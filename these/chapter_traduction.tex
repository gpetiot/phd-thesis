
\chapter{Traduction pour le test}
\label{sec:traduction}

\chapterintro


Ce chapitre détaille les règles à appliquer pour traduire des annotations \acsl
en code C sémantiquement équivalent.
Cette méthode permet d'utiliser un outil de génération de tests prenant des
programmes C en entrée, sans que ce outils n'aient à traiter les annotations
\acsl.
Le processus de traduction est présenté dans sa généralité, puis sont détaillées
les règles de traduction (du niveau le plus bas vers le niveau le plus haut) des
termes, des prédicats et des annotations \acsl.
Enfin, nous abordons les différences entre une traduction pour le test et une
traduction pour la validation à l'exécution.


\section{Processus de transformation de programme}


\input{figures/fig_grammar}

Cette section présent le processus d'instrumentation des fonctions C annotées
avec le langage d'annotations \acsl pour la génération de tests.
Pour des raisons de commodité, nous considérons qu'un label précède chaque
instruction et annotation à l'intérieur d'une fonction.
Considérons aussi la présence d'un label au début et à la fin de chaque corps de
boucle.
(Strictement parlant, les labels ne peuvent pas être placés juste avant les
déclarations de variables ou l'accolade fermante ``$\bclose$'' en C, mais
cette limitation peut être contournée par l'ajout d'une instruction ``skip''
(``\lstinline{;}'') après ces labels.)
Nous supposons que les fonctions respectent la forme normale définie par
l'entité syntactique \textit{function} de la grammaire définie
figure~\ref{fig:grammar}. 
Dans cette figure, la notation ``${\textit{as}\;X}$'' en exposant signifie que
chaque occurrence de $X$ dans la règle courante doit être remplacée par la
chaîne à laquelle on fait référence en exposant.
Par exemple, si \texttt{foo} est le nom ($id$) de la fonction sous test dans la
règle $function$, les labels $\texttt{Beg}_f$ et $\texttt{End}_f$ dans le corps
de cette fonction sont remplacés par $\texttt{Beg}_{\texttt{foo}}$ et
$\texttt{End}_{\texttt{foo}}$, ce qui assure des labels uniques au début et à la
fin du corps de la fonction.
Les accès aux pointeurs et aux tableaux sont notés \lstinline|*(p+i)|.
Les symboles terminaux sont présentés en police \texttt{typewriter}.
Les symboles non-terminaux \underline{soulignés} ne sont pas détaillés car ils
font partie des langages C ou \acsl.
$Termes$ et $predicats$ sont des expressions \acsl qui sont décrits en
section~\ref{sec:term} et section~\ref{sec:pred}.


\subsection{Sous-langage considéré}

Le langage de spécification \eacsl est un sous-langage exécutable d'\acsl, qui
est un langage de spécification comportementale implémenté dans \framac.
Premièrement, étant un sous-ensemble d'\acsl, \eacsl préserve la sémantique
d'\acsl, ce qui implique que les greffons de \framac existants supportant \acsl
peuvent être utilisés avec \eacsl sans modification.
Deuxièmement, le langage \eacsl est \textit{exécutable}, ce qui veut dire que
toutes les annotations peuvent être traduites en C et exécutées, il peut donc
être utilisé pour l'analyse dynamique et le \textit{monitoring} (surveillance
d'exécution).

\eacsl est basé sur une logique du premier ordre typée dans laquelle chaque
terme peut contenir des expressions C pures (sans effets de bord) et des
mots-clés du langage.
Par exemple, le mot-clé \lstinline{\result} permet de faire référence au
résultat d'une fonction, \lstinline{\valid} est un prédicat qui renvoie vrai si
son argument est un pointeur valide (se référer au manuel du
langage~\cite{\citeacsl}).
Les quantificateurs existentiels et universels sont bornées par des contraintes
de domaines finis d'entiers afin de rester exécutable.
Un contrat de fonction à la \textsc{Eiffel} \cite{eiffel} peut être associé à
chaque fonction pour spécifier les pré- et postconditions.
Ces contrats peuvent définir des comportements (\lstinline{behaviors}) gardés et
nommés, pour lesquels l'exhaustivité (\textit{completeness}) et/ou la séparation
(\textit{disjointness}) peut être requise.
Les assertions, les invariants de boucle et les variants peuvent aussi être
associés aux instructions.
Abordons maintenant deux des choix les plus importants du langage: les entiers
mathématiques et la non-définition (nous utiliserons le terme anglais
\textit{undefinedness}).


\subsubsection{Entiers mathématiques}\label{sec:eacsl-integers}


En plus des entiers machine, les termes \eacsl peuvent être des entiers
mathématiques de type \lstinline{integer} : les constantes entières, les
opérations sur les entiers, ainsi que les variables logiques sont de type
\lstinline{integer}.
L'arithmétique entière est non bornée et donc les débordements d'entier
(\textit{overflows}) sont impossibles.
\eacsl dispose d'un système de sous-typage pour convertir automatiquement les
types entiers du C vers les entiers mathématiques.
Par exemple, si \lstinline{x} est une variable C de type \lstinline{int},
\lstinline{x+1} et \lstinline{1} sont de type \lstinline{integer} et une
conversion implicite d'\lstinline{int} vers \lstinline{integer} est introduite
dans ce contexte quand la variable \lstinline{x} est typée.
Ce choix a été fait pour plusieurs raisons.
Premièrement, un des buts principaux de \framac est la preuve de programmes par
appels à des prouveurs externes, la plupart de ces prouveurs fonctionnent mieux
avec l'arithmétique entière qu'avec l'arithmétique bornée (ou modulaire).
Deuxièmement, les spécifications sont habituellement écrites sans se préoccuper
des détails d'implémentation, et les débordements d'entiers sont des détails
d'implémentation.
Troisièmement, il reste possible d'utiliser l'arithmétique bornée si besoin en
utilisant des conversions explicites (\textit{casts}).
Par exemple, \lstinline{(int)(INT_MAX + 1)} est égal à \lstinline{INT_MIN}, la
plus petite valeur représentable de type \lstinline{int}.
Quatrièmement, ce choix facilite l'expression des débordements potentiels dans
les spécifications : par exemple, grâce à l'arithmétique entière,
\lstinline{/*@ assert INT_MIN <= x+y <= INT_MAX;*/} est le moyen le plus simple
de spécifier que \lstinline{x+y} ne déborde pas.
Dans la suite, sauf mention contraire, ``entier'' fait référence à
``entier non-borné''.


\subsubsection{Undefinedness}\label{sec:undefined}


\eacsl est exécutable.
Cependant, l'évaluation de termes indéfinis comme \lstinline{1/0} n'est pas
possible.
Pour résoudre ce problème, \eacsl suit la sémantique de vérification à
l'exécution définie par Chalin~\cite{chalin10}, selon laquelle la sémantique de
tels termes est ``indéfinie'' (\textit{undefined}) : \eacsl utilise une logique
tri-valuée~\cite{konikowska91} comme \textsc{Spark2014}~\cite{sparkERTS2014} ou
\jml \cite{\citejml}.
Il est de la responsibilité des outils interprétant \eacsl de s'assurer que les
termes indéfinis ne sont jamais évalués.
Une conséquence indirecte de ce choix est qie les opérateurs \lstinline{&&}\,,
\ \lstinline{||}\,, \ \lstinline{_?_:_} \ et\ \lstinline{==>} sont
``paresseux'' (comme leur équivalent C pour les trois premiers).


\subsection{Support des entiers mathématiques}\label{sec:integers}


\lstinputlisting[style=c,escapechar=§,caption={Propriétés des entiers : faux
    négatif dû à une traduction naïve},label=lst:Z:1]
                {listings/naive_false_negative.c}

\lstinputlisting[style=c,caption={Propriétés des entiers : faux positif dû à
    une traduction naïve},label=lst:Z:2]
                {listings/naive_false_positive.c}


Le listing~\ref{lst:Z:1} et le listing~\ref{lst:Z:2} montrent deux exemples où
une traduction naïve des annotations contenant des entiers mathématiques mènent
à un résultat incorrect.
Soit \lstinline'x' de type \lstinline'int'.
L'assertion ligne 1 du listing~\ref{lst:Z:1} est fausse lorsque
\lstinline'x = INT_MAX'.
La traduction naïve de cette assertion (ligne 3) utilise les entiers machine
avec arithmétique modulaire (supposons une architecture 32 bits), donc
\lstinline'x+1' reste inférieur ou égal à \lstinline'INT_MAX' pour toute valeur
de \lstinline'x', rendant tout échec de l'assertion impossible.
La traduction correcte pour cette annotation (lignes 6--9) conserve la
sémantique de l'arithmétique entière non bornée en utilisant une bibliothèque
externe (nous avons choisi GMP, la bibliothèque GNU Multi-Precision) pour
représenter les valeurs pouvant provoquer un débordement d'entier (ici
\lstinline'INT_MAX+1').
Les variables nécessaires pour la gestion des entiers non bornés sont crées et
initialisées, puis le résultat est calculé et les comparaisons sont faites en
tant qu'entier non borné.
Le second exemple (listing~\ref{lst:Z:2}) définit une assertion \eacsl (ligne 2)
qui est toujours correcte : pour tout entier positif \lstinline'x', son
successeur est aussi positif.
Une traduction naïve de cette annotation (ligne 3) génèrera une erreur à
l'exécution pour \lstinline'x = INT_MAX' : en arithmétique modulaire
\lstinline'x+1' déborde et devient négatif, violant l'assertion ligne 2.
Une traduction correcte utilisant les entiers non bornés (non présentée ici)
conserve le comportement attendu : l'assertion est vraie pour tout entier
positif \lstinline'x'.
Une traduction naïve des annotations dans ces deux exemples résulterait en un
faux négatif dans le premier cas et en un faux positif dans le deuxième cas, ce
qui porterait atteinte à la correction et à la précision de notre méthode.
Les règles de traduction pour les constructions \eacsl que nous présentons
respectent la sémantique des entiers non bornés d'\eacsl et suppose
l'utilisation d'une bibilothèque externe telle GMP, comme illustré dans le
listing~\ref{lst:Z:1}.

Pour simplifier la lecture des insertions de code générées par la traduction,
nous utilisons la notation abrégée ${}^{\square}$\lstinline{var} pour indiquer
que la variable \lstinline{var} doit être déclarée et allouée (avec
\lstinline{Z_t var; Z_init(var);}) au début de la portion de code insérée, et la
notation \lstinline{var}${}^{\boxtimes}$ pour indiquer que la variable
\lstinline{var} doit être désallouée (avec \lstinline{Z_clear(var);})
à la fin du code inséré.
Nous soulignons les fragments de code afin d'indiquer que l'opération effectuée
(affectation, comparaison, \dots) utilise l'arithmétique non bornée est doit
être traduite en utilisant les fonctions correspondantes d'une bibliothèque
comme GMP.
Les lignes 12--13 du listing~\ref{lst:Z:1} illustrent la notation abrégée de 
l'instrumentation des lignes 6--9.
\framac explicite les conversion de type implicites dans les annotations, donc
le terme \lstinline'x+1' ligne 1 du listing~\ref{lst:Z:1} devient
\lstinline'(integer)(x+1)'.


\subsection{Principes généraux}
\label{sec:principles}


\lstinputlisting[style=c,escapechar=§,caption={Instrumented version of program
    of Listing~\ref{lst:normalized}},label=lst:abbrv]
                {listings/is_present_instrumented.c}


Présentons maintenant les principes de la traduction d'une fonction $f$ annotée
respectant la grammaire de la figure~\ref{fig:grammar}.
Premièrement, chaque valeur d'entrée \lstinline'x' (un paramètre formel de la
liste $params$ ou une variable globale) de type $T$ est mémorisée par
l'instruction \lstinline|T old_x = x;| au début de la fonction sous test
instrumentée, c'est-à-dire au label $Beg_f$, dans la section $decl^*$.
Pour chaque tableau ou pointeur \lstinline'x', les valeurs pointées sont
mémorisées dans un tableau alloué dynamiquement \lstinline'old_val_x' dont la
taille est inférée à partir du prédicat \lstinline'\valid' dont on suppose la
présence en précondition de la fonction sous test.
%% We also generate an additional function named \lstinline'f_precond'
%% that is used to check the precondition of the FUT. For the  FUT  we ensure
%% that the precondition is assumed by inserting 
%% \lstinline|fassume(f_precond(x1, ..., xn));| 
%% at label $Beg_{f}$
%% (cf line 11 in Listing~\ref{lst:abbrv}).

Deuxièmement, toute annotation \eacsl de la forme \lstinline'kwd w' (où
\lstinline'kwd' $\in$ $\bopen$ \lstinline|assert|, \lstinline|requires|,
\lstinline|typically|, \lstinline|ensures|, \lstinline|loop variant|,
\lstinline|loop invariant|, \lstinline|assigns|, \lstinline|loop assigns|
$\bclose$ et \lstinline'w' est un terme ou un prédicat) est traduite.
D'autres constructions \eacsl ne sont pas détaillées ici car elles peuvent être
obtenues à partir du fragment \eacsl décrit.
Par exemple, les behaviors peuvent être réécrits comme des implications dans les
clauses \lstinline'ensures' et les contrats d'instruction peuvent être réécrits
comme des implications dans des assertions.
%% global (resp., loop or statement)
%% \lstinline|assigns| clauses can be rewritten as postconditions
%% (resp., loop invariants or assertions)
%% checking the non-modification of some variables.

Chaque paire, $(label, annotation)$ est traduite en une séquence
d'\emph{insertions de code}
$(l_1, c_1) \concat (l_2, c_2) \concat \ldots \concat (l_n, c_n)$, qui 
represente une liste de fragments de programmes C $c_1, c_2, \ldots, c_n$ où
le fragment $c_i$ sera inséré dans le programme instrumenté au label $l_i$.
Les annotations \eacsl sont traduites séparément et les séquences de fragments
résultant de la traduction sont traitées en suivant l'ordre des annotations dans
le programme.
Quand plusieurs fragments doivent être insérés au même endroit $l$, ils sont
insérés en respectant leur ordre dans la séquence (l'ordre dans lequel ils ont
été générés).

La traduction d'annotations est définie par les règles de la
section~\ref{sec:annot}.
Cela requiert de traduire les termes et les prédicats \eacsl.
Ces transformations sont décrites par les règles des sections~\ref{sec:term}
et~\ref{sec:pred}.
Dans ces règles, les notations suivantes sont utilisées :
\begin{itemize}
\item $p$, $p_1$, $p_2$ et $p_3$ sont des prédicats \eacsl;
\item $t$, $t_1$, $t_2$ et $t_3$ sont des termes \eacsl et $w$ est un prédicat
  ou un terme;
\item $c$, $c_1$, $c_2$ et $c_3$ sont des fragments de programmes C;
\item $e$, $e_1$, $e_2$ et $e_3$ sont des expressions C;
\item $l$, $l_1$, $l_2$, $l_3$, $Beg_f$, $End_f$, $BegIter_l$ et $EndIter_l$ sont
  des labels du programme;
\item $i$ est un identifiant de variable liée dans un prédicat \eacsl et un
  compteur d'itérations dans un programme C, $x$ est un identifiant de
  variable C;
\item $I$, $I_1$, $I_2$ et $I_3$ sont des listes d'insertions de code
  $(l_i, c_i)$.
\end{itemize}

Les variables \lstinline'res', \lstinline'var_n', \lstinline'i_n',
\lstinline|old_x|, \lstinline'old_val_x' et \lstinline|old_variant| sont
``fraîches'' (fresh), c'est-à-dire que ces identifiants sont supposés différents
de tous les autres identifiants de variables du programme instrumenté :
quand on utilise plusieurs fois une règle introduisant une variable fraîche,
toutes les occurrences de la variable créée doivent être différentes.
Ceci peut être implémenté en incrémentant le compteur $n$ à chaque occurrence
dans \lstinline'var_n' et \lstinline'i_n', et en utilisant le nom de la variable
d'origine à la place de $x$ dans \lstinline'old_x' et \lstinline'old_val_x'.

Pour des raisons de commodité, nous supposons que toutes les variables logiques
liées dans les annotations et toutes les variables du programme sont
différentes, ceci nous permet en particulier de traduire les variables logiques
en C sans les renommer.


\subsubsection*{Exemple}
\label{sec:translation-example}


\lstinputlisting[style=c,escapechar=§,caption={Annotated C function deciding if
    \lstinline{v} is present in array \lstinline{t} of size \lstinline{n}},
  label=lst:normalized]{listings/is_present_normalized.c}

Nous présentons dans le listing~\ref{lst:normalized} un exemple de fonction sous
test normalisée en suivant la grammaire de la figure~\ref{fig:grammar}.
Elle retourne $1$ quand la valeur $v$ en paramètre est présente dans le tabbleau
$t$ en paramètre, ou $0$ sinon.
Le programme instrumenté obtenu après traduction des annotations de cette
fonction est présenté (utilisant la notation abrégée pour les entiers non
bornés) dans le listing~\ref{lst:abbrv}.
La fonction précondition générée est définie lignes 1--6
(listing~\ref{lst:abbrv}), elle retourne une valeur non nulle quand la
précondition est vraie.
La clause \lstinline'requires' de la ligne 1 (listing~\ref{lst:normalized})
indique que la taille du tableau \lstinline|n| est positive, elle est traduite
en conditionnelle ligne 3 du listing~\ref{lst:abbrv}.
La clause \lstinline'requires' de la ligne 2 (listing~\ref{lst:normalized}) 
indique que \lstinline|(t+0)|$, ..., $\lstinline|(t+(n-1))| sont des pointeurs
valides, elle est traduite en conditionnelle ligne 4 du
listing~\ref{lst:abbrv}).
La clause \lstinline'typically' de la ligne 3 du listing~\ref{lst:normalized}
(traduite ligne 5 du listing~\ref{lst:abbrv}), est une extension de la syntaxe
d'\eacsl définissant une précondition pour le test.
Elle renforce la précondition pour limiter l'explosion combinatoire du nombre de
chemins à explorer par la génération de tests, elle permet d'obtenir une
couverture partielle des chemins : seuls les chemins satisfaisant cette clause
sont considérés.
Ici elle limite l'espace des états de \lstinline'n' (et donc la taille de
\lstinline't') à $[0, 6]$ (cela peut être vu comme une ``finitization''
\cite{Korat}).
L'invariant de boucle de la ligne 9 du listing~\ref{lst:normalized} est traduit
aux lignes 13--14 du listing~\ref{lst:abbrv} pour vérifier que l'invariant est
vrai avant la première itération (établissement), et aux lignes 21--22 du
listing~\ref{lst:abbrv} pour vérifier la préservation de l'invariant après
chaque itération.
(Un invariant de boucle supplémentaire 
\lstinline|\forall integer k; 0<=k<i ==> \old(*(t+k))!=v;|
nécessaire pour prouver formellement la postcondition n'est pas inclus dans cet
exemple simplifié).
Le variant de boucle ligne 10 du listing~\ref{lst:normalized} est traduit à la
ligne 15 du listing~\ref{lst:abbrv} pour vérifier que le variant est positif ou
nul avant chaque itération de la boucle, à la ligne 18 du
listing~\ref{lst:abbrv} pour mémoriser la valeur du variant au début de la
boucle, et aux lignes 23--25 du listing~\ref{lst:abbrv} pour vérifier que le
variant décroisse strictement après chaque itération, assurant ainsi la
terminaison de la boucle.
La postcondition des lignes 4-5 du listing~\ref{lst:normalized} est traduite aux
lignes 28--32 du listing~\ref{lst:abbrv}, définit que \lstinline|\result| est
non nul si et seulement si il existe un élément de \lstinline|t| égal à
\lstinline|v|.
Les valeurs des paramètres formels \lstinline|t|, \lstinline|n| et \lstinline|v|
sont mémorisées lignes 10--11 du listing~\ref{lst:abbrv}, un nouveau tableau
\lstinline|old_val_t| stocke les anciennes valeurs contenues dans \lstinline|t|,
il est alloué ligne 10, rempli ligne 11 et désalloué ligne 33.


\section{Traduction des termes \acsl}
\label{sec:term}

\input{figures/fig_rules}

Let us denote
$(l, t:T) \rulearrow ((l_1, c_1) \concat (l_2, c_2) \concat \ldots \concat (l_n, c_n), e)$
an instance of the partial function $\tau$ mapping an E-ACSL term $t$ of type
$T$ at label $l$ to the pair $(I, e)$ where $I$ is a list of code insertions
$(l_i, c_i)$, $e$ is a C expression, and $T$ can be $\mathbb{Z}$ (integer) or
$ctype$. We only consider
the following types as included in $ctype$: $ptr$,
that can be a pointer of any type, and \lstinline'int' that is the regular C
type. Other integral C types such as \lstinline'char', \lstinline'long',
\lstinline'unsigned' could be supported in the same way, but are not considered
for simplicity and readability purposes.
The expression $e$ is pure (i.e. has no side
effects) and evaluates the value of the term at the given point.
%(that is usually computed by the inserted program fragments $c_i$).  
The evaluation of $e$ often requires additional
computations, that are performed by the inserted program fragments
resulting from the predicate and term translation. For example, a quantified
term requires the computation of a value throughout a \lstinline|for| loop
(see Fig.~\ref{fig:builtin}). In this case, the second element of the returned
pair, $e$, is the value of a variable computed by the loop.
When a term $t$ can be directly translated without additional C code, 
the sequence of code insertions is empty and denoted $\emptyset$.
For a term $t:\mathbb{Z}$,
the translation result $e$ is always a variable of type \lstinline'Z_t'
(that justifies de-allocation \lstinline{e}${}^{\boxtimes}$ e.g. in Fig.~\ref{fig:coerce}).

Fig.~\ref{fig:const-id} describes the rules for identifiers
(\textsc{$\tau$-var}), for the \lstinline|\result| term
(\textsc{$\tau$-res}) and constants (\textsc{$\tau$-const}).
Two rules are considered for the ACSL construct \lstinline|\old|.
Applied to an identifier $x$, it is translated as the fresh variable
\lstinline|old_x| storing the value at the entry of the function.
Applied to a memory access (rule \textsc{$\tau$-old-val}), we use the dynamically
allocated array \lstinline|old_val_x| that memorizes the elements of an array
\lstinline|x| at the entry of the function (cf Sec.~\ref{sec:principles}).
The special term \lstinline|\result| translated by the rule
\textsc{$\tau$-res} denotes the return value of the function in
\textsc{ACSL} written into the fresh variable   \lstinline|res|.
That variable is unique after the normalization of the abstract syntax tree (AST) by
\textsc{Frama-C}. 
The rule \textsc{$\tau$-const} states that an integer variable is defined to
store the integer constant.

Fig.~\ref{fig:coerce} details the rules for coercions, from integer to C type
and from C type to integer.

Fig.~\ref{fig:op} details the rules for unary operations
(\textsc{$\tau$-unop$_*$}),
binary operations (\textsc{$\tau$-binop$_*$}) and the ternary condition on terms
(\textsc{$\tau$-if}).
\textsc{$\tau$-unop$_1$} deals with pointer indirection ($\star$).
In \textsc{$\tau$-unop$_2$}, the logical not (\lstinline|!|) does not involve
integers.
In \textsc{$\tau$-unop$_3$}, $op$ is the unary minus (\lstinline|-|) or the
bitwise complement ($\sim$) and is an operation from and to integer.
In \textsc{$\tau$-binop$_1$}, the left operand is a pointer so $op$ must be
\lstinline|+| or \lstinline|-|, whereas the right operand is an $int$
(if it is an integer, it will be coerced to $int$ using the rule
\textsc{$\tau$-coerce$_1$} for pointer arithmetics).
In \textsc{$\tau$-binop$_2$}, $op$ is a comparison operator over integer values
and the result of the comparison is stored in an \lstinline|int|.
In \textsc{$\tau$-binop$_3$}, $op$ is any of the arithmetic
operators: \lstinline|+|, \lstinline|-|, \lstinline|/|, \lstinline|%|,
\lstinline|<<|, \lstinline|>>|, \lstinline{|}, \lstinline|&|, \lstinline|^|
over integers.
In the rule \textsc{$\tau$-if}, the evaluation of $t_2$ and $t_3$ are in
conditional branches: only one of them is computed, depending on the evaluation
of $t_1$.






Fig.~\ref{fig:builtin} presents the rules for translating the builtin
logic functions \lstinline|\sum| (\textsc{$\tau$-sum}) and \lstinline|\numof|
(\textsc{$\tau$-numof}). % and \lstinline|\min| (\textsc{$\tau$-min}).
The rule for function %\lstinline|\max| and
\lstinline|\product| is similar 
to the rule % \textsc{$\tau$-min} and
\textsc{$\tau$-sum}.
%respectively.
The rule \textsc{$\tau$-sum} over integers initializes a fresh integer variable
\lstinline|var_n|, initialized to $0$, and increments its value with the value
of the \lstinline|\lambda|-term \lstinline't3' at each iteration.
The rule \textsc{$\tau$-numof} also initializes a fresh integer variable
\lstinline|var_n| to $0$, but increments it only when the (non-integer)
\lstinline|\lambda|-term \lstinline't3' is evaluated to a non-null expression.



\section{Traduction des prédicats \acsl}
\label{sec:pred}

Similarly to the translation function $\tau$ for terms (see
Sec.~\ref{sec:term}), the translation function for predicates, denoted $\pi$,
is defined as a partial function mapping a label and an \textsc{ACSL} predicate
to a sequence of code insertions
$(l_i, c_i)$ and a C expression $e \in \{0, 1\}$.
When a predicate $p$ can be directly translated without additional C code, 
the sequence of code insertions is empty and denoted $\emptyset$.


We define in Fig.~\ref{fig:pred-logic},
Fig.~\ref{fig:valid} and Fig.~\ref{fig:quantif} the transformation rules for the
main \textsc{ACSL} predicates we handle.

Fig.~\ref{fig:pred-logic} details the translation rules for the simplest
predicates of the \textsc{ACSL} language. The rules \textsc{$\pi$-true} and
\textsc{$\pi$-false} state that $true$ (resp. $false$) are translated into $1$
(resp. $0$). The rules \textsc{$\pi$-equiv} and
\textsc{$\pi$-not} are
compositional: the subpredicates are translated recursively, then the result of
the translation of the predicate is rebuilt from the values of the subpredicates.
The rules \textsc{$\pi$-and},
\textsc{$\pi$-or} and \textsc{$\pi$-impl} are reflective of the laziness of
the \textsc{ACSL} semantics of those operators: the first operand is always
evaluated (in $I_1$) but the second one is only evaluated (in $I_2$) when necessary. The rule
The rule \textsc{$\pi$-if} is the counterpart of \textsc{$\tau$-if} (cf
Sec.~\ref{sec:term}) for predicates.
In our running example of Listing~\ref{lst:normalized}, translating 
the postcondition
\lstinline{\result != 0 <==> \exists integer i; 0<=i<n && *(t+i)==v} requires
the translation of the predicates \lstinline|\result != 0| and
\lstinline{\exists(...)} that are respectively translated as \lstinline|var_32|
and \lstinline|var_35|. These two predicates are put together to build the
translation of
the composed predicate, that is, according to \textsc{$\pi$-equiv},
\lstinline{(!var_32 || var_35) && (!var_35 || var_32)} (line 32 of
Listing~\ref{lst:abbrv}).
In the rule \textsc{$\pi$-rel}, \lstinline|op| is any of these
operators: \lstinline[style=c]{<, <=, >, >=, ==, !=}.

Fig.~\ref{fig:valid} shows the translation rules for the \lstinline|\valid|
predicate that holds if its parameter points to a valid memory location and can
be dereferenced. 
Basic usages are
\lstinline{\valid(t)} 
%and \lstinline|\valid(t1+t2)| 
%(that is a generalization of
%the previous with $t_2$ equal to $0$) 
for checking  the validity of a single 
pointer \lstinline{t},
%or of pointer \lstinline{t1} with offset \lstinline{t2}, 
and \lstinline|\valid(t1+(t2..t3))| for checking the validity of 
pointer \lstinline{t1} within offset range \lstinline|t_2..t_3|. The rules \textsc{$\pi$-valid} and
\textsc{$\pi$-valid-range} cover both usages. We assume that we can
evaluate the validity of the memory location a pointer points to by the means of
a function \lstinline|fvalid|, and the validity of a pointer 
within an offset range by \lstinline|fvalidr|.
In our running example of Listing~\ref{lst:normalized}, the predicate
\lstinline|\valid(t+(0..n-1))| in the \lstinline|requires| clause of line 2 is
translated to \lstinline[style=c]|fvalidr(t,0,(n-1))| (line 4 of
Listing~\ref{lst:abbrv}).
Full support of these predicates requires a precise low-level
memory representation.

The rules \textsc{$\pi$-exists}
(Fig.~\ref{fig:quantif}) translates the existentially
quantified predicate \lstinline|\exists| other integer values.
It updates
a variable \lstinline|var_n| (initially set to $false$) at each iteration of the
loop until all values of \lstinline|i| are considered or  
until \lstinline|var_n| is evaluated to $true$.
This rule also treats the universally quantified predicate
(l, \lstinline{\forall integer i; t1<=i<t2 ==> p}) since it
is equivalent to 
(l, \lstinline{! (\exists integer i; t1<=i<t2 && !p)}).
In Listing~\ref{lst:normalized}, the quantified predicate
\lstinline{\exists integer i; 0<=i<n && *(t+i)==v} of 
line 4 is translated in lines 29--31 of Listing~\ref{lst:abbrv}
and the fresh variable containing the value of the predicate after its
evaluation is \lstinline|var_35| (declared at line 29).


\section{Traduction des annotations \acsl}
\label{sec:annot}

Now we  define the translation rules for annotations that allow to trigger 
annotation failures and 
enforce 
test generation of erroneous inputs. For each annotation, a fragment of a C
program ending by a condition test is inserted into the program. The test
generator will try to cover all feasible paths, thus activating the error if
such inputs exist. The rules are of the following form:

\vspace{-4mm}
\[
\dfrac
    {(l_1, w) \rulearrow (I_1, e_1) \quad \ldots \quad
      (l_n, w) \rulearrow (I_n, e_n)}
    {(l, \mathtt{kwd\ w;}) \rulearrow
      g_{kwd} (l, (I_1, e_1), \ldots, (I_n, e_n))}
\]
\vspace{-4mm}



This rule pattern states that if the term or predicate $w$ at label $l_i$
is translated (by $\tau$ or $\pi$) as
$(I_i, e_i)$, then the property $kwd\ w$ involving $w$ at
program point $l$ will be translated by some composition 
function of code insertions of each
$I_i$ and of the expressions $e_i$. 
The particular composition function, denoted $g_{kwd}$, depends on
the annotation kind.
In Fig.~\ref{fig:annot} and Fig.~\ref{fig:loop-annot} we present the
translation rules for each annotation kind. Suppose \lstinline|fassert| is a C
function checking an expression. We define the condition $e$ that
must be tested for each annotation. The test is expressed by applying the
function \lstinline|fassert|, that is expanded to a conditional \lstinline|if|.
Test generation tries to cover both branches. If the expected property is
false, the failure is reported and the
exploration switches to another branch.

Fig.~\ref{fig:annot} describes the translation rules for an assertion at label $l$
(\textsc{$\alpha$-assert}), a postcondition (\textsc{$\alpha$-post}) and
a precondition (\textsc{$\alpha$-pre})
that are considered to be stated resp. at labels $End_f$ and $Beg_f$. 
The rule \textsc{$\alpha$-assert}
simply checks the translated predicate at label $l$ with the function
\lstinline|fassert|. The rule \textsc{$\alpha$-post} checks the predicate at
the end of the function being translated. The rule \textsc{$\alpha$-pre} checks
the predicate of a precondition in a separate function that we call
\lstinline'f_precond', returning $0$ if one of the \lstinline|requires| or
\lstinline|typically| clauses does not hold, or $1$ otherwise. This function
has to be called with the same formal parameters as the function
being translated.
Since the precondition is \emph{assumed} for the function under test
and must be \emph{ensured} for a called function,
its result has to be {\em asserted} in the case
of a {\em callee}  and {\em assumed} in the case of the function under
test.
So for each function, a check 
\lstinline|fassert(h_precond(x1, x2, ..., xn));| (resp.
\lstinline|fassume(h_precond(x1, x2, ..., xn));|) is inserted at the label
$Beg_h$ if $h$ is a {\em callee} (resp. FUT), where
$x_1, x_2, ..., x_n$ are the formal parameters of $h$, and
the \lstinline|fassume| function restricts 
test generation to input values for which it returns true.
In the example of Listing~\ref{lst:normalized}, the
\lstinline|requires| clause lines 1-2 and the \lstinline|typically| clause line
3 are translated to the lines 3--5 of Listing~\ref{lst:abbrv}. The validity of the
\lstinline'is_present_precond' precondition is {\em assumed} line 11 of
Listing~\ref{lst:abbrv}. Finally, the \lstinline|ensures| clause lines 4-5 is
translated as lines 28--32 in Listing~\ref{lst:abbrv}. 

The translation rules for the loop invariants (\textsc{$\alpha$-invariant}) and
loop variants (\textsc{$\alpha$-variant}) for a loop at label $l$ are presented in
Fig.~\ref{fig:loop-annot}. The rule \textsc{$\alpha$-invariant} checks the
predicate of the loop invariant before the loop, and after
each iteration of the loop (i.e. at the predefined label $EndIter_l$). The rule
\textsc{$\alpha$-variant} checks that the variant term is non-negative at the
beginning of each iteration,
then the previous value of the variant is saved at the begining of the loop
iteration in a fresh variable 
\lstinline|oldvariant|. Finally, it checks at the end of each iteration that
the current value of the variant is strictly
decreasing (compared to its value in the previous iteration).
In the running example of Listing~\ref{lst:normalized}, translating the
\lstinline|loop invariant| line 9 results in lines 13--14 and 21--22 in
Listing~\ref{lst:abbrv}, while translating the \lstinline|loop variant| line 10
results in lines 15, 18 and 23--25 in Listing~\ref{lst:abbrv}.


\section{Différences entre le Test et la Validation d'Assertions à l'Exécution}


Instrumentation based translation of ACSL annotations into C code 
has been implemented in two \framac \cite{\citeframac} plugins:
\eacsltoc \cite{Delahaye/SAC13,Kosmatov/RV13} that generates an instrumented program
for Runtime Assertion Checking (RAC), and \stady, that instruments a program for Test Generation with
\pathcrawler \cite{\citepathcrawler}. 
This section  discusses similarities and differences between both kinds of instrumentation.

Test generation and runtime checking both need to
generate executable code and so consider only an executable subset of the
specification language. 
Therefore, most rules defined in Sec. \ref{sec:term}, \ref{sec:pred} and \ref{sec:annot} 
for test generation are also valid for RAC.

\textbf{Precondition of the function under test (FUT).}
One difference is the treatment of the precondition of the FUT.
In RAC, it is usually checked as any other annotation.
In test generation, it is used to avoid testing the program on inadmissible values 
for which the program is not supposed to work correctly.
Hence, the precondition  of the FUT should be assumed during test generation
to ensure that all generated test inputs respect the precondition of the FUT.

Besides, the treatment of the precondition of the FUT in \pathcrawler has two optimizations.
First, an internal mechanism of unquantified and quantified preconditions
allows a direct translation of ACSL preconditions into constraints
supported in an efficient manner.
Hence, for precondition patterns that can be expressed by this mechanism,
a translation into C code is not necessary for \pathcrawler.
Second, for the remaining preconditions translated into a C function, 
\pathcrawler offers a specific
efficient mechanism \cite{Delahaye/RV13}.
A call to \lstinline|fassume| (adding the constraints of the
precondition to the constraint store \emph{before} the path predicate in the FUT)
can be replaced in \pathcrawler by a dedicated support for
late precondition (where precondition constraints are posted \emph{after}
other path constraints of the FUT).
Thus the call to \lstinline|fassume| for the FUT 
in \pathcrawler is not needed.

\textbf{Memory-related constructs.}
Runtime checkers also require a complex instrumentation framework
to treat memory-related constructs where each memory related operation
is instrumented and relative memory block metadata is stored
so that it can be extracted when it is necessary to evaluate a memory-related
ACSL annotation \cite{Kosmatov/RV13}.
Some of these constructs can be handled symbolically in
concolic testing without additional instrumentation.
The functions \lstinline|fvalid| and \lstinline|fvalidr| are builtin C functions
defined by \pathcrawler that return the value of validity of a pointer
\cite{testing-pointers}.
They actually support global variables and formal parameters of the function
under test.

\textbf{Unbounded integers.}
While translation of ACSL mathematical integers relying on an external library 
for unbounded integers (like GMP) is appropriate and sufficient for
RAC, it will be quite inefficient if the library function code is
directly handled by test generation.
Indeed, test generation on the instrumented code would have to 
treat much more complex code, with lots of additional function 
calls, dynamic memory allocation and de-allocation, etc.
This can be avoided again using symbolic execution of the test generation
tool. \pathcrawler offers dedicated builtin support 
for GMP numbers and operations that are efficiently translated into
appropriate constraints on unbounded integers and handled 
by the underlying constraint solver.

\textbf{Runtime errors.}
Straightforward translation of annotations into C may introduce runtime errors due to annotations
with undefined terms (such as 1/0, cf Sec. \ref{sec:undefined}). 
This issue can be easily solved for test generation exactly as proposed in \cite{Delahaye/SAC13} for RAC,
by an additional guard generation phase
by running  the \rte plugin~\cite{\citeframac} on the instrumented code
to add annotations preventing
runtime errors, and finally running the instrumentation again on these new annotations.
Runtime  errors related to unbounded integer (division of a GMP integer by 0, 
overflow during a type coersion \lstinline[mathescape=true]{(int)(t:$\mathbb{Z}$)}, etc.) 
are not treated by \rte, but they can be easily prevented 
by adding suitable checks in the corresponding rules.
For example, the downcast of a term $t$ from integer to $int$ (see the rule
\textsc{$\tau$-coerce$_1$} of Fig.~\ref{fig:coerce}) can be guarded by inserting
\lstinline{fassert(}\underline{\lstinline{INT\_MIN <= e}}\lstinline{&&}\underline{\lstinline{e <= INT\_MAX}}\lstinline{)}
before the assignment \underline{\lstinline'var_n = e'}.


\textbf{Triggering errors during test generation.}
The function \lstinline|fassert(cond)| is a C macro defined by
\textsc{PathCrawler} that is expanded as a conditional
\lstinline|if(cond)|, testing
if its parameter is true. Covering all feasible paths of the
program will therefore enforce the generation of test inputs activating the
$then$ branch of this condition, and test inputs activating the
$else$ branch. So if there exist inputs such that \lstinline'cond' is evaluated to
$false$, a test case activating the \lstinline|fassert| thus
violating the corresponding annotation is generated. In other terms, a
counter-example for that annotation is generated if such inputs exist.
