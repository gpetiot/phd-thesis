
\chapter{Traduction pour le test}
\label{sec:traduction}

\chapterintro

TODO

\section{Transformation de programme \acsl vers C}



\input{figures/fig_grammar}

This section presents the instrumentation process for C functions annotated in
\acsl that we support during test generation for
the annotated code.
It will be convenient to consider that specific labels 
are introduced for each statement and annotation inside a function body, as well
as for  the beginning and the end of each function body and loop body. 
(Strictly speaking, labels cannot be put just before declarations or ``\lstinline|}|'' in C, but this
can be easily fixed by adding a skip instruction ``\lstinline{;}'' after such
labels.)
We assume that functions respect the normal form defined by the syntactic
entity \textit{function} from the grammar in Fig.~\ref{fig:grammar}. 
In this
figure, the superscript ``${\textit{as}\;X}$'' means that any occurrence of $X$
in the analysis of the current rule should be replaced with the string referred
by the superscripted syntactic entity.
For example, if \texttt{foo} is the name $id$ of the analyzed function in the
rule $function$, labels $\texttt{Beg}_f$ and $\texttt{End}_f$ in this function's
body are replaced by $\texttt{Beg}_{\texttt{foo}}$ and $\texttt{End}_{\texttt{foo}}$
providing unique labels for the beginning and the end of the function body.
Array and pointer accesses are supposed to be written as \lstinline|*(p+i)|.
The terminal symbols are presented in a \texttt{typewriter font}.
\underline{Underlined} non-terminal symbols are not detailed because they are
part of the C or ACSL languages.
$Terms$ and $predicates$ are ACSL expressions, most of them are described in
Sec.~\ref{sec:term} and Sec.~\ref{sec:pred}.



\subsection{Sous-langage considéré}

The specification language \eacsl is a strict executable subset of \acsl, which
is a behavioral specification language implemented in \framac. On the one hand,
designed as a subset of \acsl{}, \eacsl{} preserves \acsl{} semantics.
Therefore, existing \framac analyzers supporting \acsl{} continue to be used
with \eacsl{} without any change. On the other hand, the \eacsl{} language is
\textit{executable}, that is, all its annotations can be translated into C and
executed at runtime.  Thus it can be used by dynamic analyses and monitors.  Due
to these two specific features %(preserving \acsl{} semantics and being
%executable), 
\eacsl{} facilitates combinations of static and dynamic analyses.

\eacsl is based on a typed first-order logic in which terms may contain
\textit{pure} (\emph{i.e.} side-effect free) C expressions and special keywords.
For instance, the \lstinline{\result} keyword allows the user to talk about the
result of a function, while \lstinline{\valid} is a builtin predicate stating
that its argument is a valid pointer. Quantifications are bounded by constraints
to finite intervals of integers
in order to remain executable. An \textsc{Eiffel}-like contract \cite{eiffel}
may be associated to each function in order to specify its pre- and
postconditions. These contracts may be split into several named guarded
behaviors for which the users may require completeness and/or
disjointness. Assertions, loop invariants and loop variants may also be
associated to statements. We now focus on two of the most important design
choices of the language: integers and undefinedness.

\subsubsection{Integers}\label{sec:eacsl-integers}

In addition to all machine types, \eacsl terms also include mathematical
integers of type  \lstinline{integer}: integer constants and operators, as well as logic variables are of
this type. Integer arithmetics is unbounded and never
overflows. \eacsl holds a small subtyping system to automatically coerce C
integral types into mathematical integers. For instance, if \lstinline{x} is a C
variable of type \lstinline{int}, \lstinline{x+1} and \lstinline{1} are of type
\lstinline{integer} and a coercion from \lstinline{int} to \lstinline{integer} is
introduced when typing \lstinline{x} in this context. This design was chosen for
several reasons. First, one of the main goals of \framac is program proving by
discharging proof obligations to automatic theorem provers. Such provers usually
work much better with mathematical arithmetics than with \textit{modular
  arithmetics}, that is, bounded arithmetics with overflows.  Second,
specifications are usually written without any implementation detail in mind,
and potential overflows are implementation details. Third, it is still possible
to use bounded modular arithmetics when required by using explicit casts: for
instance, \lstinline{(int)(INT_MAX + 1)} is equal to \lstinline{INT_MIN}, the
smallest representable value of \lstinline{int}. Fourth, this choice makes it
much easier to talk about potential overflows in specifications: for example,
thanks to mathematical arithmetics, 
\lstinline{/*@ assert INT_MIN <= x+y <= INT_MAX;*/} specifies in the easiest way
that \lstinline{x+y} must not overflow.
Unless otherwise stated, ``integer'' will refer below to ``unbounded integer''.

\subsubsection{Undefinedness}\label{sec:undefined}

\eacsl is executable. However, evaluation of undefined terms like \lstinline{1/0} is not
possible. To solve this issue, \eacsl follows Chalin's Runtime Assertion
Checking semantics~\cite{chalin10} by stating that semantics of such terms is
``undefined'': \eacsl uses a 3-valued logic~\cite{konikowska91} like
\textsc{Spark2014}~\cite{sparkERTS2014} or \jml~\cite{assert}. It is
then the responsibility of the tools interpreting \eacsl{} to ensure that an
undefined term is never evaluated. An indirect consequence of this design is
that operators \lstinline{&&}\,, \ \lstinline{||}\,, \ \lstinline{_?_:_} \ and
\ \lstinline{==>} \ in \eacsl are lazy (like the C counterparts for the first
three of them).


\subsection{Support des entiers mathématiques}\label{sec:integers}


\lstinputlisting[style=c,escapechar=§,caption={Properties over integers: naive
    instrumentation gives false negative},label=lst:Z:1]
                {listings/naive_false_negative.c}

\lstinputlisting[style=c,caption={Properties over integers: naive
    instrumentation gives false positive},label=lst:Z:2]
                {listings/naive_false_positive.c}


Listing~\ref{lst:Z:1} and Listing~\ref{lst:Z:2} exhibit two examples where 
naive translation of annotations with mathematical integers leads to unsoundness.
 Let  \lstinline'x' be of type \lstinline'int'.
The assertion at line 1 of Listing~\ref{lst:Z:1}
is obviously false when \lstinline'x = INT_MAX'. 
The naive translation of this assertion
(line 3) uses machine integers with modular arithmetics
(we assume a 32-bit architecture), so 
\lstinline'x+1' remains less or equal to \lstinline'INT_MAX' for any value of
\lstinline'x', making it impossible to find the assertion violation.
The correct translation for this annotation
(sketched at lines 6--8) maintains the semantics of unbounded integer arithmetics
using an external unbounded integer library (we use GMP, the GNU Multi-Precision library)
to represent values that may overflow otherwise (like
\lstinline'INT_MAX+1' here).
It creates and initializes necessary variables for unbounded integers,
then computes and compares the values as unbounded integers.
The second example (Listing~\ref{lst:Z:2}) defines an ACSL assertion
(line 2) that is always correct here: for any positive integer \lstinline'x',
its successor also is positive. The naive instrumentation
(line 4) will exhibit an error for \lstinline'x = INT_MAX':
due to modular arithmetics, \lstinline'x+1' overflows and becomes negative,
violating the assertion. A correct translation using unbounded integers 
(not detailed here)
%(lines 7--9) 
maintains the expected behavior, so that the assertion remains valid for any positive integer
\lstinline'x'.
Using the naive translation for these two examples would result in a
false negative in the first case, and in a false positive in the second case,
undermining the tool's correctness and precision.
The translation rules for E-ACSL constructs %terms and predicates 
presented below %in Sec. \ref{sec:pred}, \ref{sec:term} and \ref{sec:annot} 
respect unbounded integer semantics of E-ACSL mathematical integers and
assume the usage of an external library as illustrated in Listing~\ref{lst:Z:1}.
To simplify the notation of code insertions, we will use the abbreviated notation
${}^{\square}$\lstinline{var} 
to indicate that the variable \lstinline{var} must be declared and
allocated (with \lstinline{Z_t var; Z_init(var);})
at the beginning of the inserted code, and the notation
\lstinline{var}${}^{\boxtimes}$ 
to indicate that the variable \lstinline{var} must be de-allocated
(with \lstinline{Z_clear(var);})
at the end of the inserted code.
We will also use underlined code fragments to indicate that the corresponding
operation (assignment, comparison, \dots) should be translated using
corresponding functions from the unbounded integer library.
So line 12 of Listing~\ref{lst:Z:1} illustrates abbreviated notation of 
instrumentation for lines 6--9.
As mentioned in Sec. \ref{sec:eacsl-integers}, %we assume that all 
type coersions  
are automatically made explicit in the annotations in \framac, 
so \lstinline'x+1' in line 1 of Listing~\ref{lst:Z:1}  becomes \lstinline'(integer)x+1'.


\subsection{Principe général}
\label{sec:principles}


\lstinputlisting[style=c,escapechar=§,caption={Instrumented version of program
    of Listing~\ref{lst:normalized}},label=lst:abbrv]
                {listings/is_present_instrumented.c}


Let us describe the principles of instrumentation for an annotated function
$f$ respecting the grammar of Fig.~\ref{fig:grammar}.
First, each input value $x$ (a formal parameter $x$ in $params$ or a global variable $x$) of type
$T$ is stored as \lstinline|T old_x = x;|
at the beginning of the instrumented FUT, i.e. at label $Beg_f$, in
the $decl^*$ section.
For an input array  (or pointer) \lstinline'x', the values are stored in the dynamically
allocated array \lstinline'old_val_x' whose size is inferred from the
We also generate an additional function named \lstinline'f_precond'
that is used to check the precondition of the FUT. For the  FUT  we ensure
that the precondition is assumed by inserting 
\lstinline|fassume(f_precond(x1, ..., xn));| 
at label $Beg_{f}$
(cf line 11 in Listing~\ref{lst:abbrv}).

Second, any \textsc{ACSL} annotation of the form \lstinline|kwd w| (where
keyword \lstinline|kwd| belongs to \{\lstinline|assert|, \lstinline|requires|,
\lstinline|typically|, \lstinline|ensures|, \lstinline|loop variant|,
\lstinline|loop invariant|\} and $w$ is a predicate or a term) is translated.
Some other \textsc{ACSL} constructs are not detailed here because they can be
obtained from the described \textsc{ACSL} fragment. For example, behaviors can
be rewritten as implications in \lstinline|ensures| annotations,
statement contracts can be rewritten as implicative \lstinline|assert|'s and
global (resp., loop or statement)
\lstinline|assigns| clauses can be rewritten as postconditions
(resp., loop invariants or assertions)
checking the non-modification of some variables. 

Each pair
$(label, annotation)$ is translated into a sequence of \emph{code insertions} 
$(l_1, c_1) \concat (l_2, c_2) \concat \ldots \concat (l_n, c_n)$, that 
represents a list of fragments of C programs $c_1, c_2, \ldots, c_n$ where
the fragment $c_i$ will be inserted into the instrumented program at label
$l_i$. Program fragments $c_i$ are parts of a correct program that might be
incomplete if taken separately
since a syntactically complete statement can be split into several insertions.
%for example \lstinline|while(1) {| and
%\lstinline|}| are two fragments of a larger C program containing a loop.
When there are several fragments to insert in the same location $l$, they
are inserted according  to their order in the list. \textsc{ACSL} annotations
are translated separately, and the  resulting sequences of insertions are treated 
respecting the order of annotations in the source program.

Translation of annotations is defined by the rules in Sec.~\ref{sec:annot}. It
requires translating \textsc{ACSL} terms and predicates. These
transformations are described by the rules in Sec.~\ref{sec:term} and
Sec.~\ref{sec:pred}. In these rules we use the following notation:
\begin{itemize}
\item $p$, $p_1$, $p_2$ and $p_3$ are \textsc{E-ACSL} predicates;
\item $t$, $t_1$, $t_2$ and $t_3$ are \textsc{E-ACSL} terms and $w$ is either a
  predicate or a term;
\item $c$, $c_1$, $c_2$ and $c_3$ are fragments of C programs;
%% TODO: renommer c_i en s_i ?
\item $e$, $e_1$, $e_2$ and $e_3$ are C expressions;
\item $l$, $l_1$, $l_2$, $l_3$, $Beg_f$, $End_f$, $BegIter_l$ and $EndIter_l$ are
  program labels;
\item $i$ is an identifier of a bounded variable in an \textsc{ACSL} predicate
  and an iterating counter in a C program, $x$ is an identifier of a C variable;
\item $I$, $I_1$, $I_2$ and $I_3$ are lists of code insertions $(l_i, c_i)$.
\end{itemize}



We denote by \lstinline'res', \lstinline'var_n', \lstinline'i_n',
\lstinline|old_x|, \lstinline'old_val_x' and \lstinline|old_variant|, fresh
variables, that is, identifiers different from all other identifiers of the
instrumented program.
When we use several times a rule introducing a fresh variable, all occurrences
must be different. It can be easily implemented incrementing the number
\lstinline'n' in \lstinline|var_n| or \lstinline'i_n' and replacing
\lstinline|x| in \lstinline|old_x| or \lstinline'old_val_x' by the
names of parameters of $f$ or global variables.

For convenience, we assume that all bounded variables in annotations and all program variables are different
from one another.
In particular, we can translate bounded variables into C without renaming.


\subsubsection{Exemple}
\label{sec:running-example}
%\vspace{-2mm}

\lstinputlisting[style=c,escapechar=§,caption={Annotated C function deciding if
    \lstinline{v} is present in array \lstinline{t} of size \lstinline{n}},
  label=lst:normalized]{listings/is_present_normalized.c}

We present in Listing~\ref{lst:normalized} an example of FUT  
normalized according to the grammar of Fig.~\ref{fig:grammar}. It returns $1$
when a given value is present in a given array, or $0$ otherwise. The
instrumented program obtained after translation of annotations of this function
is presented  (using abbreviated notation) in Listing~\ref{lst:abbrv}. The generated  precondition function is
defined at lines 1--6 (Listing~\ref{lst:abbrv}), it returns a nonzero value when the
precondition holds. The \lstinline|requires| clause in line 1
(Listing~\ref{lst:normalized}) stating that the array size \lstinline|n| is
positive  is
translated as the condition in line 3 (Listing~\ref{lst:abbrv}).
The \lstinline|requires| clause in line 2 (Listing~\ref{lst:normalized}) states
that \lstinline|(t+0)|$, ..., $\lstinline|(t+(n-1))| are valid pointers, and leads
to the condition in line 4 (Listing~\ref{lst:abbrv}). The
\lstinline|typically| clause 
in line 3 of Listing~\ref{lst:normalized} (translated
as line 5  of Listing~\ref{lst:abbrv}), 
is an extension of 
\acsl defining a precondition
considered only for testing. It strengthens the precondition to restrict
the (potentially too big) number of paths to be explored by test generation to
user-controlled partial coverage. Here it bounds the state space of
\lstinline|n| (and thus the size of \lstinline|t|) to $[0, 6]$ (it can be seen
as a domain {\em finitization} \cite{Korat}).
The loop invariant in line 9 of Listing~\ref{lst:normalized} 
%is bounding \lstinline|i|
%to values between $[0, \lstinline|n|]$. It 
is translated as lines 13--14 of
Listing~\ref{lst:abbrv} to check that the invariant holds before the first loop
iteration, and lines 21--22 of Listing~\ref{lst:abbrv} to check the preservation of
the invariant by any iteration. (An additional loop invariant 
\lstinline|\forall integer k; 0<=k<i ==> \old(*(t+k))!=v;|
necessary to formally prove the postcondition using deductive verification
was not included in this simplified example).
The loop variant line 10 in Listing~\ref{lst:normalized} is translated as
line 15 of Listing~\ref{lst:abbrv} to check that the variant is positive or
zero before the loop, line 18 of Listing~\ref{lst:abbrv} to back up the
value of the variant at the beginning of the loop, and lines 23--25 of
Listing~\ref{lst:abbrv} to check that it strictly decreases but remains positive
or zero, thus ensuring the termination of the loop.
The postcondition at lines 4-5 of Listing~\ref{lst:normalized} is translated as
lines 28--32 of Listing~\ref{lst:abbrv}, it states that \lstinline|\result| is
non zero if and only if there exists an element of \lstinline|t| equal
to \lstinline|v|.
The values of formal parameters \lstinline|t|, \lstinline|n| and
\lstinline|v|
are saved in lines 10--11
(Listing~\ref{lst:abbrv}), a new array \lstinline|old_val_t| saves the old values
contained in \lstinline|t|, it is allocated line 10, filled line 11 and
deallocated line 33.



\section{Traduction des termes \acsl}
\label{sec:term}

\input{figures/fig_rules}

Let us denote
$(l, t:T) \rulearrow ((l_1, c_1) \concat (l_2, c_2) \concat \ldots \concat (l_n, c_n), e)$
an instance of the partial function $\tau$ mapping an E-ACSL term $t$ of type
$T$ at label $l$ to the pair $(I, e)$ where $I$ is a list of code insertions
$(l_i, c_i)$, $e$ is a C expression, and $T$ can be $\mathbb{Z}$ (integer) or
$ctype$. We only consider
the following types as included in $ctype$: $ptr$,
that can be a pointer of any type, and \lstinline'int' that is the regular C
type. Other integral C types such as \lstinline'char', \lstinline'long',
\lstinline'unsigned' could be supported in the same way, but are not considered
for simplicity and readability purposes.
The expression $e$ is pure (i.e. has no side
effects) and evaluates the value of the term at the given point.
%(that is usually computed by the inserted program fragments $c_i$).  
The evaluation of $e$ often requires additional
computations, that are performed by the inserted program fragments
resulting from the predicate and term translation. For example, a quantified
term requires the computation of a value throughout a \lstinline|for| loop
(see Fig.~\ref{fig:builtin}). In this case, the second element of the returned
pair, $e$, is the value of a variable computed by the loop.
When a term $t$ can be directly translated without additional C code, 
the sequence of code insertions is empty and denoted $\emptyset$.
For a term $t:\mathbb{Z}$,
the translation result $e$ is always a variable of type \lstinline'Z_t'
(that justifies de-allocation \lstinline{e}${}^{\boxtimes}$ e.g. in Fig.~\ref{fig:coerce}).

Fig.~\ref{fig:const-id} describes the rules for identifiers
(\textsc{$\tau$-var}), for the \lstinline|\result| term
(\textsc{$\tau$-res}) and constants (\textsc{$\tau$-const}).
Two rules are considered for the ACSL construct \lstinline|\old|.
Applied to an identifier $x$, it is translated as the fresh variable
\lstinline|old_x| storing the value at the entry of the function.
Applied to a memory access (rule \textsc{$\tau$-old-val}), we use the dynamically
allocated array \lstinline|old_val_x| that memorizes the elements of an array
\lstinline|x| at the entry of the function (cf Sec.~\ref{sec:principles}).
The special term \lstinline|\result| translated by the rule
\textsc{$\tau$-res} denotes the return value of the function in
\textsc{ACSL} written into the fresh variable   \lstinline|res|.
That variable is unique after the normalization of the abstract syntax tree (AST) by
\textsc{Frama-C}. 
The rule \textsc{$\tau$-const} states that an integer variable is defined to
store the integer constant.

Fig.~\ref{fig:coerce} details the rules for coercions, from integer to C type
and from C type to integer.

Fig.~\ref{fig:op} details the rules for unary operations
(\textsc{$\tau$-unop$_*$}),
binary operations (\textsc{$\tau$-binop$_*$}) and the ternary condition on terms
(\textsc{$\tau$-if}).
\textsc{$\tau$-unop$_1$} deals with pointer indirection ($\star$).
In \textsc{$\tau$-unop$_2$}, the logical not (\lstinline|!|) does not involve
integers.
In \textsc{$\tau$-unop$_3$}, $op$ is the unary minus (\lstinline|-|) or the
bitwise complement ($\sim$) and is an operation from and to integer.
In \textsc{$\tau$-binop$_1$}, the left operand is a pointer so $op$ must be
\lstinline|+| or \lstinline|-|, whereas the right operand is an $int$
(if it is an integer, it will be coerced to $int$ using the rule
\textsc{$\tau$-coerce$_1$} for pointer arithmetics).
In \textsc{$\tau$-binop$_2$}, $op$ is a comparison operator over integer values
and the result of the comparison is stored in an \lstinline|int|.
In \textsc{$\tau$-binop$_3$}, $op$ is any of the arithmetic
operators: \lstinline|+|, \lstinline|-|, \lstinline|/|, \lstinline|%|,
\lstinline|<<|, \lstinline|>>|, \lstinline{|}, \lstinline|&|, \lstinline|^|
over integers.
In the rule \textsc{$\tau$-if}, the evaluation of $t_2$ and $t_3$ are in
conditional branches: only one of them is computed, depending on the evaluation
of $t_1$.






Fig.~\ref{fig:builtin} presents the rules for translating the builtin
logic functions \lstinline|\sum| (\textsc{$\tau$-sum}) and \lstinline|\numof|
(\textsc{$\tau$-numof}). % and \lstinline|\min| (\textsc{$\tau$-min}).
The rule for function %\lstinline|\max| and
\lstinline|\product| is similar 
to the rule % \textsc{$\tau$-min} and
\textsc{$\tau$-sum}.
%respectively.
The rule \textsc{$\tau$-sum} over integers initializes a fresh integer variable
\lstinline|var_n|, initialized to $0$, and increments its value with the value
of the \lstinline|\lambda|-term \lstinline't3' at each iteration.
The rule \textsc{$\tau$-numof} also initializes a fresh integer variable
\lstinline|var_n| to $0$, but increments it only when the (non-integer)
\lstinline|\lambda|-term \lstinline't3' is evaluated to a non-null expression.



\section{Traduction des prédicats \acsl}
\label{sec:pred}

Similarly to the translation function $\tau$ for terms (see
Sec.~\ref{sec:term}), the translation function for predicates, denoted $\pi$,
is defined as a partial function mapping a label and an \textsc{ACSL} predicate
to a sequence of code insertions
$(l_i, c_i)$ and a C expression $e \in \{0, 1\}$.
When a predicate $p$ can be directly translated without additional C code, 
the sequence of code insertions is empty and denoted $\emptyset$.


We define in Fig.~\ref{fig:pred-logic},
Fig.~\ref{fig:valid} and Fig.~\ref{fig:quantif} the transformation rules for the
main \textsc{ACSL} predicates we handle.

Fig.~\ref{fig:pred-logic} details the translation rules for the simplest
predicates of the \textsc{ACSL} language. The rules \textsc{$\pi$-true} and
\textsc{$\pi$-false} state that $true$ (resp. $false$) are translated into $1$
(resp. $0$). The rules \textsc{$\pi$-equiv} and
\textsc{$\pi$-not} are
compositional: the subpredicates are translated recursively, then the result of
the translation of the predicate is rebuilt from the values of the subpredicates.
The rules \textsc{$\pi$-and},
\textsc{$\pi$-or} and \textsc{$\pi$-impl} are reflective of the laziness of
the \textsc{ACSL} semantics of those operators: the first operand is always
evaluated (in $I_1$) but the second one is only evaluated (in $I_2$) when necessary. The rule
The rule \textsc{$\pi$-if} is the counterpart of \textsc{$\tau$-if} (cf
Sec.~\ref{sec:term}) for predicates.
In our running example of Listing~\ref{lst:normalized}, translating 
the postcondition
\lstinline{\result != 0 <==> \exists integer i; 0<=i<n && *(t+i)==v} requires
the translation of the predicates \lstinline|\result != 0| and
\lstinline{\exists(...)} that are respectively translated as \lstinline|var_32|
and \lstinline|var_35|. These two predicates are put together to build the
translation of
the composed predicate, that is, according to \textsc{$\pi$-equiv},
\lstinline{(!var_32 || var_35) && (!var_35 || var_32)} (line 32 of
Listing~\ref{lst:abbrv}).
In the rule \textsc{$\pi$-rel}, \lstinline|op| is any of these
operators: \lstinline[style=c]{<, <=, >, >=, ==, !=}.

Fig.~\ref{fig:valid} shows the translation rules for the \lstinline|\valid|
predicate that holds if its parameter points to a valid memory location and can
be dereferenced. 
Basic usages are
\lstinline{\valid(t)} 
%and \lstinline|\valid(t1+t2)| 
%(that is a generalization of
%the previous with $t_2$ equal to $0$) 
for checking  the validity of a single 
pointer \lstinline{t},
%or of pointer \lstinline{t1} with offset \lstinline{t2}, 
and \lstinline|\valid(t1+(t2..t3))| for checking the validity of 
pointer \lstinline{t1} within offset range \lstinline|t_2..t_3|. The rules \textsc{$\pi$-valid} and
\textsc{$\pi$-valid-range} cover both usages. We assume that we can
evaluate the validity of the memory location a pointer points to by the means of
a function \lstinline|fvalid|, and the validity of a pointer 
within an offset range by \lstinline|fvalidr|.
In our running example of Listing~\ref{lst:normalized}, the predicate
\lstinline|\valid(t+(0..n-1))| in the \lstinline|requires| clause of line 2 is
translated to \lstinline[style=c]|fvalidr(t,0,(n-1))| (line 4 of
Listing~\ref{lst:abbrv}).
Full support of these predicates requires a precise low-level
memory representation.

The rules \textsc{$\pi$-exists}
(Fig.~\ref{fig:quantif}) translates the existentially
quantified predicate \lstinline|\exists| other integer values.
It updates
a variable \lstinline|var_n| (initially set to $false$) at each iteration of the
loop until all values of \lstinline|i| are considered or  
until \lstinline|var_n| is evaluated to $true$.
This rule also treats the universally quantified predicate
(l, \lstinline{\forall integer i; t1<=i<t2 ==> p}) since it
is equivalent to 
(l, \lstinline{! (\exists integer i; t1<=i<t2 && !p)}).
In Listing~\ref{lst:normalized}, the quantified predicate
\lstinline{\exists integer i; 0<=i<n && *(t+i)==v} of 
line 4 is translated in lines 29--31 of Listing~\ref{lst:abbrv}
and the fresh variable containing the value of the predicate after its
evaluation is \lstinline|var_35| (declared at line 29).


\section{Traduction des annotations \acsl}
\label{sec:annot}

Now we  define the translation rules for annotations that allow to trigger 
annotation failures and 
enforce 
test generation of erroneous inputs. For each annotation, a fragment of a C
program ending by a condition test is inserted into the program. The test
generator will try to cover all feasible paths, thus activating the error if
such inputs exist. The rules are of the following form:

\vspace{-4mm}
\[
\dfrac
    {(l_1, w) \rulearrow (I_1, e_1) \quad \ldots \quad
      (l_n, w) \rulearrow (I_n, e_n)}
    {(l, \mathtt{kwd\ w;}) \rulearrow
      g_{kwd} (l, (I_1, e_1), \ldots, (I_n, e_n))}
\]
\vspace{-4mm}



This rule pattern states that if the term or predicate $w$ at label $l_i$
is translated (by $\tau$ or $\pi$) as
$(I_i, e_i)$, then the property $kwd\ w$ involving $w$ at
program point $l$ will be translated by some composition 
function of code insertions of each
$I_i$ and of the expressions $e_i$. 
The particular composition function, denoted $g_{kwd}$, depends on
the annotation kind.
In Fig.~\ref{fig:annot} and Fig.~\ref{fig:loop-annot} we present the
translation rules for each annotation kind. Suppose \lstinline|fassert| is a C
function checking an expression. We define the condition $e$ that
must be tested for each annotation. The test is expressed by applying the
function \lstinline|fassert|, that is expanded to a conditional \lstinline|if|.
Test generation tries to cover both branches. If the expected property is
false, the failure is reported and the
exploration switches to another branch.

Fig.~\ref{fig:annot} describes the translation rules for an assertion at label $l$
(\textsc{$\alpha$-assert}), a postcondition (\textsc{$\alpha$-post}) and
a precondition (\textsc{$\alpha$-pre})
that are considered to be stated resp. at labels $End_f$ and $Beg_f$. 
The rule \textsc{$\alpha$-assert}
simply checks the translated predicate at label $l$ with the function
\lstinline|fassert|. The rule \textsc{$\alpha$-post} checks the predicate at
the end of the function being translated. The rule \textsc{$\alpha$-pre} checks
the predicate of a precondition in a separate function that we call
\lstinline'f_precond', returning $0$ if one of the \lstinline|requires| or
\lstinline|typically| clauses does not hold, or $1$ otherwise. This function
has to be called with the same formal parameters as the function
being translated.
Since the precondition is \emph{assumed} for the function under test
and must be \emph{ensured} for a called function,
its result has to be {\em asserted} in the case
of a {\em callee}  and {\em assumed} in the case of the function under
test.
So for each function, a check 
\lstinline|fassert(h_precond(x1, x2, ..., xn));| (resp.
\lstinline|fassume(h_precond(x1, x2, ..., xn));|) is inserted at the label
$Beg_h$ if $h$ is a {\em callee} (resp. FUT), where
$x_1, x_2, ..., x_n$ are the formal parameters of $h$, and
the \lstinline|fassume| function restricts 
test generation to input values for which it returns true.
In the example of Listing~\ref{lst:normalized}, the
\lstinline|requires| clause lines 1-2 and the \lstinline|typically| clause line
3 are translated to the lines 3--5 of Listing~\ref{lst:abbrv}. The validity of the
\lstinline'is_present_precond' precondition is {\em assumed} line 11 of
Listing~\ref{lst:abbrv}. Finally, the \lstinline|ensures| clause lines 4-5 is
translated as lines 28--32 in Listing~\ref{lst:abbrv}. 

The translation rules for the loop invariants (\textsc{$\alpha$-invariant}) and
loop variants (\textsc{$\alpha$-variant}) for a loop at label $l$ are presented in
Fig.~\ref{fig:loop-annot}. The rule \textsc{$\alpha$-invariant} checks the
predicate of the loop invariant before the loop, and after
each iteration of the loop (i.e. at the predefined label $EndIter_l$). The rule
\textsc{$\alpha$-variant} checks that the variant term is non-negative at the
beginning of each iteration,
then the previous value of the variant is saved at the begining of the loop
iteration in a fresh variable 
\lstinline|oldvariant|. Finally, it checks at the end of each iteration that
the current value of the variant is strictly
decreasing (compared to its value in the previous iteration).
In the running example of Listing~\ref{lst:normalized}, translating the
\lstinline|loop invariant| line 9 results in lines 13--14 and 21--22 in
Listing~\ref{lst:abbrv}, while translating the \lstinline|loop variant| line 10
results in lines 15, 18 and 23--25 in Listing~\ref{lst:abbrv}.


\section{Différences entre le Test et la Validation d'Assertions à l'Exécution}


Instrumentation based translation of ACSL annotations into C code 
has been implemented in two \framac \cite{\citeframac} plugins:
\eacsltoc \cite{Delahaye/SAC13,Kosmatov/RV13} that generates an instrumented program
for Runtime Assertion Checking (RAC), and \stady, that instruments a program for Test Generation with
\pathcrawler \cite{\citepathcrawler}. 
This section  discusses similarities and differences between both kinds of instrumentation.

Test generation and runtime checking both need to
generate executable code and so consider only an executable subset of the
specification language. 
Therefore, most rules defined in Sec. \ref{sec:term}, \ref{sec:pred} and \ref{sec:annot} 
for test generation are also valid for RAC.

\textbf{Precondition of the function under test (FUT).}
One difference is the treatment of the precondition of the FUT.
In RAC, it is usually checked as any other annotation.
In test generation, it is used to avoid testing the program on inadmissible values 
for which the program is not supposed to work correctly.
Hence, the precondition  of the FUT should be assumed during test generation
to ensure that all generated test inputs respect the precondition of the FUT.

Besides, the treatment of the precondition of the FUT in \pathcrawler has two optimizations.
First, an internal mechanism of unquantified and quantified preconditions
allows a direct translation of ACSL preconditions into constraints
supported in an efficient manner.
Hence, for precondition patterns that can be expressed by this mechanism,
a translation into C code is not necessary for \pathcrawler.
Second, for the remaining preconditions translated into a C function, 
\pathcrawler offers a specific
efficient mechanism \cite{Delahaye/RV13}.
A call to \lstinline|fassume| (adding the constraints of the
precondition to the constraint store \emph{before} the path predicate in the FUT)
can be replaced in \pathcrawler by a dedicated support for
late precondition (where precondition constraints are posted \emph{after}
other path constraints of the FUT).
Thus the call to \lstinline|fassume| for the FUT 
in \pathcrawler is not needed.

\textbf{Memory-related constructs.}
Runtime checkers also require a complex instrumentation framework
to treat memory-related constructs where each memory related operation
is instrumented and relative memory block metadata is stored
so that it can be extracted when it is necessary to evaluate a memory-related
ACSL annotation \cite{Kosmatov/RV13}.
Some of these constructs can be handled symbolically in
concolic testing without additional instrumentation.
The functions \lstinline|fvalid| and \lstinline|fvalidr| are builtin C functions
defined by \pathcrawler that return the value of validity of a pointer
\cite{testing-pointers}.
They actually support global variables and formal parameters of the function
under test.

\textbf{Unbounded integers.}
While translation of ACSL mathematical integers relying on an external library 
for unbounded integers (like GMP) is appropriate and sufficient for
RAC, it will be quite inefficient if the library function code is
directly handled by test generation.
Indeed, test generation on the instrumented code would have to 
treat much more complex code, with lots of additional function 
calls, dynamic memory allocation and de-allocation, etc.
This can be avoided again using symbolic execution of the test generation
tool. \pathcrawler offers dedicated builtin support 
for GMP numbers and operations that are efficiently translated into
appropriate constraints on unbounded integers and handled 
by the underlying constraint solver.

\textbf{Runtime errors.}
Straightforward translation of annotations into C may introduce runtime errors due to annotations
with undefined terms (such as 1/0, cf Sec. \ref{sec:undefined}). 
This issue can be easily solved for test generation exactly as proposed in \cite{Delahaye/SAC13} for RAC,
by an additional guard generation phase
by running  the \rte plugin~\cite{\citeframac} on the instrumented code
to add annotations preventing
runtime errors, and finally running the instrumentation again on these new annotations.
Runtime  errors related to unbounded integer (division of a GMP integer by 0, 
overflow during a type coersion \lstinline[mathescape=true]{(int)(t:$\mathbb{Z}$)}, etc.) 
are not treated by \rte, but they can be easily prevented 
by adding suitable checks in the corresponding rules.
For example, the downcast of a term $t$ from integer to $int$ (see the rule
\textsc{$\tau$-coerce$_1$} of Fig.~\ref{fig:coerce}) can be guarded by inserting
\lstinline{fassert(}\underline{\lstinline{INT\_MIN <= e}}\lstinline{&&}\underline{\lstinline{e <= INT\_MAX}}\lstinline{)}
before the assignment \underline{\lstinline'var_n = e'}.


\textbf{Triggering errors during test generation.}
The function \lstinline|fassert(cond)| is a C macro defined by
\textsc{PathCrawler} that is expanded as a conditional
\lstinline|if(cond)|, testing
if its parameter is true. Covering all feasible paths of the
program will therefore enforce the generation of test inputs activating the
$then$ branch of this condition, and test inputs activating the
$else$ branch. So if there exist inputs such that \lstinline'cond' is evaluated to
$false$, a test case activating the \lstinline|fassert| thus
violating the corresponding annotation is generated. In other terms, a
counter-example for that annotation is generated if such inputs exist.
