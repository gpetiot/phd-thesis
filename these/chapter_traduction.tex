
\chapter{Traduction en C des Annotations pour le Test}
\label{sec:traduction}

\chapterintro


Ce chapitre présente la transformation d'un programme C annoté avec \eacsl en un
programme C appelé programme instrumenté.
Les annotations \eacsl ont été traduites en fragments de programme C ajoutés au
programme initial.
Ces fragments mettent en \oe{}uvre les annotations \eacsl afin de générer des
tests satisfaisant et violant ces annotations.

Ce chapitre présente les règles de traduction des annotations \eacsl en code C
sémantiquement équivalent afin d'utiliser un générateur de tests qui prend en
entrée des programmes C.
L'instrumentation permet de l'utiliser pour traiter des programmes C annotés
sans que cet outil n'ait à traiter les annotations dans leur format d'origine,
il les traite via leur instrumentation en C.

Dans un premier temps nous présentons le langage des programmes annotés pris en
compte.
Puis nous présentons les principes généraux de la traduction.
Ensuite nous détaillons les règles de traduction des éléments les plus simples
que sont les termes, aux éléments les plus complexes que sont les annotations,
en passant par les prédicats.
Enfin, nous discutons les différences et les similitudes entre l'instrumentation
pour la génération de tests et l'instrumentation pour la validation à
l'exécution.


\section{Processus de transformation de programmes}


\input{figures/fig_grammar}

Cette section présente le processus d'instrumentation des fonctions C annotées
avec le langage d'annotations \eacsl pour la génération de tests.
Pour des raisons de commodité, nous considérons qu'un label précède chaque
instruction et annotation à l'intérieur d'une fonction.
Considérons aussi la présence d'un label au début et à la fin de chaque corps de
boucle.
(Strictement parlant, les labels ne peuvent pas être placés juste avant les
déclarations de variables ou l'accolade fermante ``$\bclose$'' en C, mais
cette limitation peut être contournée par l'ajout d'une instruction ``skip''
(``\lstinline{;}'') après ces labels.)
Nous supposons que les fonctions respectent la forme normale définie par
l'entité syntaxique \textit{function} de la grammaire définie
figure~\ref{fig:grammar}. 
Dans cette figure, la notation ``${\textit{as}\;X}$'' en exposant signifie que
chaque occurrence de $X$ dans la règle courante doit être remplacée par la
chaîne à laquelle on fait référence en exposant.
Par exemple, si \texttt{foo} est le nom ($id$) de la fonction sous test dans la
règle $function$, les labels $\texttt{Beg}_f$ et $\texttt{End}_f$ dans le corps
de cette fonction sont remplacés par $\texttt{Beg}_{\texttt{foo}}$ et
$\texttt{End}_{\texttt{foo}}$, ce qui assure des labels uniques au début et à la
fin du corps de la fonction.
Nous supposons qu'il existe une unique instruction \lstinline'return' à la fin
de chaque fonction, que la variable retournée s'appelle \lstinline'res' et que
cette variable n'entre pas en conflit avec une autre variable du programme.
Les accès aux pointeurs et aux tableaux sont notés \lstinline|*(p+i)|.
Les symboles terminaux sont présentés en police \texttt{typewriter}.
Les symboles non-terminaux \underline{soulignés} ne sont pas détaillés car ils
font partie des langages C ou \eacsl.
\textit{\underline{not-while-stmt}} est toute instruction du C qui n'est pas
une boucle.
\textit{\underline{term}} et \textit{\underline{predicate}} sont des expressions
\eacsl qui sont décrites en section~\ref{sec:term} et section~\ref{sec:pred}.


\subsection{Sous-langage considéré}

Le langage de spécification \eacsl est un sous-langage exécutable d'\acsl, qui
est un langage de spécification comportementale implémenté dans \framac.
Premièrement, étant un sous-ensemble d'\acsl, \eacsl préserve la sémantique
d'\acsl, ce qui implique que les greffons de \framac existants supportant \acsl
peuvent être utilisés avec \eacsl sans modification.
Deuxièmement, le langage \eacsl est \textit{exécutable}, ce qui veut dire que
toutes les annotations peuvent être traduites en C et exécutées, il peut donc
être utilisé pour l'analyse dynamique et le \textit{monitoring} (surveillance
d'exécution).

\eacsl est basé sur une logique du premier ordre typée dans laquelle chaque
terme peut contenir des expressions C pures (sans effets de bord) et des
mots-clés du langage.
Par exemple, le mot-clé \lstinline{\result} permet de faire référence au
résultat d'une fonction, \lstinline{\valid} est un prédicat qui renvoie vrai si
son argument est un pointeur valide (se référer au manuel du
langage~\cite{\citeacsl}).
Les quantificateurs existentiels et universels sont bornées par des contraintes
de domaines finis d'entiers afin de rester exécutable.
Un contrat de fonction à la \eiffel~\cite{\citeeiffel} peut être associé à
chaque fonction pour spécifier les pré- et postconditions.
Ces contrats peuvent définir des comportements (\lstinline{behaviors}) gardés et
nommés, pour lesquels l'exhaustivité (\textit{completeness}) et/ou la séparation
(\textit{disjointness}) peut être requise.
Les assertions, les invariants de boucle et les variants peuvent aussi être
associés aux instructions.
Abordons maintenant deux des choix les plus importants du langage: les entiers
mathématiques et la non-définition (nous utiliserons le terme anglais
\textit{undefinedness}).


\subsubsection{Entiers mathématiques}\label{sec:eacsl-integers}


En plus des entiers machine, les termes \eacsl peuvent être des entiers
mathématiques de type \lstinline{integer} qui sont définis sur l'ensemble
$\mathbb{Z}$ : les constantes entières, les
opérations sur les entiers, ainsi que les variables logiques sont de type
\lstinline{integer}.
L'arithmétique entière est non bornée et donc les débordements d'entier
(\textit{overflows}) sont impossibles.
\eacsl dispose d'un système de sous-typage pour convertir automatiquement les
types entiers du C vers les entiers mathématiques.
Par exemple, si \lstinline{x} est une variable C de type \lstinline{int},
\lstinline{x+1} et \lstinline{1} sont de type \lstinline{integer} et une
conversion implicite d'\lstinline{int} vers \lstinline{integer} est introduite
dans ce contexte quand la variable \lstinline{x} est typée.
Ce choix a été fait pour plusieurs raisons.
Premièrement, un des buts principaux de \framac est la preuve de programmes par
appels à des prouveurs externes, la plupart de ces prouveurs fonctionnent mieux
avec l'arithmétique entière qu'avec l'arithmétique bornée (ou modulaire).
Deuxièmement, les spécifications sont habituellement écrites sans se préoccuper
des détails d'implémentation, et les débordements d'entiers sont des détails
d'implémentation.
Troisièmement, il reste possible d'utiliser l'arithmétique bornée si besoin en
utilisant des conversions explicites (\textit{casts}).
Par exemple, \lstinline{(int)(INT_MAX + 1)} est égal à \lstinline{INT_MIN}, la
plus petite valeur représentable de type \lstinline{int}.
Quatrièmement, ce choix facilite l'expression des débordements potentiels dans
les spécifications : par exemple, grâce à l'arithmétique entière,
\lstinline{/*@ assert INT_MIN <= x+y <= INT_MAX;*/} est le moyen le plus simple
de spécifier que \lstinline{x+y} ne déborde pas.
Dans la suite, sauf mention contraire, ``entier'' fait référence à
``entier non-borné''.


\subsubsection{Undefinedness}\label{sec:undefined}


\eacsl est exécutable.
Cependant, l'évaluation de termes indéfinis comme \lstinline{1/0} n'est pas
possible.
Pour résoudre ce problème, \eacsl suit la sémantique de vérification à
l'exécution définie par Chalin~\cite{Chalin/10}, selon laquelle la sémantique de
tels termes est ``indéfinie'' (\textit{undefined}) : \eacsl utilise une logique
tri-valuée~\cite{Konikowska/91} comme \spark~\cite{\citespark} ou
\jml \cite{\citejml}.
Il est de la responsibilité des outils interprétant \eacsl de s'assurer que les
termes indéfinis ne sont jamais évalués.
Une conséquence indirecte de ce choix est que les opérateurs \lstinline{&&}\,,
\ \lstinline{||}\,, \ \lstinline{_?_:_} \ et\ \lstinline{==>} sont
``paresseux'' (comme leur équivalent C pour les trois premiers).


\subsection{Support des entiers mathématiques}\label{sec:integers}


\lstinputlisting[style=c,escapechar=§,caption={Propriétés des entiers : faux
    négatif dû à une traduction naïve},label=lst:Z:1]
                {listings/naive_false_negative.c}

\lstinputlisting[style=c,caption={Propriétés des entiers : faux positif dû à
    une traduction naïve},label=lst:Z:2]
                {listings/naive_false_positive.c}


Le listing~\ref{lst:Z:1} et le listing~\ref{lst:Z:2} montrent deux exemples où
une traduction naïve des annotations contenant des entiers mathématiques mènent
à un résultat incorrect.
Soit \lstinline'x' de type \lstinline'int'.
L'assertion ligne 1 du listing~\ref{lst:Z:1} est fausse lorsque
\lstinline'x = INT_MAX'.
La traduction naïve de cette assertion (ligne 3) utilise les entiers machine
avec arithmétique modulaire (supposons une architecture 32 bits), donc
\lstinline'x+1' reste inférieur ou égal à \lstinline'INT_MAX' pour toute valeur
de \lstinline'x', rendant tout échec de l'assertion impossible.
La traduction correcte pour cette annotation (lignes 6--9) conserve la
sémantique de l'arithmétique entière non bornée en utilisant une bibliothèque
externe (nous avons choisi GMP, la bibliothèque GNU Multi-Precision) pour
représenter les valeurs pouvant provoquer un débordement d'entier (ici
\lstinline'INT_MAX+1').
Les variables nécessaires pour la gestion des entiers non bornés sont crées et
initialisées, puis le résultat est calculé et les comparaisons sont faites en
tant qu'entier non borné.
Le second exemple (listing~\ref{lst:Z:2}) définit une assertion \eacsl (ligne 2)
qui est toujours correcte : pour tout entier positif \lstinline'x', son
successeur est aussi positif.
Une traduction naïve de cette annotation (ligne 3) génèrera une erreur à
l'exécution pour \lstinline'x = INT_MAX' : en arithmétique modulaire
\lstinline'x+1' déborde et devient négatif, violant l'assertion ligne 2.
Une traduction correcte utilisant les entiers non bornés (non présentée ici)
conserve le comportement attendu : l'assertion est vraie pour tout entier
positif \lstinline'x'.
Une traduction naïve des annotations dans ces deux exemples résulterait en un
faux négatif dans le premier cas et en un faux positif dans le deuxième cas, ce
qui porterait atteinte à la correction et à la précision de notre méthode.
Les règles de traduction pour les constructions \eacsl que nous présentons
respectent la sémantique des entiers non bornés d'\eacsl et suppose
l'utilisation d'une bibilothèque externe telle GMP, comme illustré dans le
listing~\ref{lst:Z:1}.

Pour simplifier la lecture des insertions de code générées par la traduction,
nous utilisons la notation abrégée ${}^{\square}$\lstinline{var} pour indiquer
que la variable \lstinline{var} doit être déclarée et allouée (avec
\lstinline{Z_t var; Z_init(var);}) au début de la portion de code insérée, et la
notation \lstinline{var}${}^{\boxtimes}$ pour indiquer que la variable
\lstinline{var} doit être désallouée (avec \lstinline{Z_clear(var);})
à la fin du code inséré.
Nous soulignons les fragments de code afin d'indiquer que l'opération effectuée
(affectation, comparaison, \dots) utilise l'arithmétique non bornée et doit
être traduite en utilisant les fonctions correspondantes d'une bibliothèque
comme GMP.
Les lignes 12--13 du listing~\ref{lst:Z:1} illustrent la notation abrégée de 
l'instrumentation des lignes 6--9.
\framac explicite les conversions de type implicites dans les annotations, donc
le terme \lstinline'x+1' ligne 1 du listing~\ref{lst:Z:1} devient
\lstinline'(integer)(x+1)'.


\subsection{Principes généraux}
\label{sec:principles}


\lstinputlisting[style=c,escapechar=§,caption={Version instrumentée du programme
    du listing~\ref{lst:normalized}},label=lst:abbrv]
                {listings/is_present_instrumented.c}


Présentons maintenant les principes de la traduction d'une fonction $f$ annotée
respectant la grammaire de la figure~\ref{fig:grammar}.
Premièrement, chaque valeur d'entrée \lstinline'x' (un paramètre formel de la
liste $params$ ou une variable globale) de type $T$ est mémorisée par
l'instruction \lstinline|T old_x = x;| au début de la fonction sous test
instrumentée, c'est-à-dire au label $Beg_f$, dans la section $decl^{*}$.
Pour chaque tableau ou pointeur \lstinline'x', les valeurs pointées sont
mémorisées dans un tableau alloué dynamiquement \lstinline'old_val_x' dont la
taille est inférée à partir du prédicat \lstinline'\valid' dont on suppose la
présence en précondition de la fonction sous test.

Deuxièmement, toute annotation \eacsl de la forme \lstinline'kwd w' (où
\lstinline'kwd' $\in$ $\bopen$ \lstinline|assert|, \lstinline|requires|,
\lstinline|typically|, \lstinline|ensures|, \lstinline|loop variant|,
\lstinline|loop invariant|, \lstinline|assigns|, \lstinline|loop assigns|
$\bclose$ et \lstinline'w' est un terme ou un prédicat) est traduite.
D'autres constructions \eacsl ne sont pas détaillées ici car elles peuvent être
obtenues à partir du fragment \eacsl considéré.
Par exemple, les behaviors peuvent être réécrits comme des implications dans les
clauses \lstinline'ensures' et les contrats d'instruction peuvent être réécrits
comme des implications dans des assertions.

Chaque paire, $(label, annotation)$ est traduite en une séquence
d'\emph{insertions de code}
$(l_1, c_1) \concat (l_2, c_2) \concat \ldots \concat (l_n, c_n)$, qui 
represente une liste de fragments de programmes C $c_1, c_2, \ldots, c_n$ où
le fragment $c_i$ sera inséré dans le programme instrumenté au label $l_i$.
Les annotations \eacsl sont traduites séparément et les séquences de fragments
résultant de la traduction sont traitées en suivant l'ordre des annotations dans
le programme.
Quand plusieurs fragments doivent être insérés au même endroit $l$, ils sont
insérés en respectant leur ordre dans la séquence (l'ordre dans lequel ils ont
été générés).

La traduction d'annotations est définie par les règles de la
section~\ref{sec:annot}.
Cela requiert de traduire les termes et les prédicats \eacsl.
Ces transformations sont décrites par les règles des sections~\ref{sec:term}
et~\ref{sec:pred}.
Dans ces règles, les notations suivantes sont utilisées :
\begin{itemize}
\item $p$, $p_1$, $p_2$ et $p_3$ sont des prédicats \eacsl;
\item $t$, $t_1$, $t_2$ et $t_3$ sont des termes \eacsl et $w$ est un prédicat
  ou un terme;
\item $c$, $c_1$, $c_2$ et $c_3$ sont des fragments de programmes C;
\item $e$, $e_1$, $e_2$ et $e_3$ sont des expressions C;
\item $l$, $l_1$, $l_2$, $l_3$, $Beg_f$, $End_f$, $BegIter_l$ et $EndIter_l$ sont
  des labels du programme;
\item $i$ est un identificateur de variable liée dans un prédicat \eacsl et un
  compteur d'itérations dans un programme C, $x$ est un identificateur de
  variable C;
\item $I$, $I_1$, $I_2$ et $I_3$ sont des listes d'insertions de code
  $(l_i, c_i)$.
\end{itemize}

Les variables \lstinline'res', \lstinline'var_n', \lstinline'i_n',
\lstinline|old_x|, \lstinline'old_val_x' et \lstinline|old_variant| sont
``fraîches'' (fresh), c'est-à-dire que ces identificateurs sont supposés
différents de tous les autres identifiants de variables du programme instrumenté
: quand on utilise plusieurs fois une règle introduisant une variable fraîche,
toutes les occurrences de la variable créée doivent être différentes.
Ceci peut être implémenté en incrémentant le compteur $n$ à chaque occurrence
dans \lstinline'var_n' et \lstinline'i_n', et en utilisant le nom de la variable
d'origine à la place de $x$ dans \lstinline'old_x' et \lstinline'old_val_x'.

Pour des raisons de commodité, nous supposons que toutes les variables logiques
liées dans les annotations et toutes les variables du programme sont
différentes, ceci nous permet en particulier de traduire les variables logiques
en C sans les renommer.


\subsubsection*{Exemple}
\label{sec:translation-example}


\lstinputlisting[style=c,escapechar=§,caption={Function C annotée décidant si
    \lstinline{v} est présent dans le tableau \lstinline{t} de taille
    \lstinline{n}},
  label=lst:normalized]{listings/is_present_normalized.c}

Nous présentons dans le listing~\ref{lst:normalized} un exemple de fonction sous
test normalisée en suivant la grammaire de la figure~\ref{fig:grammar}.
Elle retourne $1$ quand la valeur $v$ en paramètre est présente dans le tableau
$t$ en paramètre, ou $0$ sinon.
Le programme instrumenté obtenu après traduction des annotations de cette
fonction est présenté (utilisant la notation abrégée pour les entiers non
bornés) dans le listing~\ref{lst:abbrv}.
La clause \lstinline'requires' de la ligne 1 (listing~\ref{lst:normalized})
indique que la taille du tableau \lstinline|n| est positive, elle est traduite
à la ligne 6 du listing~\ref{lst:abbrv}.
La clause \lstinline'requires' de la ligne 2 (listing~\ref{lst:normalized}) 
indique que \lstinline|(t+0)|, \ldots, \lstinline|(t+(n-1))| sont des pointeurs
valides, elle est traduite à la ligne 7 du listing~\ref{lst:abbrv}).
La clause \lstinline'typically' de la ligne 3 du listing~\ref{lst:normalized}
(traduite ligne 8 du listing~\ref{lst:abbrv}), est une extension de la syntaxe
d'\eacsl définissant une précondition pour le test.
Elle renforce la précondition pour limiter l'explosion combinatoire du nombre de
chemins à explorer par la génération de tests, elle permet d'obtenir une
couverture partielle des chemins : seuls les chemins satisfaisant cette clause
sont considérés.
Ici elle limite l'espace des états de \lstinline'n' (et donc la taille de
\lstinline't') à $[0, 6]$ (cela peut être vu comme une ``finitization''
\cite{\citekorat}).
L'invariant de boucle de la ligne 9 du listing~\ref{lst:normalized} est traduit
aux lignes 10--12 du listing~\ref{lst:abbrv} pour vérifier que l'invariant est
vrai avant la première itération (établissement), et aux lignes 20--24 du
listing~\ref{lst:abbrv} pour vérifier la préservation de l'invariant après
chaque itération.
Notons que pour prouver formellement la postcondition, un invariant de boucle
supplémentaire est nécessaire, mais n'est pas inclus dans cet exemple simplifié 
: \lstinline|\forall integer k; 0<=k<i ==> \old(*(t+k))!=v;|.
Le variant de boucle ligne 10 du listing~\ref{lst:normalized} est traduit aux
lignes 15--16 du listing~\ref{lst:abbrv} pour vérifier que le variant est
positif ou nul avant chaque itération de la boucle, à la ligne 17 du
listing~\ref{lst:abbrv} pour mémoriser la valeur du variant au début de la
boucle, et aux lignes 25--26 du listing~\ref{lst:abbrv} pour vérifier que le
variant décroît strictement après chaque itération, assurant ainsi la
terminaison de la boucle.
La postcondition des lignes 4--5 du listing~\ref{lst:normalized} est traduite
aux lignes 29--34 du listing~\ref{lst:abbrv}, elle définit que
\lstinline|\result| est non nul si et seulement si il existe un élément de
\lstinline|t| égal à \lstinline|v|.
Les valeurs des paramètres formels \lstinline|t|, \lstinline|n| et \lstinline|v|
sont mémorisées lignes 3--5 du listing~\ref{lst:abbrv}, un nouveau tableau
\lstinline|old_val_t| stocke les anciennes valeurs contenues dans \lstinline|t|,
il est alloué ligne 3, rempli ligne 5 et désalloué ligne 35.


\section{Traduction des termes \eacsl}
\label{sec:term}


\input{figures/fig_rules}

Soit
$(l, t:T) \rulearrow ((l_1, c_1) \concat (l_2, c_2) \concat \ldots \concat (l_n, c_n), e)$
une instance de la fonction partielle $\tau$ qui à un terme \eacsl $t$ de type
$T$ au label $l$ associe la paire $(I, e)$ où $I$ est une liste d'insertions de
code $(l_i, c_i)$, $e$ est une expression C, et $T$ peut être $\mathbb{Z}$
(\lstinline'integer') ou $ctype$.
Les insertions de code sont les instructions C nécessaires à l'évaluation du
terme, elles permettent notamment d'évaluer les termes auxiliaires dont est
composé le terme $t$.
L'expression $e$ est pure (elle ne provoque pas d'effet de bord) et correspond
à l'évaluation du term $t$ au point de programme donné $l$.
L'évaluation de $e$ requiert le plus souvent plusieurs opérations, qui sont
effectuées par les fragments de programme qui résultent de la traduction du
terme et seront insérés aux endroits adéquats dans le programme instrumenté.
Par exemple, un terme quantifié (comme une somme : \lstinline'sum') a besoin de
plusieurs instructions pour être évalué, et notamment d'une boucle (voir la
figure~\ref{fig:builtin}).
Dans ce cas, le second élément de la paire retournée, $e$ est la valeur de la
variable calculée par la boucle.
Nous considérons comme étant inclus dans $ctype$ les types suivants : $ptr$,
type pointeur pointant vers n'importe quel type du C, et le type C
\lstinline'int'.
Les autres types C tels \lstinline'char', \lstinline'long',
\lstinline'unsigned', etc. peuvent être supportés de manière similaire, mais ne
sont pas abordés pour des raisons de simplicité et lisibilité.
Quand un terme $t$ peut être traduit directement sans nécessiter de code C
supplémentaire, la séquence d'insertions de code est vide et notée $\emptyset$.
Pour un terme $t:\mathbb{Z}$, le resultat de traduction $e$ est toujours une
variable de type \lstinline'Z_t' (ce qui justifie une désallocation
\lstinline{e}${}^{\boxtimes}$, voir figure~\ref{fig:coerce}).

La figure~\ref{fig:const-id} présente les règles de traduction pour les
identificateurs de variable (\textsc{$\tau$-var}), pour le terme
\lstinline|\result| (\textsc{$\tau$-res}) et pour les constantes
(\textsc{$\tau$-const}).
Deux règles sont nécessaires pour traduire la construction \eacsl
\lstinline|\old|.
Appliquée à un identificateur $x$ (règle \textsc{$\tau$-old}), le terme est
traduit en variable fraîche \lstinline|old_x| qui contient la valeur de $x$ au
début de la fonction.
Appliquée à un accès mémoire (règle \textsc{$\tau$-old-val}), on utilise le
tableau alloué dynamiquement \lstinline|old_val_x| qui contient les valeurs du
tableau ou pointeur \lstinline'x' au début de la fonction (se référer à la
section~\ref{sec:principles}).
Le terme \lstinline|\result| est traduit par la règle \textsc{$\tau$-res}, il
fait référence à la valeur de retour de la fonction en \eacsl qui est écrite
dans la variable \lstinline|res|.
Cette variable est unique dans chaque fonction après normalisation de l'arbre de
syntaxe abstrait (AST) par \framac.
La règle \textsc{$\tau$-const} établit qu'une variable entière est définie pour
prendre la valeur d'une contante entière.

La figure~\ref{fig:coerce} détaille les règles de conversions implicites, de
\lstinline'integer' vers type C et de type C vers \lstinline'integer'.

La figure~\ref{fig:op} détaille les règles pour les opérations unaires
(\textsc{$\tau$-unop$_{*}$}), les opérations binaires
(\textsc{$\tau$-binop$_{*}$}) et la condition ternaire sur les termes
(\textsc{$\tau$-if}).
\textsc{$\tau$-unop$_1$} traite le cas de l'indirection de pointeur ($\star$).
\textsc{$\tau$-unop$_2$} traite le cas de la négation logique (\lstinline|!|) et
n'opère que sur un \lstinline'int', si c'est un \lstinline'integer' il est
converti en utilisant la règle \textsc{$\tau$-coerce$_1$}.
\textsc{$\tau$-unop$_3$} traite le cas du \lstinline|-| unaire et du complément
bit-à-bit ($\sim$) et on suppose que ces opérations prennent un
\lstinline'integer' en entrée et en sortie.

\textsc{$\tau$-binop$_1$} traite l'arithmétique de pointeur, l'opérande gauche
est un pointeur, $op$ doit être \lstinline|+| ou \lstinline|-|, et l'opérande
droite est de type \lstinline'int'.
\textsc{$\tau$-binop$_2$} traite la comparaison, $op$ est un opérateur de
comparaison sur les entiers et le résultat de la comparaison est stocké dans un
\lstinline|int|.
\textsc{$\tau$-binop$_3$} traite les opérations arithmétiques entières (les
opérandes et le résultat sont des entiers), $op$ est un des opérateurs
arithmétiques suivants : \lstinline|+|, \lstinline|-|, \lstinline|/|,
\lstinline|%|, \lstinline|<<|, \lstinline|>>|, \lstinline{|}, \lstinline|&|,
\lstinline|^|.
Dans la règle \textsc{$\tau$-if}, les évaluations de $t_2$ et $t_3$ sont dans
des branches conditionnelles : on calcule uniquement l'un des deux, en fonction
de l'évaluation de $t_1$.

La figure~\ref{fig:builtin} présente les règles de traduction pour les fonctions
logiques \lstinline|\sum| (\textsc{$\tau$-sum}) et \lstinline|\numof|
(\textsc{$\tau$-numof}).
La règle pour la fonction \lstinline|\product| est similaire à la règle
\textsc{$\tau$-sum}.
La règle \textsc{$\tau$-sum} permet de calculer une somme d'entiers non bornés,
elle initialise une variable entière fraîche \lstinline|var_n| à $0$ et
l'incrémente avec la valeur du \lstinline|\lambda|-terme \lstinline't3' à chaque
itération.
La règle \textsc{$\tau$-numof} initialise aussi une variable entière fraîche
\lstinline|var_n| à $0$, mais incrémente sa valeur uniquement quand le
\lstinline|\lambda|-terme \lstinline't3' (non entier) s'évalue en une expression
non nulle.


\section{Traduction des prédicats \eacsl}
\label{sec:pred}


De manière similaire à la fonction de traduction $\tau$ pour les termes
(section~\ref{sec:term}), la fonction de traduction des prédicats, notée $\pi$,
est définie comme une fonction partielle qui, à un label et un prédicat \eacsl
$p$, associe une séquence d'insertions de code $(l_i, c_i)$ et une expression C
$e \in \{0, 1\}$ (que nous encoderons dans un \lstinline'int').
Les insertions de code sont les instructions C nécessaires à l'évaluation du
prédicat, elles permettent notamment d'évaluer les termes et prédicats
auxiliaires dont est composé le prédicat $p$.
Quand un prédicat $p$ peut être traduit directement et ne nécessite pas la
création d'instructions C, la séquence d'insertions est vide et notée
$\emptyset$.

Nous définissons dans la figure~\ref{fig:pred-logic}, la figure~\ref{fig:valid}
et la figure~\ref{fig:quantif} les règles de traduction pour les principaux
prédicats \eacsl que nous supportons.

La figure~\ref{fig:pred-logic} détaille les règles de traduction pour les
prédicats les plus simples du langage \eacsl.
Les règles \textsc{$\pi$-true} et \textsc{$\pi$-false} indiquent que
\lstinline'\true' (respectivement \lstinline'\false') se traduit en $1$
(respectivement $0$).
Les règles \textsc{$\pi$-equiv} et \textsc{$\pi$-not} sont compositionnelles :
les prédicats fils sont traduits récursivement, puis le résultat de la
traduction est construit à partir des valeurs des prédicats fils.
Les règles \textsc{$\pi$-and}, \textsc{$\pi$-or} et \textsc{$\pi$-impl}
reflètent l'évaluation paresseuse de ces opérateurs selon la sémantique d'\eacsl
: le premier opérande est toujours évalué (en $I_1$) mais le deuxième n'est
évalué (en $I_2$) que si nécessaire.
La règle \textsc{$\pi$-if} est similaire à \textsc{$\tau$-if} (voir
section~\ref{sec:term}).
Dans l'exemple du listing~\ref{lst:normalized}, la traduction de la
postcondition
\lstinline{\result != 0 <==> \exists integer i; 0<=i<n && *(t+i)==v} requiert
la traduction des prédicats \lstinline|\result != 0| et
\lstinline{\exists(...)} qui sont respectivement traduits en \lstinline|var_32|
et \lstinline|var_35|.
Ces deux prédicats sont assemblés pour construire la traduction du prédicat
composé, d'après la règle \textsc{$\pi$-equiv},:
\lstinline{(!var_32 || var_35) && (!var_35 || var_32)} (line 34 du
listing~\ref{lst:abbrv}).
Dans la règle \textsc{$\pi$-rel}, \lstinline|op| est un des opérateurs suivants
: \lstinline[style=c]{<, <=, >, >=, ==, !=}.

La figure~\ref{fig:valid} montre les règles de traduction pour le prédicat
\lstinline|\valid|, qui est vrai si le pointeur en argument pointe vers une
case mémoire valide et peut être déréférencé.
\lstinline'\valid(t)' exprime la validité d'un seul pointeur et
\lstinline'\valid(t1+(t2..t3))' exprime la validité du pointeur \lstinline't1'
dans l'intervalle d'offsets \lstinline't2..t3', ce qui veut dire que
\lstinline'(t1+t2)', \lstinline'(t1+t2+1)' \dots, \lstinline'(t1+t3)' sont
valides.
Les règles \textsc{$\pi$-valid} et \textsc{$\pi$-valid-range} couvrent les deux
cas.
On suppose que l'évaluation de la validité d'un pointeur est possible au moyen
d'une fonction \lstinline'fvalid' et que l'évaluation d'un pointeur sur un
intervalle d'offsets peut se faire au moyen d'une fonction
\lstinline'validr'.
Le support de ces prédicats nécessite une représentation précise de la mémoire
du programme, la réalisation de telles fonctions est abordée dans le
chapitre~\ref{sec:runtime}.
Dans notre exemple du listing~\ref{lst:normalized}, le prédicat
\lstinline|\valid(t+(0..n-1))| de la clause \lstinline|requires| de la ligne 2
est traduit en \lstinline[style=c]|fvalidr(t,0,(n-1))| (ligne 7 du
listing~\ref{lst:abbrv}).

La règle \textsc{$\pi$-exists} (figure~\ref{fig:quantif}) aborde la traduction
du prédicat existentiel \lstinline'\exists', quantifié sur les entiers.
Le code généré met à jour une variable \lstinline'var_n' (initialement $false$)
à chaque itération de la boucle, jusqu'à ce que toutes les valeurs de
\lstinline'i' soient considérées ou que \lstinline'var_n' soit évalué à $true$.
Cette règle permet aussi de traduire le prédicat universellement quantifié
\lstinline{\forall integer i; t1<=i<t2 ==> p}, ce dernier étant équivalent à
\lstinline{! (\exists integer i; t1<=i<t2 && !p)}.
Dans le listing~\ref{lst:normalized}, le prédicat
\lstinline{\exists integer i; 0<=i<n && *(t+i)==v} de la ligne 4 est traduit
aux lignes 29--33 du listing~\ref{lst:abbrv} et la variable fraîche contenant la
valeur du prédicat après évaluation est \lstinline|var_35| (déclarée à la
ligne 31).


\section{Traduction des annotations \eacsl}
\label{sec:annot}


Définissons maintenant les règles de traduction de haut niveau pour les
annotations, qui permettent de mettre en évidence les échecs d'annotation.
Pour chaque annotation, un fragment de programme C se terminant par une
condition est inséré dans le programme.
Le générateur de tests essaiera de couvrir tous les chemins d'exécution
faisables, donc s'il existe des entrées permettant de provoquer un échec de la
condition de l'annotation, l'erreur sera trouvée.
Les règles sont de la forme suivante :


\vspace{-4mm}
\[
\dfrac
    {(l_1, w) \rulearrow (I_1, e_1) \quad \ldots \quad
      (l_n, w) \rulearrow (I_n, e_n)}
    {(l, \mbox{\lstinline'kwd w;'}) \rulearrow
      g_{kwd} (l, (I_1, e_1), \ldots, (I_n, e_n))}
\]
\vspace{-4mm}


Ce schéma de traduction établit que le terme ou prédicat $w$ au label $l_i$ est
traduit (par $\tau$ ou $\pi$) en $(I_i, e_i)$, puis l'annotation
\lstinline'kwd w;' au point de programme $l$ est traduite par composition
des insertions de code $I_i$ et des expressions $e_i$.
Cette fonction de composition -- notée $g_{kwd}$ -- dépend de la nature de
l'annotation.
La figure~\ref{fig:annot} et la figure~\ref{fig:loop-annot} présentent les
règles de traduction pour chaque annotation.
Soit la condition $e$ qui doit être testée pour chaque annotation, qui
correspond au statut de validité de l'annotation en question.
Nous définissons une fonction \lstinline'fassert' permettant de tester la valeur
d'une expression, cette fonction correspond à un \lstinline'if' dont la branche
\lstinline'else' génère une erreur et la rapporte.
Nous définissons également une fonction \lstinline'fassume' permettant de tester
la valeur d'une expression, cette fonction correspond à un \lstinline'if' dont
la branche \lstinline'then' est toujours vraie, les exécutions pour lesquelles
la branche \lstinline'else' est activée sont ignorées.

La figure~\ref{fig:annot} décrit les règles de traduction pour les assertions
(\textsc{$\alpha$-assert}), les préconditions (\textsc{$\alpha$-check-pre} et
\textsc{$\alpha$-assume-pre}), les assigns (\textsc{$\alpha$-check-assigns} et
\textsc{$\alpha$-assume-assigns}) et les postconditions
(\textsc{$\alpha$-check-post} et \textsc{$\alpha$-assume-post}).
La règle \textsc{$\alpha$-assert} vérifie simplement la valeur du prédicat
traduit au label $l$ avec la fonction \lstinline'fassert'.
La règle \textsc{$\alpha$-check-pre} vérifie le prédicat, et la règle
\textsc{$\alpha$-assume-pre} suppose sa validité au début de la fonction
intrumentée.
La règle \textsc{$\alpha$-check-assigns} vérifie que les l-values qui ne sont
pas dans une clause \lstinline'assigns' ne sont pas modifiées par la fonction.
Pour chacune de ces l-value, une sauvegarde est faite au début de la fonction,
puis on vérifie que la valeur n'a pas été modifiée en fin de fonction.
La règle \textsc{$\alpha$-assume-assigns} suppose que toutes les l-values
présentes dans la clause \lstinline'assigns' ont changé de valeur : elle affecte
une nouvelle valeur non déterministe à chacune d'elle à la fin de la fonction.
La règle \textsc{$\alpha$-check-post} vérifie le prédicat et la règle
\textsc{$\alpha$-assume-post} suppose sa validité à la fin de la fonction
instrumentée.
Dans l'exemple du listing~\ref{lst:normalized}, les clauses \lstinline'requires'
et \lstinline'typically' des lignes 1, 2 et 3 sont traduites (en utilisant la
règle \textsc{$\alpha$-assume-pre}) respectivement aux lignes 6, 7 et 8 du
listing~\ref{lst:abbrv}.
La postcondition aux lignes 4--5 du listing~\ref{lst:normalized} est traduite
en utilisant la règle \textsc{$\alpha$-check-post} aux lignes 29--34 du
listing~\ref{lst:abbrv}.

Les règles de traduction pour les invariants de boucle
(\textsc{$\alpha$-check-invariant}, \textsc{$\alpha$-assume-invariant-1} et
\textsc{$\alpha$-assume-invariant-2}), les variants de boucle
(\textsc{$\alpha$-variant}) et les loop assigns
(\textsc{$\alpha$-check-loop-assigns} et \textsc{$\alpha$-assume-loop-assigns})
pour une boucle au label $l$ sont présentées dans la
figure~\ref{fig:loop-annot}.
La règle \textsc{$\alpha$-check-loop-assigns} vérifie que les l-values qui ne
sont pas dans la clause \lstinline'loop assigns' ne sont pas modifiées par la
boucle. Pour chacune de ces l-values, une sauvegarde est faite au début de
chaque itération, puis on vérifie que la valeur n'a pas été modifiée en fin de
boucle.
La règle \textsc{$\alpha$-assume-loop-assigns} suppose que toutes les l-values
présentes dans la clause \lstinline'loop assigns' ont changé de valeur : une
nouvelle valeur non déterministe est affectée à chacune d'elle.
La règle \textsc{$\alpha$-check-invariant} vérifie le prédicat de l'invariant
avant la boucle et après chaque itération de la boucle.
La règle \textsc{$\alpha$-assume-invariant-1} a vocation à remplacer toute la
boucle, elle suppose que le prédicat de l'invariant est vrai, ainsi que la
négation de la condition de boucle (appelée ici \lstinline'loopcond').
La règle \textsc{$\alpha$-assume-invariant-2} permet de supposer que la boucle
a déjà itéré un certain nombre de fois, elle suppose que l'invariant est vrai
avant la boucle, et vérifie l'invariant à la fin de chaque itération.
La règle \textsc{$\alpha$-variant} vérifie que le terme variant est non-négatif
au début de chaque itération, puis mémorise la valeur du terme au début de la
boucle dans une variable fraîche \lstinline|oldvariant|. Enfin, on vérifie à la
fin de chaque itération que le variant décroît strictement (par rapport à sa
valeur au début de l'itération).
Dans notre exemple du listing~\ref{lst:normalized}, la traduction du
\lstinline'loop invariant' de la ligne 9 par la règle
\textsc{$\alpha$-check-invariant} donne les lignes 10--12 et 20--24 du
listing~\ref{lst:abbrv}, tandis que la traduction du \lstinline'loop variant'
ligne 10 par la règle \textsc{$\alpha$-variant} produit les lignes 15--17 et
25--26 du listing~\ref{lst:abbrv}.


\section[Test vs. Validation à l'Exécution]{Similarités et Différences selon
  l'objectif Test vs. Validation à l'Exécution}


La traduction d'annotations \eacsl en code C a été implémentée dans deux
greffons \framac : \eacsltoc \cite{Delahaye/SAC13,Kosmatov/RV13} et \stady
\cite{Petiot/TAP14,Petiot/SCAM14}.
Le premier génère un programme instrumenté pour la validation d'assertions à
l'exécution, le second génère un programme instrumenté pour la génération de
tests avec \pathcrawler \cite{\citepathcrawler}.
Cette section discute les similarités et les différences entre ces deux façons
d'instrumenter.

La traduction pour la génération de test et la traduction pour la validation à
l'exécution ont toutes deux besoin de générer du code exécutable, c'est pourquoi
un sous-ensemble exécutable du langage de spécification est considéré dans les
deux cas.
La plupart des règles définies dans les sections~\ref{sec:term},
\ref{sec:pred} et \ref{sec:annot} sont autant valables pour la validation à
l'exécution que pour le test, le code généré devant être correct vis-à-vis de la
sémantique des annotations.
Cependant, il y a plusieurs différences liées à la différence d'objectif.
Les quatre différences sont :
\begin{itemize}
\item la manière de considérer la précondition de la fonction sous test;
\item la manière de traiter les annotations liées au modèle mémoire;
\item la manière de traiter les fonctions sur les entiers mathématiques;
\item et la manière de traiter les potentielles erreurs à l'exécution
  introduites par les fragments de code résultant de la traduction.
\end{itemize}


\textbf{Précondition de la fonction sous test.}
Une première différence est le traitement de la précondition de la fonction sous
test.
En vérification à l'exécution, elle est vérifiée comme n'importe quelle autre
annotation.
En génération de tests, la précondition est utilisée pour éviter de tester le
programme avec des valeurs d'entrées incorrectes, pour lesquelles le bon
fonctionnement du programme n'est pas garanti.
La préconditon de la fonction sous test est donc supposée vraie pour la
génération de tests, afin de s'assurer que toutes les entrées générées par le
test satisfont cette précondition.

%% Besides, the treatment of the precondition of the FUT in \pathcrawler has two optimizations.
%% First, an internal mechanism of unquantified and quantified preconditions
%% allows a direct translation of ACSL preconditions into constraints
%% supported in an efficient manner.
%% Hence, for precondition patterns that can be expressed by this mechanism,
%% a translation into C code is not necessary for \pathcrawler.
%% Second, for the remaining preconditions translated into a C function, 
%% \pathcrawler offers a specific
%% efficient mechanism \cite{Delahaye/RV13}.
%% A call to \lstinline|fassume| (adding the constraints of the
%% precondition to the constraint store \emph{before} the path predicate in the FUT)
%% can be replaced in \pathcrawler by a dedicated support for
%% late precondition (where precondition constraints are posted \emph{after}
%% other path constraints of the FUT).
%% Thus the call to \lstinline|fassume| for the FUT 
%% in \pathcrawler is not needed.

\textbf{Annotations liées au modèle mémoire.}
La validation à l'exécution nécessite une instrumentation complexe pour traiter
les constructions \eacsl liées au modèle mémoire comme \lstinline'\valid',
\lstinline'\block_length', \lstinline'\base_addr', etc.
Chaque opération affectant la mémoire doit être instrumentée et les informations
de chaque case mémoire doivent être enregistrées afin de pouvoir évaluer ces
annotations \cite{Kosmatov/RV13}.
Nous aborderons les spécificités d'une telle instrumentation dans le
chapitre~\ref{sec:runtime}.
Certaines de ces constructions peuvent être traitées symboliquement en test
concolique sans nécessiter d'instrumentation spécifique dans le code C.
C'est ce que nous faisons ici en supposant la définition de fonctions C
\lstinline'fvalid' et \lstinline'fvalidr' supportées par le générateur de tests,
qui retournent la valeur de validité du pointeur en argument si celui-ci est
une variable globale ou un paramètre formel de la fonction sous test
\cite{Chebaro/ICSSEA12}.

\textbf{Arithmétique non bornée.}
Tandis que l'utilisation d'une bibliothèque externe d'artihmétique non bornée
(comme GMP) pour traduire les entiers d'\eacsl est appropriée pour la validation
à l'exécution, il n'en est pas de même pour la génération de tests :
si le code des functions de la bibliothèque est analysé par le
générateur de tests, alors cette solution se révèlera inefficace.
En effet, la génération de tests à partir du programme instrumenté aura à
traiter un code beaucoup plus compliqué, avec de nombreux appels de fonctions, 
des allocations/désallocations dynamiques, etc.
Ceci peut être évité en exécutant symboliquement les fonctions de la
bibliothèque : \pathcrawler offre un support dédié aux fonctions de la
bibliothèque GMP, dont les opérations sont traduites efficacement en contraintes
sur les entiers non bornés, que le solveur de contraintes sous-jacent peut
traiter.

\textbf{Erreurs à l'exécution.}
La traduction d'annotations en C peut introduire des erreurs à l'exécution dues
aux termes dont la sémantique est indéfinie dans les annotations, comme
\lstinline'1/0' (voir section~\ref{sec:undefined}).
Ce problème peut être évité pour la génération de tests comme proposé dans
\cite{Delahaye/SAC13} pour la validation à l'exécution, en utilisant le greffon
\rte \cite{\citeframac} sur le code résultant de l'instrumentation, celui-ci va
rajouter des gardes supplémentaires et il suffit ensuite de ré-instrumenter le
programme en tenant compte de ces nouvelles annotations.
Les erreurs à l'exécution liées aux entiers non bornés (division d'un entier
GMP par $0$, débordement pendant une conversion
\lstinline[mathescape=true]{(int)(t:$\mathbb{Z}$)}, etc.) ne sont pas traités
par \rte mais ces erreurs peuvent être évitées en ajoutant les gardes
nécessaires aux règles de traduction.
Par exemple, le cast d'un terme $t$ d'\lstinline'integer' vers \lstinline'int'
(voir la règle \textsc{$\tau$-coerce$_1$} de la figure~\ref{fig:coerce}) peut
être gardée en ajoutant
\lstinline{fassert(}\underline{\lstinline{INT\_MIN <= e}}\lstinline{ && }\underline{\lstinline{e <= INT\_MAX}}\lstinline{)} avant l'affectation
\underline{\lstinline'var_n = e'}.

%% already said earlier.
%% \textbf{Triggering errors during test generation.}
%% The function \lstinline|fassert(cond)| is a C macro defined by
%% \textsc{PathCrawler} that is expanded as a conditional
%% \lstinline|if(cond)|, testing
%% if its parameter is true. Covering all feasible paths of the
%% program will therefore enforce the generation of test inputs activating the
%% $then$ branch of this condition, and test inputs activating the
%% $else$ branch. So if there exist inputs such that \lstinline'cond' is evaluated to
%% $false$, a test case activating the \lstinline|fassert| thus
%% violating the corresponding annotation is generated. In other terms, a
%% counter-example for that annotation is generated if such inputs exist.

\section*{Conclusion du chapitre}

L'objectif de ce chapitre était de définir une traduction en C des annotations
\eacsl pour la génération de tests.
Nous avons tout d'abord présenté le processus de la traduction dans sa
généralité.
Puis nous avons défini les règles permettant pour chaque terme et prédicat
\eacsl d'obtenir un code C calculant cette expression tout en préservant la
sémantique d'\eacsl.
Ces règles nous ont permis de définir différentes manières de traduire les
annotations \eacsl : \lstinline'assert', \lstinline'requires',
\lstinline'typically', \lstinline'assigns', \lstinline'ensures',
\lstinline'loop invariant', \lstinline'loop assigns' et
\lstinline'loop variant'.
Ces différentes instrumentations des annotations nous permettront par la suite
de détecter différentes erreurs dans le code et la spécification.
Le chapitre suivant aborde la preuve de correction des règles de traduction des
termes, prédicats et annotations.
