
\chapter{Traduction pour le test}
\label{sec:traduction}

\chapterintro


Ce chapitre détaille les règles à appliquer pour traduire des annotations \eacsl
en code C sémantiquement équivalent.
Cette méthode permet d'utiliser un outil de génération de tests prenant des
programmes C en entrée, sans que ce outils n'aient à traiter les annotations
\eacsl.
Le processus de traduction est présenté dans sa généralité, puis sont détaillées
les règles de traduction (du niveau le plus bas vers le niveau le plus haut) des
termes, des prédicats et des annotations \eacsl.
Enfin, nous abordons les différences entre une traduction pour le test et une
traduction pour la validation à l'exécution.


\section{Processus de transformation de programme}


\input{figures/fig_grammar}

Cette section présent le processus d'instrumentation des fonctions C annotées
avec le langage d'annotations \eacsl pour la génération de tests.
Pour des raisons de commodité, nous considérons qu'un label précède chaque
instruction et annotation à l'intérieur d'une fonction.
Considérons aussi la présence d'un label au début et à la fin de chaque corps de
boucle.
(Strictement parlant, les labels ne peuvent pas être placés juste avant les
déclarations de variables ou l'accolade fermante ``$\bclose$'' en C, mais
cette limitation peut être contournée par l'ajout d'une instruction ``skip''
(``\lstinline{;}'') après ces labels.)
Nous supposons que les fonctions respectent la forme normale définie par
l'entité syntactique \textit{function} de la grammaire définie
figure~\ref{fig:grammar}. 
Dans cette figure, la notation ``${\textit{as}\;X}$'' en exposant signifie que
chaque occurrence de $X$ dans la règle courante doit être remplacée par la
chaîne à laquelle on fait référence en exposant.
Par exemple, si \texttt{foo} est le nom ($id$) de la fonction sous test dans la
règle $function$, les labels $\texttt{Beg}_f$ et $\texttt{End}_f$ dans le corps
de cette fonction sont remplacés par $\texttt{Beg}_{\texttt{foo}}$ et
$\texttt{End}_{\texttt{foo}}$, ce qui assure des labels uniques au début et à la
fin du corps de la fonction.
Les accès aux pointeurs et aux tableaux sont notés \lstinline|*(p+i)|.
Les symboles terminaux sont présentés en police \texttt{typewriter}.
Les symboles non-terminaux \underline{soulignés} ne sont pas détaillés car ils
font partie des langages C ou \eacsl.
$Termes$ et $predicats$ sont des expressions \eacsl qui sont décrits en
section~\ref{sec:term} et section~\ref{sec:pred}.


\subsection{Sous-langage considéré}

Le langage de spécification \eacsl est un sous-langage exécutable d'\acsl, qui
est un langage de spécification comportementale implémenté dans \framac.
Premièrement, étant un sous-ensemble d'\acsl, \eacsl préserve la sémantique
d'\acsl, ce qui implique que les greffons de \framac existants supportant \acsl
peuvent être utilisés avec \eacsl sans modification.
Deuxièmement, le langage \eacsl est \textit{exécutable}, ce qui veut dire que
toutes les annotations peuvent être traduites en C et exécutées, il peut donc
être utilisé pour l'analyse dynamique et le \textit{monitoring} (surveillance
d'exécution).

\eacsl est basé sur une logique du premier ordre typée dans laquelle chaque
terme peut contenir des expressions C pures (sans effets de bord) et des
mots-clés du langage.
Par exemple, le mot-clé \lstinline{\result} permet de faire référence au
résultat d'une fonction, \lstinline{\valid} est un prédicat qui renvoie vrai si
son argument est un pointeur valide (se référer au manuel du
langage~\cite{\citeacsl}).
Les quantificateurs existentiels et universels sont bornées par des contraintes
de domaines finis d'entiers afin de rester exécutable.
Un contrat de fonction à la \textsc{Eiffel} \cite{eiffel} peut être associé à
chaque fonction pour spécifier les pré- et postconditions.
Ces contrats peuvent définir des comportements (\lstinline{behaviors}) gardés et
nommés, pour lesquels l'exhaustivité (\textit{completeness}) et/ou la séparation
(\textit{disjointness}) peut être requise.
Les assertions, les invariants de boucle et les variants peuvent aussi être
associés aux instructions.
Abordons maintenant deux des choix les plus importants du langage: les entiers
mathématiques et la non-définition (nous utiliserons le terme anglais
\textit{undefinedness}).


\subsubsection{Entiers mathématiques}\label{sec:eacsl-integers}


En plus des entiers machine, les termes \eacsl peuvent être des entiers
mathématiques de type \lstinline{integer} : les constantes entières, les
opérations sur les entiers, ainsi que les variables logiques sont de type
\lstinline{integer}.
L'arithmétique entière est non bornée et donc les débordements d'entier
(\textit{overflows}) sont impossibles.
\eacsl dispose d'un système de sous-typage pour convertir automatiquement les
types entiers du C vers les entiers mathématiques.
Par exemple, si \lstinline{x} est une variable C de type \lstinline{int},
\lstinline{x+1} et \lstinline{1} sont de type \lstinline{integer} et une
conversion implicite d'\lstinline{int} vers \lstinline{integer} est introduite
dans ce contexte quand la variable \lstinline{x} est typée.
Ce choix a été fait pour plusieurs raisons.
Premièrement, un des buts principaux de \framac est la preuve de programmes par
appels à des prouveurs externes, la plupart de ces prouveurs fonctionnent mieux
avec l'arithmétique entière qu'avec l'arithmétique bornée (ou modulaire).
Deuxièmement, les spécifications sont habituellement écrites sans se préoccuper
des détails d'implémentation, et les débordements d'entiers sont des détails
d'implémentation.
Troisièmement, il reste possible d'utiliser l'arithmétique bornée si besoin en
utilisant des conversions explicites (\textit{casts}).
Par exemple, \lstinline{(int)(INT_MAX + 1)} est égal à \lstinline{INT_MIN}, la
plus petite valeur représentable de type \lstinline{int}.
Quatrièmement, ce choix facilite l'expression des débordements potentiels dans
les spécifications : par exemple, grâce à l'arithmétique entière,
\lstinline{/*@ assert INT_MIN <= x+y <= INT_MAX;*/} est le moyen le plus simple
de spécifier que \lstinline{x+y} ne déborde pas.
Dans la suite, sauf mention contraire, ``entier'' fait référence à
``entier non-borné''.


\subsubsection{Undefinedness}\label{sec:undefined}


\eacsl est exécutable.
Cependant, l'évaluation de termes indéfinis comme \lstinline{1/0} n'est pas
possible.
Pour résoudre ce problème, \eacsl suit la sémantique de vérification à
l'exécution définie par Chalin~\cite{chalin10}, selon laquelle la sémantique de
tels termes est ``indéfinie'' (\textit{undefined}) : \eacsl utilise une logique
tri-valuée~\cite{konikowska91} comme \textsc{Spark2014}~\cite{sparkERTS2014} ou
\jml \cite{\citejml}.
Il est de la responsibilité des outils interprétant \eacsl de s'assurer que les
termes indéfinis ne sont jamais évalués.
Une conséquence indirecte de ce choix est qie les opérateurs \lstinline{&&}\,,
\ \lstinline{||}\,, \ \lstinline{_?_:_} \ et\ \lstinline{==>} sont
``paresseux'' (comme leur équivalent C pour les trois premiers).


\subsection{Support des entiers mathématiques}\label{sec:integers}


\lstinputlisting[style=c,escapechar=§,caption={Propriétés des entiers : faux
    négatif dû à une traduction naïve},label=lst:Z:1]
                {listings/naive_false_negative.c}

\lstinputlisting[style=c,caption={Propriétés des entiers : faux positif dû à
    une traduction naïve},label=lst:Z:2]
                {listings/naive_false_positive.c}


Le listing~\ref{lst:Z:1} et le listing~\ref{lst:Z:2} montrent deux exemples où
une traduction naïve des annotations contenant des entiers mathématiques mènent
à un résultat incorrect.
Soit \lstinline'x' de type \lstinline'int'.
L'assertion ligne 1 du listing~\ref{lst:Z:1} est fausse lorsque
\lstinline'x = INT_MAX'.
La traduction naïve de cette assertion (ligne 3) utilise les entiers machine
avec arithmétique modulaire (supposons une architecture 32 bits), donc
\lstinline'x+1' reste inférieur ou égal à \lstinline'INT_MAX' pour toute valeur
de \lstinline'x', rendant tout échec de l'assertion impossible.
La traduction correcte pour cette annotation (lignes 6--9) conserve la
sémantique de l'arithmétique entière non bornée en utilisant une bibliothèque
externe (nous avons choisi GMP, la bibliothèque GNU Multi-Precision) pour
représenter les valeurs pouvant provoquer un débordement d'entier (ici
\lstinline'INT_MAX+1').
Les variables nécessaires pour la gestion des entiers non bornés sont crées et
initialisées, puis le résultat est calculé et les comparaisons sont faites en
tant qu'entier non borné.
Le second exemple (listing~\ref{lst:Z:2}) définit une assertion \eacsl (ligne 2)
qui est toujours correcte : pour tout entier positif \lstinline'x', son
successeur est aussi positif.
Une traduction naïve de cette annotation (ligne 3) génèrera une erreur à
l'exécution pour \lstinline'x = INT_MAX' : en arithmétique modulaire
\lstinline'x+1' déborde et devient négatif, violant l'assertion ligne 2.
Une traduction correcte utilisant les entiers non bornés (non présentée ici)
conserve le comportement attendu : l'assertion est vraie pour tout entier
positif \lstinline'x'.
Une traduction naïve des annotations dans ces deux exemples résulterait en un
faux négatif dans le premier cas et en un faux positif dans le deuxième cas, ce
qui porterait atteinte à la correction et à la précision de notre méthode.
Les règles de traduction pour les constructions \eacsl que nous présentons
respectent la sémantique des entiers non bornés d'\eacsl et suppose
l'utilisation d'une bibilothèque externe telle GMP, comme illustré dans le
listing~\ref{lst:Z:1}.

Pour simplifier la lecture des insertions de code générées par la traduction,
nous utilisons la notation abrégée ${}^{\square}$\lstinline{var} pour indiquer
que la variable \lstinline{var} doit être déclarée et allouée (avec
\lstinline{Z_t var; Z_init(var);}) au début de la portion de code insérée, et la
notation \lstinline{var}${}^{\boxtimes}$ pour indiquer que la variable
\lstinline{var} doit être désallouée (avec \lstinline{Z_clear(var);})
à la fin du code inséré.
Nous soulignons les fragments de code afin d'indiquer que l'opération effectuée
(affectation, comparaison, \dots) utilise l'arithmétique non bornée est doit
être traduite en utilisant les fonctions correspondantes d'une bibliothèque
comme GMP.
Les lignes 12--13 du listing~\ref{lst:Z:1} illustrent la notation abrégée de 
l'instrumentation des lignes 6--9.
\framac explicite les conversion de type implicites dans les annotations, donc
le terme \lstinline'x+1' ligne 1 du listing~\ref{lst:Z:1} devient
\lstinline'(integer)(x+1)'.


\subsection{Principes généraux}
\label{sec:principles}


\lstinputlisting[style=c,escapechar=§,caption={Instrumented version of program
    of Listing~\ref{lst:normalized}},label=lst:abbrv]
                {listings/is_present_instrumented.c}


Présentons maintenant les principes de la traduction d'une fonction $f$ annotée
respectant la grammaire de la figure~\ref{fig:grammar}.
Premièrement, chaque valeur d'entrée \lstinline'x' (un paramètre formel de la
liste $params$ ou une variable globale) de type $T$ est mémorisée par
l'instruction \lstinline|T old_x = x;| au début de la fonction sous test
instrumentée, c'est-à-dire au label $Beg_f$, dans la section $decl^*$.
Pour chaque tableau ou pointeur \lstinline'x', les valeurs pointées sont
mémorisées dans un tableau alloué dynamiquement \lstinline'old_val_x' dont la
taille est inférée à partir du prédicat \lstinline'\valid' dont on suppose la
présence en précondition de la fonction sous test.
%% We also generate an additional function named \lstinline'f_precond'
%% that is used to check the precondition of the FUT. For the  FUT  we ensure
%% that the precondition is assumed by inserting 
%% \lstinline|fassume(f_precond(x1, ..., xn));| 
%% at label $Beg_{f}$
%% (cf line 11 in Listing~\ref{lst:abbrv}).

Deuxièmement, toute annotation \eacsl de la forme \lstinline'kwd w' (où
\lstinline'kwd' $\in$ $\bopen$ \lstinline|assert|, \lstinline|requires|,
\lstinline|typically|, \lstinline|ensures|, \lstinline|loop variant|,
\lstinline|loop invariant|, \lstinline|assigns|, \lstinline|loop assigns|
$\bclose$ et \lstinline'w' est un terme ou un prédicat) est traduite.
D'autres constructions \eacsl ne sont pas détaillées ici car elles peuvent être
obtenues à partir du fragment \eacsl décrit.
Par exemple, les behaviors peuvent être réécrits comme des implications dans les
clauses \lstinline'ensures' et les contrats d'instruction peuvent être réécrits
comme des implications dans des assertions.
%% global (resp., loop or statement)
%% \lstinline|assigns| clauses can be rewritten as postconditions
%% (resp., loop invariants or assertions)
%% checking the non-modification of some variables.

Chaque paire, $(label, annotation)$ est traduite en une séquence
d'\emph{insertions de code}
$(l_1, c_1) \concat (l_2, c_2) \concat \ldots \concat (l_n, c_n)$, qui 
represente une liste de fragments de programmes C $c_1, c_2, \ldots, c_n$ où
le fragment $c_i$ sera inséré dans le programme instrumenté au label $l_i$.
Les annotations \eacsl sont traduites séparément et les séquences de fragments
résultant de la traduction sont traitées en suivant l'ordre des annotations dans
le programme.
Quand plusieurs fragments doivent être insérés au même endroit $l$, ils sont
insérés en respectant leur ordre dans la séquence (l'ordre dans lequel ils ont
été générés).

La traduction d'annotations est définie par les règles de la
section~\ref{sec:annot}.
Cela requiert de traduire les termes et les prédicats \eacsl.
Ces transformations sont décrites par les règles des sections~\ref{sec:term}
et~\ref{sec:pred}.
Dans ces règles, les notations suivantes sont utilisées :
\begin{itemize}
\item $p$, $p_1$, $p_2$ et $p_3$ sont des prédicats \eacsl;
\item $t$, $t_1$, $t_2$ et $t_3$ sont des termes \eacsl et $w$ est un prédicat
  ou un terme;
\item $c$, $c_1$, $c_2$ et $c_3$ sont des fragments de programmes C;
\item $e$, $e_1$, $e_2$ et $e_3$ sont des expressions C;
\item $l$, $l_1$, $l_2$, $l_3$, $Beg_f$, $End_f$, $BegIter_l$ et $EndIter_l$ sont
  des labels du programme;
\item $i$ est un identificateur de variable liée dans un prédicat \eacsl et un
  compteur d'itérations dans un programme C, $x$ est un identificateur de
  variable C;
\item $I$, $I_1$, $I_2$ et $I_3$ sont des listes d'insertions de code
  $(l_i, c_i)$.
\end{itemize}

Les variables \lstinline'res', \lstinline'var_n', \lstinline'i_n',
\lstinline|old_x|, \lstinline'old_val_x' et \lstinline|old_variant| sont
``fraîches'' (fresh), c'est-à-dire que ces identificateurs sont supposés
différents de tous les autres identifiants de variables du programme instrumenté
: quand on utilise plusieurs fois une règle introduisant une variable fraîche,
toutes les occurrences de la variable créée doivent être différentes.
Ceci peut être implémenté en incrémentant le compteur $n$ à chaque occurrence
dans \lstinline'var_n' et \lstinline'i_n', et en utilisant le nom de la variable
d'origine à la place de $x$ dans \lstinline'old_x' et \lstinline'old_val_x'.

Pour des raisons de commodité, nous supposons que toutes les variables logiques
liées dans les annotations et toutes les variables du programme sont
différentes, ceci nous permet en particulier de traduire les variables logiques
en C sans les renommer.


\subsubsection*{Exemple}
\label{sec:translation-example}


\lstinputlisting[style=c,escapechar=§,caption={Annotated C function deciding if
    \lstinline{v} is present in array \lstinline{t} of size \lstinline{n}},
  label=lst:normalized]{listings/is_present_normalized.c}

Nous présentons dans le listing~\ref{lst:normalized} un exemple de fonction sous
test normalisée en suivant la grammaire de la figure~\ref{fig:grammar}.
Elle retourne $1$ quand la valeur $v$ en paramètre est présente dans le tabbleau
$t$ en paramètre, ou $0$ sinon.
Le programme instrumenté obtenu après traduction des annotations de cette
fonction est présenté (utilisant la notation abrégée pour les entiers non
bornés) dans le listing~\ref{lst:abbrv}.
La fonction précondition générée est définie lignes 1--6
(listing~\ref{lst:abbrv}), elle retourne une valeur non nulle quand la
précondition est vraie.
La clause \lstinline'requires' de la ligne 1 (listing~\ref{lst:normalized})
indique que la taille du tableau \lstinline|n| est positive, elle est traduite
en conditionnelle ligne 3 du listing~\ref{lst:abbrv}.
La clause \lstinline'requires' de la ligne 2 (listing~\ref{lst:normalized}) 
indique que \lstinline|(t+0)|$, ..., $\lstinline|(t+(n-1))| sont des pointeurs
valides, elle est traduite en conditionnelle ligne 4 du
listing~\ref{lst:abbrv}).
La clause \lstinline'typically' de la ligne 3 du listing~\ref{lst:normalized}
(traduite ligne 5 du listing~\ref{lst:abbrv}), est une extension de la syntaxe
d'\eacsl définissant une précondition pour le test.
Elle renforce la précondition pour limiter l'explosion combinatoire du nombre de
chemins à explorer par la génération de tests, elle permet d'obtenir une
couverture partielle des chemins : seuls les chemins satisfaisant cette clause
sont considérés.
Ici elle limite l'espace des états de \lstinline'n' (et donc la taille de
\lstinline't') à $[0, 6]$ (cela peut être vu comme une ``finitization''
\cite{Korat}).
L'invariant de boucle de la ligne 9 du listing~\ref{lst:normalized} est traduit
aux lignes 13--14 du listing~\ref{lst:abbrv} pour vérifier que l'invariant est
vrai avant la première itération (établissement), et aux lignes 21--22 du
listing~\ref{lst:abbrv} pour vérifier la préservation de l'invariant après
chaque itération.
(Un invariant de boucle supplémentaire 
\lstinline|\forall integer k; 0<=k<i ==> \old(*(t+k))!=v;|
nécessaire pour prouver formellement la postcondition n'est pas inclus dans cet
exemple simplifié).
Le variant de boucle ligne 10 du listing~\ref{lst:normalized} est traduit à la
ligne 15 du listing~\ref{lst:abbrv} pour vérifier que le variant est positif ou
nul avant chaque itération de la boucle, à la ligne 18 du
listing~\ref{lst:abbrv} pour mémoriser la valeur du variant au début de la
boucle, et aux lignes 23--25 du listing~\ref{lst:abbrv} pour vérifier que le
variant décroisse strictement après chaque itération, assurant ainsi la
terminaison de la boucle.
La postcondition des lignes 4-5 du listing~\ref{lst:normalized} est traduite aux
lignes 28--32 du listing~\ref{lst:abbrv}, définit que \lstinline|\result| est
non nul si et seulement si il existe un élément de \lstinline|t| égal à
\lstinline|v|.
Les valeurs des paramètres formels \lstinline|t|, \lstinline|n| et \lstinline|v|
sont mémorisées lignes 10--11 du listing~\ref{lst:abbrv}, un nouveau tableau
\lstinline|old_val_t| stocke les anciennes valeurs contenues dans \lstinline|t|,
il est alloué ligne 10, rempli ligne 11 et désalloué ligne 33.


\section{Traduction des termes \eacsl}
\label{sec:term}


\input{figures/fig_rules}

Soit
$(l, t:T) \rulearrow ((l_1, c_1) \concat (l_2, c_2) \concat \ldots \concat (l_n, c_n), e)$
une instance de la fonction partielle $\tau$ qui à un terme \eacsl $t$ de type
$T$ au label $l$ associe la paire $(I, e)$ où $I$ est une liste d'insertions de
code $(l_i, c_i)$, $e$ est une expression C, et $T$ peut être $\mathbb{Z}$
(\lstinline'integer') or $ctype$.
Nous considérons comme étant inclus dans $ctype$ les types suivants : $ptr$,
type pointeur pointant vers n'importe quel type du C, et le type C
\lstinline'int'.
Les autres types C tels \lstinline'char', \lstinline'long',
\lstinline'unsigned', etc. peuvent être supportés de manière similaire, mais ne
sont pas abordés pour des raisons de simplicité et lisibilité.
L'expression $e$ est pure (elle ne provoque pas d'effet de bord) et correspond
à l'évaluation du term $t$ au point de programme donné $l$.
L'évaluation de $e$ requiert le plus souvent plusieurs opérations, qui sont
effectuées par les fragments de programme qui résultent de la traduction du
terme et seront insérés aux endroits adéquats dans le programme instrumenté.
Par exemple, un terme quantifié (comme une somme : \lstinline'sum') a besoin de
plusieurs instructions pour être évalué, et notamment d'une boucle (voir la
figure~\ref{fig:builtin}).
Dans ce cas, le second élément de la paire retournée, $e$ est la valeur de la
variable calculée par le boucle.
Quand un terme $t$ peut être traduit directement sans nécessiter de code C
supplémentaire, la séquence d'insertions de code est vide et notée $\emptyset$.
Pour un terme $t:\mathbb{Z}$, le resultat de traduction $e$ est toujours une
variable de type \lstinline'Z_t' (ce qui justifie une désallocation
\lstinline{e}${}^{\boxtimes}$, voir figure~\ref{fig:coerce}).

La figure~\ref{fig:const-id} présente les règles de traduction pour les
identificateurs de variable (\textsc{$\tau$-var}), pour le terme
\lstinline|\result| (\textsc{$\tau$-res}) et pour les constantes
(\textsc{$\tau$-const}).
Deux règles sont nécessaires pour traduire la construction \eacsl
\lstinline|\old|.
Appliquée à un identificateur $x$ (règle \textsc{$\tau$-old}), le terme est
traduit en variable fraîche \lstinline|old_x| qui contient la valeur de $x$ au
début de la fonction.
Appliquée à un accès mémoire (règle \textsc{$\tau$-old-val}), on utilise le
tableau alloué dynamiquement \lstinline|old_val_x| qui contient les valeurs du
tableau ou pointeur \lstinline'x' au début de la fonction (se référer à la
section~\ref{sec:principles}).
Le terme \lstinline|\result| est traduit par la règle \textsc{$\tau$-res}, il
fait référence à la valeur de retour de la fonction en \eacsl qui est écrite
dans la variable \lstinline|res|.
Cette variable est unique dans chaque fonction après normalisation de l'arbre de
syntaxe abstrait (AST) par \framac.
La règle \textsc{$\tau$-const} établit qu'une variable entière est définie pour
prendre la valeur d'une contante entière.

La figure~\ref{fig:coerce} détaille les règles de conversions implicites, de
\lstinline'integer' vers type C et de type C vers \lstinline'integer'.

La figure~\ref{fig:op} détaille les règles pour les opérations unaires
(\textsc{$\tau$-unop$_*$}), les opérations binaires (\textsc{$\tau$-binop$_*$}) 
et la condition ternaire sur les termes (\textsc{$\tau$-if}).
\textsc{$\tau$-unop$_1$} traite le cas de l'indirection de pointeur ($\star$).
\textsc{$\tau$-unop$_2$} traite le cas de la négation logique (\lstinline|!|) et
n'opère que sur un \lstinline'int', si c'est un \lstinline'integer' il est
converti en utilisant la règle \textsc{$\tau$-coerce$_1$}.
\textsc{$\tau$-unop$_3$} traite le cas du \lstinline|-| unaire et du complément
bit-à-bit ($\sim$) et on suppose que ces opérations prennent un
\lstinline'integer' en entrée et en sortie.

\textsc{$\tau$-binop$_1$} traite l'arithmétique de pointeur, l'opérande gauche
est un pointeur, $op$ doit être \lstinline|+| ou \lstinline|-|, et l'opérande
droite est de type \lstinline'int'.
\textsc{$\tau$-binop$_2$} traite la comparaison, $op$ est un opérateur de
comparaison sur les entiers et le résultat de la comparaison est stocké dans un
\lstinline|int|.
\textsc{$\tau$-binop$_3$} traite les opérations arithmétiques entières (les
opérandes et le résultat sont des entiers), $op$ est des opérateurs
arithmétiques suivants : \lstinline|+|, \lstinline|-|, \lstinline|/|,
\lstinline|%|, \lstinline|<<|, \lstinline|>>|, \lstinline{|}, \lstinline|&|,
\lstinline|^|.
Dans la règle \textsc{$\tau$-if}, les évaluations de $t_2$ et $t_3$ sont dans
des branches conditionnelles : on calcule uniquement l'un des deux, en fonction
de l'évaluation de $t_1$.

La figure~\ref{fig:builtin} présente les règles de traduction pour les fonctions
logiques \lstinline|\sum| (\textsc{$\tau$-sum}) et \lstinline|\numof|
(\textsc{$\tau$-numof}).
La règle pour la fonction \lstinline|\product| est similaire à la règle
\textsc{$\tau$-sum}.
La règle \textsc{$\tau$-sum} permet de calculer une somme d'entiers non bornés,
elle initialise une variable entière fraîche \lstinline|var_n| à $0$ et
l'incrémente avec la valeur du \lstinline|\lambda|-terme \lstinline't3' à chaque
itération.
La règle \textsc{$\tau$-numof} initialise aussi une variable entière fraîche
\lstinline|var_n| à $0$, mais incrémente sa valeur uniquement quand le
\lstinline|\lambda|-terme \lstinline't3' (non entier) s'évalue en une expression
non nulle.


\section{Traduction des prédicats \eacsl}
\label{sec:pred}


De manière similaire à la fonction de traduction $\tau$ pour les termes
(section~\ref{sec:term}), la fonction de traduction des prédicats, notée $\pi$,
est définie comme une fonction partielle qui, à un label et un prédicat \eacsl,
associe une séquence d'insertions de code $(l_i, c_i)$ et une expression C
$e \in \{0, 1\}$.
Quand un prédicat $p$ peut être traduit directement et ne nécessite pas la
création d'instructions C, la séquence d'insertions est vide et notée
$\emptyset$.

Nous définissons dans la figure~\ref{fig:pred-logic}, la figure~\ref{fig:valid}
et la figure~\ref{fig:quantif} les règles de traduction pour les principaux
prédicats \eacsl que nous supportons.

La figure~\ref{fig:pred-logic} détaille les règles de traduction pour les
prédicats les plus simples du langage \eacsl.
Les règles \textsc{$\pi$-true} et \textsc{$\pi$-false} indiquent que
\lstinline'\true' (respectivement \lstinline'\false') se traduit en $1$
(respectivement $0$).
Les règles \textsc{$\pi$-equiv} et \textsc{$\pi$-not} sont compositionnelles :
les prédicats fils sont traduits récursivement, puis le résultat de la
traduction est construit à partir des valeurs des prédicats fils.
Les règles \textsc{$\pi$-and}, \textsc{$\pi$-or} et \textsc{$\pi$-impl}
reflètent l'évaluation paresseuse de ces opérateurs selon la sémantique d'\eacsl
: le premier opérande est toujours évalué (en $I_1$) mais le deuxième n'est
évalué (en $I_2$) que si nécessaire.
La règle \textsc{$\pi$-if} est similaire à \textsc{$\tau$-if} (voir
section~\ref{sec:term}).
Dans l'exemple du listing~\ref{lst:normalized}, la traduction de la
postcondition
\lstinline{\result != 0 <==> \exists integer i; 0<=i<n && *(t+i)==v} requiert
la traduction des prédicats \lstinline|\result != 0| et
\lstinline{\exists(...)} qui sont respectivement traduits en \lstinline|var_32|
et \lstinline|var_35|.
Ces deux prédicats sont assemblés pour construire la traduction du prédicat
composé, d'après la règle \textsc{$\pi$-equiv},:
\lstinline{(!var_32 || var_35) && (!var_35 || var_32)} (line 32 du
listing~\ref{lst:abbrv}).
Dans la règle \textsc{$\pi$-rel}, \lstinline|op| est un des opérateurs suivants
: \lstinline[style=c]{<, <=, >, >=, ==, !=}.

La figure~\ref{fig:valid} montre les règles de traduction pour le prédicat
\lstinline|\valid|, qui est vrai si le pointeur en argument pointe vers une
case mémoire valide et peut être déréférencé.
\lstinline'\valid(t)' exprime la validité d'un seul pointeur et
\lstinline'\valid(t1+(t2..t3))' exprime la validité du pointeur \lstinline't1'
dans l'intervalle d'offsets \lstinline't2..t3', ce qui veut dire que
\lstinline't1+t2', \dots, \lstinline't1+t3' sont valides.
Les règles \textsc{$\pi$-valid} et \textsc{$\pi$-valid-range} couvrent les deux
cas.
On suppose que l'évaluation de la validité d'un pointeur est possible au moyen
d'une fonction \lstinline'fvalid' et que l'évaluation d'un pointeur sur un
intervalle d'offsets est peut se faire au moyen d'une fonction
\lstinline'validr'.
Le support de ces prédicats nécessite une représentation précise de la mémoire
du programme, la réalisation de telles fonctions est abordée dans le
chapitre~\ref{sec:runtime}.
Dans notre exemple du listing~\ref{lst:normalized}, le prédicat
\lstinline|\valid(t+(0..n-1))| de la clause \lstinline|requires| de la ligne 2
est traduit en \lstinline[style=c]|fvalidr(t,0,(n-1))| (ligne 4 du
listing~\ref{lst:abbrv}).

La règle \textsc{$\pi$-exists} (figure~\ref{fig:quantif}) aborde la traduction
du prédicat existentiel \lstinline'\exists', quantifié sur les entiers.
Le code généré met à jour une variable \lstinline'var_n' (initialement $false$)
à chaque itération de la boucle, jusqu'à ce que toutes les valeurs de
\lstinline'i' soient considérées ou que \lstinline'var_n' soit évalué à $true$.
Cette règle permet aussi de traduire le prédicat universellement quantifié
\lstinline{\forall integer i; t1<=i<t2 ==> p}, ce dernier étant équivalent à
\lstinline{! (\exists integer i; t1<=i<t2 && !p)}.
Dans le listing~\ref{lst:normalized}, le prédicat
\lstinline{\exists integer i; 0<=i<n && *(t+i)==v} de la ligne 4 est traduit
au lignes 29--31 du listing~\ref{lst:abbrv} et la variable fraîche contenant la
valeur du prédicat après évaluation est \lstinline|var_35| (déclarée à la
ligne 29).


\section{Traduction des annotations \eacsl}
\label{sec:annot}


Now we  define the translation rules for annotations that allow to trigger 
annotation failures and 
enforce 
test generation of erroneous inputs. For each annotation, a fragment of a C
program ending by a condition test is inserted into the program. The test
generator will try to cover all feasible paths, thus activating the error if
such inputs exist. The rules are of the following form:

\vspace{-4mm}
\[
\dfrac
    {(l_1, w) \rulearrow (I_1, e_1) \quad \ldots \quad
      (l_n, w) \rulearrow (I_n, e_n)}
    {(l, \mathtt{kwd\ w;}) \rulearrow
      g_{kwd} (l, (I_1, e_1), \ldots, (I_n, e_n))}
\]
\vspace{-4mm}



This rule pattern states that if the term or predicate $w$ at label $l_i$
is translated (by $\tau$ or $\pi$) as
$(I_i, e_i)$, then the property $kwd\ w$ involving $w$ at
program point $l$ will be translated by some composition 
function of code insertions of each
$I_i$ and of the expressions $e_i$. 
The particular composition function, denoted $g_{kwd}$, depends on
the annotation kind.
In Fig.~\ref{fig:annot} and Fig.~\ref{fig:loop-annot} we present the
translation rules for each annotation kind. Suppose \lstinline|fassert| is a C
function checking an expression. We define the condition $e$ that
must be tested for each annotation. The test is expressed by applying the
function \lstinline|fassert|, that is expanded to a conditional \lstinline|if|.
Test generation tries to cover both branches. If the expected property is
false, the failure is reported and the
exploration switches to another branch.

Fig.~\ref{fig:annot} describes the translation rules for an assertion at label $l$
(\textsc{$\alpha$-assert}), a postcondition (\textsc{$\alpha$-post}) and
a precondition (\textsc{$\alpha$-pre})
that are considered to be stated resp. at labels $End_f$ and $Beg_f$. 
The rule \textsc{$\alpha$-assert}
simply checks the translated predicate at label $l$ with the function
\lstinline|fassert|. The rule \textsc{$\alpha$-post} checks the predicate at
the end of the function being translated. The rule \textsc{$\alpha$-pre} checks
the predicate of a precondition in a separate function that we call
\lstinline'f_precond', returning $0$ if one of the \lstinline|requires| or
\lstinline|typically| clauses does not hold, or $1$ otherwise. This function
has to be called with the same formal parameters as the function
being translated.
Since the precondition is \emph{assumed} for the function under test
and must be \emph{ensured} for a called function,
its result has to be {\em asserted} in the case
of a {\em callee}  and {\em assumed} in the case of the function under
test.
So for each function, a check 
\lstinline|fassert(h_precond(x1, x2, ..., xn));| (resp.
\lstinline|fassume(h_precond(x1, x2, ..., xn));|) is inserted at the label
$Beg_h$ if $h$ is a {\em callee} (resp. FUT), where
$x_1, x_2, ..., x_n$ are the formal parameters of $h$, and
the \lstinline|fassume| function restricts 
test generation to input values for which it returns true.
In the example of Listing~\ref{lst:normalized}, the
\lstinline|requires| clause lines 1-2 and the \lstinline|typically| clause line
3 are translated to the lines 3--5 of Listing~\ref{lst:abbrv}. The validity of the
\lstinline'is_present_precond' precondition is {\em assumed} line 11 of
Listing~\ref{lst:abbrv}. Finally, the \lstinline|ensures| clause lines 4-5 is
translated as lines 28--32 in Listing~\ref{lst:abbrv}. 

The translation rules for the loop invariants (\textsc{$\alpha$-invariant}) and
loop variants (\textsc{$\alpha$-variant}) for a loop at label $l$ are presented in
Fig.~\ref{fig:loop-annot}. The rule \textsc{$\alpha$-invariant} checks the
predicate of the loop invariant before the loop, and after
each iteration of the loop (i.e. at the predefined label $EndIter_l$). The rule
\textsc{$\alpha$-variant} checks that the variant term is non-negative at the
beginning of each iteration,
then the previous value of the variant is saved at the begining of the loop
iteration in a fresh variable 
\lstinline|oldvariant|. Finally, it checks at the end of each iteration that
the current value of the variant is strictly
decreasing (compared to its value in the previous iteration).
In the running example of Listing~\ref{lst:normalized}, translating the
\lstinline|loop invariant| line 9 results in lines 13--14 and 21--22 in
Listing~\ref{lst:abbrv}, while translating the \lstinline|loop variant| line 10
results in lines 15, 18 and 23--25 in Listing~\ref{lst:abbrv}.


\section{Différences entre le Test et la Validation d'Assertions à l'Exécution}


Instrumentation based translation of ACSL annotations into C code 
has been implemented in two \framac \cite{\citeframac} plugins:
\eacsltoc \cite{Delahaye/SAC13,Kosmatov/RV13} that generates an instrumented program
for Runtime Assertion Checking (RAC), and \stady, that instruments a program for Test Generation with
\pathcrawler \cite{\citepathcrawler}. 
This section  discusses similarities and differences between both kinds of instrumentation.

Test generation and runtime checking both need to
generate executable code and so consider only an executable subset of the
specification language. 
Therefore, most rules defined in Sec. \ref{sec:term}, \ref{sec:pred} and \ref{sec:annot} 
for test generation are also valid for RAC.

\textbf{Precondition of the function under test (FUT).}
One difference is the treatment of the precondition of the FUT.
In RAC, it is usually checked as any other annotation.
In test generation, it is used to avoid testing the program on inadmissible values 
for which the program is not supposed to work correctly.
Hence, the precondition  of the FUT should be assumed during test generation
to ensure that all generated test inputs respect the precondition of the FUT.

Besides, the treatment of the precondition of the FUT in \pathcrawler has two optimizations.
First, an internal mechanism of unquantified and quantified preconditions
allows a direct translation of ACSL preconditions into constraints
supported in an efficient manner.
Hence, for precondition patterns that can be expressed by this mechanism,
a translation into C code is not necessary for \pathcrawler.
Second, for the remaining preconditions translated into a C function, 
\pathcrawler offers a specific
efficient mechanism \cite{Delahaye/RV13}.
A call to \lstinline|fassume| (adding the constraints of the
precondition to the constraint store \emph{before} the path predicate in the FUT)
can be replaced in \pathcrawler by a dedicated support for
late precondition (where precondition constraints are posted \emph{after}
other path constraints of the FUT).
Thus the call to \lstinline|fassume| for the FUT 
in \pathcrawler is not needed.

\textbf{Memory-related constructs.}
Runtime checkers also require a complex instrumentation framework
to treat memory-related constructs where each memory related operation
is instrumented and relative memory block metadata is stored
so that it can be extracted when it is necessary to evaluate a memory-related
ACSL annotation \cite{Kosmatov/RV13}.
Some of these constructs can be handled symbolically in
concolic testing without additional instrumentation.
The functions \lstinline|fvalid| and \lstinline|fvalidr| are builtin C functions
defined by \pathcrawler that return the value of validity of a pointer
\cite{testing-pointers}.
They actually support global variables and formal parameters of the function
under test.

\textbf{Unbounded integers.}
While translation of ACSL mathematical integers relying on an external library 
for unbounded integers (like GMP) is appropriate and sufficient for
RAC, it will be quite inefficient if the library function code is
directly handled by test generation.
Indeed, test generation on the instrumented code would have to 
treat much more complex code, with lots of additional function 
calls, dynamic memory allocation and de-allocation, etc.
This can be avoided again using symbolic execution of the test generation
tool. \pathcrawler offers dedicated builtin support 
for GMP numbers and operations that are efficiently translated into
appropriate constraints on unbounded integers and handled 
by the underlying constraint solver.

\textbf{Runtime errors.}
Straightforward translation of annotations into C may introduce runtime errors due to annotations
with undefined terms (such as 1/0, cf Sec. \ref{sec:undefined}). 
This issue can be easily solved for test generation exactly as proposed in \cite{Delahaye/SAC13} for RAC,
by an additional guard generation phase
by running  the \rte plugin~\cite{\citeframac} on the instrumented code
to add annotations preventing
runtime errors, and finally running the instrumentation again on these new annotations.
Runtime  errors related to unbounded integer (division of a GMP integer by 0, 
overflow during a type coersion \lstinline[mathescape=true]{(int)(t:$\mathbb{Z}$)}, etc.) 
are not treated by \rte, but they can be easily prevented 
by adding suitable checks in the corresponding rules.
For example, the downcast of a term $t$ from integer to \lstinline'int' (see the rule
\textsc{$\tau$-coerce$_1$} of Fig.~\ref{fig:coerce}) can be guarded by inserting
\lstinline{fassert(}\underline{\lstinline{INT\_MIN <= e}}\lstinline{&&}\underline{\lstinline{e <= INT\_MAX}}\lstinline{)}
before the assignment \underline{\lstinline'var_n = e'}.


\textbf{Triggering errors during test generation.}
The function \lstinline|fassert(cond)| is a C macro defined by
\textsc{PathCrawler} that is expanded as a conditional
\lstinline|if(cond)|, testing
if its parameter is true. Covering all feasible paths of the
program will therefore enforce the generation of test inputs activating the
$then$ branch of this condition, and test inputs activating the
$else$ branch. So if there exist inputs such that \lstinline'cond' is evaluated to
$false$, a test case activating the \lstinline|fassert| thus
violating the corresponding annotation is generated. In other terms, a
counter-example for that annotation is generated if such inputs exist.
