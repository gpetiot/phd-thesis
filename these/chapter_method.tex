
\chapter{Méthode d'Aide à la Preuve combinant NCD et SWD}
\label{sec:method}

\chapterintro


Dans ce chapitre nous présentons notre méthode de diagnostic des échecs de
preuve utilisant les techniques de détection présentées dans les
chapitres~\ref{sec:ncd} et~\ref{sec:swd}.
La partie~\ref{sec:method-proof-failures} rappelle les différentes causes
possibles d'un échec de preuve.
La partie~\ref{sec:method-presentation} présente la méthode de diagnostic des
échecs de preuve et la partie~\ref{sec:method-suggestions} suggère les actions
à effectuer après qu'un échec de preuve ait été diagnostiqué.


\section{Exemple}
\label{sec:method-ex}


Nous illustrons les problèmes qui se posent lors de la vérification déductive
d'un programme et les solutions que nous proposons sur le programme C donné en
figure~\ref{fig:rgf1}.
Cet exemple provient d'un travail de spécification formelle et de vérification
déductive en cours~\cite{Genestier/TAP15} et implémente un algorithme proposé
dans \cite[page 235]{Arndt/10}.
L'exemple de la figure~\ref{fig:rgf1} concerne la génération de fonctions à
croissance restreinte (ou RGF pour \textit{Restricted Growth Functions}),
définies par la propriété exprimée par le prédicat \acsl \lstinline{is_rgf} aux
lignes 1--4 de la figure~\ref{fig:rgf1}, où la RGF $a$ est représentée par les
valeurs d'un tableau C.
Pour des raisons de lisibilité, certaines notations \acsl sont remplacées par
des symboles mathématiques (par exemple, les mots-clés
\lstinline[style=c]{\exists}, \lstinline[style=c]{\forall} et
\lstinline[style=c]{integer} sont notés respectivement $\exists$, $\forall$ et
$\mathbb{Z}$).


\begin{figure}[tb]
  \centering
  \lstinputlisting[multicols=2]{listings/rgf_0.c}
  \caption{Fonction ``successeur'' d'une RGF \label{fig:rgf1}}
\end{figure}


La figure~\ref{fig:rgf1} présente une fonction principale \lstinline{f} et une
fonction auxiliaire \lstinline{g}.
La précondition de \lstinline{f} affirme que \lstinline{a} est un tableau
valide de taille \lstinline{n>0} (lignes 27--28) et doit être une RGF
(ligne 29).
La postcondition affirme que la fonction \lstinline'f' ne peut modifier que le
contenu du tableau \lstinline{a}, à l'exception du premier élément
\lstinline{a[0]} (ligne 30), et que le tableau \lstinline{a} en sortie de la
fonction est toujours une RGF (ligne 31).
De plus, si la fonction retourne 1, alors la RGF générée \lstinline{a} doit
respecter une propriété supplémentaire (lignes 32--36).
Ici \lstinline{\at(a[j],Pre)} dénote la valeur de \lstinline{a[j]} dans l'état 
\lstinline{Pre} de la fonction, c'est-à-dire avant l'exécution de la fonction.

Observons maintenant le corps de la fonction \lstinline{f} de la
figure~\ref{fig:rgf1}. 
La boucle aux lignes 42--43 parcourt le tableau de droite à gauche afin de
trouver l'élément non-croissant le plus à droite, c'est-à-dire l'indice maximum
\lstinline{i} du tableau tel que \lstinline{a[i] <= a[i-1]}.
Si un tel indice est trouvé, la fonction incrémente \lstinline{a[i]} (ligne 46)
et remplit le reste du tableau avec \lstinline{0} (appel à la fonction
\lstinline{g}, line 47).
Le contrat de boucle (lignes 39--41) spécifie l'intervalle de valeurs de la
variable \lstinline'i', les variables que la boucle peut modifier, ainsi que
le variant de boucle qui permet d'assurer la terminaison de la boucle.
L'expression du variant de boucle doit être positive ou nulle au début de chaque
itération et doit décroître strictement entre deux itérations.

La fonction \lstinline{g} est utilisée pour remplir le tableau avec des zeros
à droite de l'indice \lstinline{i}.
En plus des contraintes de taille et de validité du tableau (lignes 12--13),
sa précondition demande que les éléments de \lstinline{a} jusqu'à l'indice
\lstinline{i} forment une RGF (lignes 14--15).
La fonction ne peut modifier que les éléments de \lstinline{a} à partir de
l'indice \lstinline{i+1} (ligne 16) et produit une RGF (line 17).
Les invariants de boucle précisent intervalle de valeur de la variable de
boucle \lstinline{k} (ligne 20), et énoncent que la propriété \lstinline{is_rgf}
est satisfaite jusqu'à \lstinline{k} (ligne 21).
Cet invariant permet à un outil de vérification déductive de prouver la
postcondition.
L'annotation \lstinline{loop assigns} (ligne 22) énonce que la boucle peut
uniquement modifier les valeurs de \lstinline{k} et des éléments de
\lstinline{a} à partir de l'indice \lstinline{i+1}.
Le terme \lstinline{n-k} est le variant de la boucle (ligne 23).

Le \acsl lemme \lstinline'max_rgf' aux lignes 6--10 affirme que si un tableau
encode une RGF, alors chacun de ses éléments est au plus égal à son indice.
Ce lemme n'est pas prouvé automatiquement par \Wp mais peut néanmoins être
utilisé pour assurer l'absence de débordement d'entier signé à la ligne 46.

Les fonctions de la figure~\ref{fig:rgf1} peuvent être prouvées à l'aide de \Wp.


Supposons maintenant que cet exemple contient une des quatre erreurs suivantes :
\emph{soit} l'ingénieur validation oublie la précondition de la ligne 29,
\emph{soit} il se trompe dans l'affectation \lstinline[style=c]'a[i]=a[i]+2;'
ligne 46, \emph{soit} il écrit une clause
\lstinline[style=c]'loop assigns i,a[1..n-1];' trop imprécise ligne 40,
\emph{soit} il oublie de fournir le lemme des lignes 6--10.
Dans chacun de ces scénarios, la preuve du programme échoue (sur la précondition
de \lstinline{g} lors de son appel ligne 47 et/ou sur l'assertion ligne 45)
pour différentes raisons.


In fact, only in the first two cases the code and specification are not compliant, while
the third failure is due to a too weak subcontract, and the last one comes from a prover incapacity.
To the best of our knowledge, 
none of the existing  techniques allows to automatically
distinguish the three reasons and suggest suitable actions.
This work proposes a complete methodology to provide such assistance.


\section{Échecs de preuve}
\label{sec:method-proof-failures}


\commentGP{rappeler NC}

\commentGP{rappeler SW}

\textbf{Prover incapacity.}
When neither a non-compliance nor a global subcontract weakness
exist, we cannot demonstrate that it is impossible to prove the property.

\begin{definition}[Prover incapacity] 
\label{def:prov-incap}
We say that a proof failure in $P$ is due to a \emph{prover incapacity} 
if for any test datum $V$ for $f$ respecting its precondition,
neither $P^{NC}$ nor $P^{\GSW}$ report any annotation failure on $V$.
In other words, there is no \NCCE and no \GSWCE for $P$.
\end{definition}


\section{Présentation de la méthode}
\label{sec:method-presentation}


\begin{figure*}[bt]\centering
\begin{tikzpicture}
  \node(p) [data] {$P$};
  \node(ncd) [right of=p,test,node distance=1.7cm] {$\NCD(P)$};
  \node(ncce1) [below of=ncd,node distance=1.2cm] {\circled{1} $V$ is \NCCE};
  \path[darrow] (ncd) -- node[left] {(\nc, $V$, $a$)} (ncce1);
  \path[arrow] (p) -- (ncd);
  \node(cwd) [right of=ncd,test,node distance=4cm] {$\CWD(P)$};
  \path[darrow] (ncd.east) -- node[above] {\no{} / \textsf{?}} (cwd);
  %\path[darrow] (ncd.east)+(0,.2) -- node[above] {\no} (cwd);
  %\path[darrow] (ncd.east)+(-.1,-.2) -- node[below] {?} (cwd);

  % CWD did not found any CE
  \node(cov-2) [right of=cwd,test,node distance=4cm]{
    $\NCD(P)=~$\no$\land$\\ $\CWD(P)=~$\no};
  \path[darrow] (cwd.east) -- node[above] {\no{} / \textsf{?}} (cov-2);
  %\path[darrow] (cwd.east)+(0,.2) -- node[above] {\no} (cov-2);
  %\path[darrow] (cwd.east)+(-.1,-.2) -- node[below] {?} (cov-2);
  \node(pw) [below of=cov-2,node distance=1.2cm]{\circled{3} Prover incapacity};
  \path[darrow] (cov-2) -- node[right] {true} (pw);
  \node(qm) [right of=pw,node distance=4cm] {\circled{4} Unknown};
  \path[darrow] (cov-2) -| node[below left] {false} (qm);

  % CWD found a CE
  \node(cwce-ncce) [below of=cwd,node distance=1.2cm]{\circled{2} $V$ is \CWCE};
  \path[darrow] (cwd) -- node[right] {(\cw, $V$, $a$, $S$)} (cwce-ncce);
  \path[darrow] (cwd) -- node[above,sloped,xshift=-3mm] {~~~(\nc, $V$, $a$)} (ncce1);
\end{tikzpicture}
\vspace{-2mm}
\caption{Combined verification methodology in case of a proof failure on $P$}
\vspace{-5mm}
\label{fig:method-short}
\end{figure*}


The proposed method is illustrated by Fig.~\ref{fig:method-short}.
Suppose that the proof of the annotated program $P$ fails for some non-imbricated annotation $a\in\A$.
The first step tries to find a non-compliance using \NCD. 
If such a non-compliance is found, it generates an \NCCE (marked by \circled{1}
in Fig.~\ref{fig:method-short})
and classifies the proof failure as a non-compliance.
If the first step cannot generate a counter-example,
the \SWD step combines $\SSWD$ and $\GSWD$ 
and tries to generate single \SWCE{}s, then global \SWCE{}s, 
until the first counter-example is generated and classified 
(either as an \NCCE \circled{1} or an \SWCE \circled{2}).
If no counter-example has been found, the last step checks the outcomes.
If both \NCD and \SWD have returned \textsf{no}, that is, 
both  $\NCD$  and $\GSWD$ have performed a complete path exploration 
without finding a counter-example,
the proof failure is classified as a prover incapacity \circled{3} (cf. Def. \ref{def:prov-incap}).
Otherwise, it  remains unclassified \circled{4}.
Fig.~\ref{tab:versions-rgf} associates a variant of the illustrating example to
each case.
For each case, we detail the lines we modified in the program of
Fig.~\ref{fig:rgf1} to obtain a new program, the intermediate results of
deductive verification, \NCD and \SWD and the final verdict (including the
generated counter-example if any).


\begin{figure*}[bt]\centering
  \includegraphics[scale=.85]{table_rgf.pdf}
  \caption{Method results for different versions of the illustrating example.}
  \label{tab:versions-rgf}
\end{figure*}


The proof failure category and the counter-example $V$, along with  
the recorded path $\pi_V$,
the reported failing annotation $a$ and set of too weak subcontracts $S$,
can be extremely helpful for the verification engineer.
Suppose we try to prove in \Wp a modified version of the function $f$ of
Fig.~\ref{fig:rgf1}
where the precondition at line 24 is missing.
The proof of the precondition of $g$ on line 10 for the call on line 41
fails without indicating a precise reason.
The \NCD step of \stady  generates an \NCCE (case \circled{1},
\#1 in Fig.~\ref{tab:versions-rgf}) where \lstinline'is_rgf(a,n)'
is clearly false due to \lstinline'a[0]' being non-zero, and indicates the
failing annotation (coming from line 10).  
That helps the verification engineer to understand and fix the issue. 


Let us suppose now that the clause on line 34 has been erroneously
written as follows: \lstinline'loop assigns i, a[1..n-1];'.
The loop on lines 36--37 still preserves its invariant.
The \NCD step does not find any \NCCE, as this modification did not introduce
any non-compliance between the code and its specification.
Thanks to the replacement shown in Fig.~\ref{fig:CW-transf-loops},
$\SSWD$ for the contract of this loop will detect a single
subcontract weakness for the loop contract (case \circled{2},
\#2 in Fig.~\ref{tab:versions-rgf}),
and report a fail to establish the 
precondition of $g$ (on line 10) for the call on line 41.
With the indication of the single subcontract weakness for the loop, 
the verification engineer will try to strengthen the loop contract
and find the issue. 


Suppose now we want to prove the absence of overflow at line 40
of Fig.~\ref{fig:rgf1}, but the lemma on lines 4--5 
(that allows the prover to deduce this property) is missing.
The proof fails  without giving a precise reason since
the prover does not perform the induction needed to deduce the right bounds on
\lstinline'a[i]'.
Neither \NCD nor \CWD can produce a counter-example, and
as the initial program has too many paths, their outcomes are \textsf{?}
(unknown) (case \circled{4}, \#4 in Fig.~\ref{tab:versions-rgf}).
For such situations, \stady offers the possibility to reduce the input domain.
The verification engineer can add the \acsl clause 
\lstinline'typically n<5;' to reduce the array size 
for testing (this clause is ignored by the proof). 
Running \stady now allows the tool to complete the exploration of all
program paths (for \lstinline'n<5') both for \NCD and \CWD without finding a counter-example.
\stady classifies the proof failure for the program with 
the reduced domain as a prover incapacity (case \circled{3},
\#3 in Fig.~\ref{tab:versions-rgf}).
That gives the verification engineer more confidence that the proof failure
has the same reason on the initial program for bigger sizes \lstinline{n}.

The verification engineer prefers to  try interactive proof or adding additional
lemmas or assertions,
and does not waste time looking for a bug or a too week subcontract.


\section{Suggestions d'actions}
\label{sec:method-suggestions}


\begin{figure*}[bt]\centering
  \begin{tabular}{p{.7cm}|>{\centering\arraybackslash}p{5.8cm}|>{\centering\arraybackslash}p{8cm}}
    \textbf{Case} & {\centering\textbf{Verdict}} & \textbf{Suggestions} \\
    \hline
    \circled{1} & Non-compliance w.r.t. the annotation $a$:
    (\nc, $V$, $a$)
    &
    check the violated annotation $a$
    or the code leading to $a$ in the path $\pi_V$,
    or strengthen the precondition of the function under verification
    \\
    \hline
    \circled{2} & Weakness of subcontracts in $S$ w.r.t. the annotation $a$:
    \ (\cw,~$V$,~$a$,~$S$)
    & strengthen one or several subcontracts in $S$ to exclude the subcontract weakness\\
    \hline
    \circled{3} & Prover incapacity
    & add lemmas or assertions to help the theorem prover,
    or use another prover,
    or an interactive  proof assistant \\
    \hline
    \circled{4} & Unknown
    & strengthen the $\mbox{\lstinline'typically'}$ clause or coverage criterion (e.g. $k$-path),
    or increase the timeout limit for testing \\
  \end{tabular}
  \caption{Suggestions of actions for different categories of proof failures}
  \label{fig:suggestions}
\end{figure*}


From the possible outcomes of the method illustrated in
Fig.~\ref{fig:method-short} we are able to suggest to the verification engineer 
the most suitable actions (displayed in Fig.~\ref{fig:suggestions})
to help her with the verification task.
A \emph{non-compliance} of the code w.r.t. annotation $a$  means that 
there is an inconsistency between the precondition, the annotation $a$ and the code 
of the path $\pi_V$  leading to $a$.
Thanks to the counter-example, 
the values of variables at different program points along $\pi_V$ 
can be either traced or explored in a debugger \cite{Muller/FM11}. 
In \framac, the execution on $V$ can be 
conveniently explored using \Value or \pathcrawler.
This helps the verification engineer to understand the issue.
Indeed, if an \NCCE is generated, there is no need to
try automatic proof or look for a too weak subcontract --- it will not help.
The reason of the proof failure is necessarily related 
to a non-compliance between 
the code and annotations
traversed by the path $\pi_V$.

A \emph{weakness} of a set of subcontracts $S$ means that at least one of the contracts of $C$
has to be strengthened. By Definitions \ref{def:GSW} and \ref{def:SSW}, the non-compliance is excluded here, 
that is, the execution of $P^{\NC}$ on  $V$  respects the annotation $a$, thus
the suggested action is to strengthen the subcontract(s).
In the case of single subcontract weakness, $S$ is a singleton so the suggestion
is very precise and helpful to the user.
Again, trying interactive proof or additional assertions or lemmas 
will be useless here since the property can obviously not be proved 
because of the counter-example.
For a \emph{prover incapacity,} the verification engineer
may write lemmas or assertions, add hypotheses that may help the theorem prover to
succeed or try another theorem prover.
She also may want to use a proof assistant like \textsc{Coq}, so that she does
not suffer from the limitations of the theorem provers, but 
this task can be more complex and time-consuming.
Finally, when the verdict is \emph{unknown,} test generation for \NCD and/or \SWD times out, 
so the verification engineer may strengthen the
precondition for testing to reduce the input domain, or extend the timeout to
give \stady more time to conclude.


\section*{Conclusion du chapitre}


Dans ce chapitre nous avons rappelé les différentes causes possibles d'un échec
de preuve.
Nous avons présenté notre méthode de diagnostic des échecs de
preuve utilisant les techniques de détection présentées dans les
chapitres~\ref{sec:ncd} et~\ref{sec:swd}.
Enfin, nous avons suggéré des actions à effectuer dans chaque situation après
qu'un échec de preuve ait été diagnostiqué.
