
\chapter{Traduction en C des Annotations pour le Test}
\label{sec:traduction}

\chapterintro

Ce chapitre présente une transformation d'un programme C annoté avec \eacsl en
un programme C, appelé programme instrumenté, dans lequel les annotations
\eacsl du programme initial ont été traduites en fragments de programme C
ajoutés au programme initial.
Ces fragments mettent en \oe{}uvre les annotations \eacsl afin de générer des
tests satisfaisant ou violant ces annotations.

Le programme instrumenté est analysé dynamiquement par un générateur de tests
structurels qui prend en entrée des programmes C.
L'instrumentation permet de l'utiliser pour détecter des erreurs dans les
programmes C annotés sans que cet outil n'ait à traiter les annotations dans
leur format d'origine.
Il détecte ces erreurs par analyse du code C produit par l'instrumentation.

Dans la partie~\ref{sec:process} nous présentons le langage des programmes
annotés pris en compte et les principes généraux de la traduction.
Ensuite nous détaillons les règles de traduction des annotations \eacsl en code
C.
Les règles de traduction pour les annotations sont décrites dans la
partie~\ref{sec:annot}.
Elles reposent sur les règles de traduction des termes et des prédicats, qui
sont détaillées dans les parties~\ref{sec:term} et~\ref{sec:pred}.
Nous discutons dans la partie~\ref{sec:rac} les différences et les
similitudes entre l'instrumentation pour la génération de tests et
l'instrumentation pour la validation à l'exécution.

Nous donnons également une justification de correction des règles de
traduction.
Nous voulons notamment nous assurer qu'une erreur est trouvée par le
générateur de tests si et seulement s'il y a une inconsistance entre le code
et sa spécification.

Pour atteindre cet objectif, nous prouvons que l'exécution du code inséré par
la traduction d'un terme, d'un prédicat ou d'une annotation a pour effet de
calculer la même valeur que la valeur de ce terme, ce prédicat ou cette
annotation évalués à leur place dans le programme initial.
Pour cela, nous nous basons sur la sémantique dénotationnelle des instructions
définie au chapitre~\ref{sec:lang}.

Les propriétés que nous vérifions sont définies en partie~\ref{sec:properties}.
Les parties~\ref{sec:term-translation}, \ref{sec:predicate-translation} et
\ref{sec:annotation-translation} détaillent la preuve de ces propriétés
respectivement sur les termes, sur les prédicats et sur les annotations.


\section{Processus de transformation de programmes}
\label{sec:process}


Cette partie présente le processus d'instrumentation des fonctions C annotées
avec le langage d'annotations \eacsl pour la génération de tests.



\subsection{Exemple}
\label{sec:translation-example}


\lstinputlisting[style=c,escapechar=§,caption={Function C annotée décidant si
    \lstinline{v} est présent dans le tableau \lstinline{t} de taille
    \lstinline{n}},
  label=lst:normalized]{listings/is_present_normalized.c}

Nous présentons dans le listing~\ref{lst:normalized} un exemple de fonction sous
test normalisée en suivant la grammaire de la figure~\ref{fig:gram-c} du
chapitre~\ref{sec:lang}.
Elle retourne $1$ quand la valeur \lstinline'v' en paramètre est présente dans
le tableau \lstinline't' en paramètre, et $0$ sinon.

La clause \lstinline'requires' de la ligne 1 indique que la taille du tableau
\lstinline'n' est positive.
La clause \lstinline'requires' de la ligne 2 indique que \lstinline'(t+0)',
\ldots, \lstinline'(t+(n-1))' sont des pointeurs valides.
La clause \lstinline'typically' de la ligne 3 est une extension de la syntaxe
d'\eacsl définissant une précondition pour le test.
Elle renforce la précondition pour limiter l'explosion combinatoire du nombre de
chemins à explorer par la génération de tests, elle permet d'obtenir une
couverture partielle des chemins : seuls les chemins satisfaisant cette clause
sont considérés.
Ici elle limite l'espace des états de \lstinline'n' (et donc la taille de
\lstinline't') à $[0, 6]$ (cela peut être vu comme une ``finitization''
\cite{\citekorat}).
L'invariant de boucle de la ligne 9 spécifie des bornes pour \lstinline'i'
sur l'ensemble des itérations de la boucle.
Le variant de boucle ligne 10 assure la terminaison de la boucle.
La postcondition des lignes 4--5 définit que \lstinline'\result' est non nul si
et seulement s'il existe un élément de \lstinline't' égal à \lstinline'v'.
Notons que pour prouver formellement la postcondition, un invariant de boucle
supplémentaire est nécessaire, mais n'est pas inclus dans cet exemple simplifié 
: \lstinline'\forall integer k; 0<=k<=i-1 ==> \old(*(t+k))!=v;'.



\subsection{Principes généraux de la traduction}
\label{sec:principles}


Présentons maintenant les principes de la traduction d'une fonction annotée
respectant la grammaire de la figure~\ref{fig:gram-c} du
chapitre~\ref{sec:lang}.

Le programme instrumenté obtenu après traduction des annotations de la fonction
du listing~\ref{lst:normalized} est présenté dans le listing~\ref{lst:abbrv}.
Les principes de la traduction sont illustrés par des extraits de ce listing,
au fur et à mesure de leur présentation.

Pour simplifier la lecture des insertions de code générées par la traduction,
nous utilisons la notation abrégée ${}^{\square}$\lstinline{var} pour indiquer
que la variable \lstinline{var} doit être déclarée et allouée
au début de la portion de code insérée, et la notation
\lstinline{var}${}^{\boxtimes}$ pour indiquer que la variable \lstinline{var} doit
être désallouée à la fin du code inséré.
Nous soulignons les opérations (affectation, comparaison, \dots) qui utilisent
l'arithmétique non bornée (par opposition à l'arithmétique modulaire), et
doivent être traduites en utilisant une bibliothèque comme GMP afin de conserver
la sémantique de l'arithmétique entière non bornée d'\eacsl et de pouvoir
raisonner sur les débordements d'entiers.
La partie~\ref{sec:integers} illustre la détection de débordements d'entiers par
GMP.


\lstinputlisting[style=c,escapechar=§,caption={Version instrumentée du programme
    du listing~\ref{lst:normalized}},label=lst:abbrv]
                {listings/is_present_instrumented.c}


Durant le processus d'instrumentation, chaque fonction C est considérée
indépendamment des autres.
Les fonctions sont traduites dans l'ordre dans lequel elles apparaissent dans le
programme.
Pour chacune de ces fonctions, les annotations \eacsl sont également considérées
dans l'ordre dans lequel elles apparaissent.

Nous associons un label à chaque annotation -- qui caractérise sa position dans
le programme initial et l'endroit où elle doit être évaluée -- ce qui nous
donne une paire $(label, annotation)$.
Chacune de ces paires est traduite en une séquence
d'\emph{insertions de code} dénotée par :
$(l_1, c_1) \concat (l_2, c_2) \concat \ldots \concat (l_n, c_n)$.
Elle représente une liste de fragments de programmes C $c_1, c_2, \ldots, c_n$
où le fragment $c_i$ sera inséré dans le programme instrumenté au label $l_i$.
Si plusieurs fragments ont le même label (et doivent donc être insérés au
même endroit), ils sont insérés dans le programme instrumenté en respectant leur
ordre dans la séquence (l'ordre dans lequel ils ont été générés).

Les fragments de programmes -- ou insertions de code -- sont les instructions
nécessaires à l'évaluation d'une annotation, d'un prédicat ou d'un terme
\eacsl.
Ces insertions de code générées à partir des annotations sont placées
dans une séquence d'insertions de code globale.

\textbf{Sauvegarde des valeurs  au début de la fonction.}
Indépendamment de la traduction des annotations, un traitement particulier est
effectué pour chaque fonction, nous permettant de faire référence à la valeur
du terme \lstinline'\old(x)' si \lstinline'x' est une variable globale ou un
paramètre formel de la fonction.
En effet, chaque valeur d'entrée \lstinline'x' (un paramètre formel de la
fonction ou une variable globale) de type $T$ est mémorisée par
une instruction \lstinline|T old_x = x;| au début de la fonction
instrumentée, c'est-à-dire au label $Beg_{\mbox{\lstinline'f'}}$.
Pour chaque tableau ou pointeur \lstinline'x', les valeurs pointées sont
mémorisées dans un tableau alloué dynamiquement \lstinline'old_val_x' dont la
taille est inférée à partir du prédicat \lstinline'\valid' dont on suppose la
présence en précondition de la fonction à traduire.
Dans l'exemple du listing~\ref{lst:abbrv}, les valeurs des paramètres formels
\lstinline|t|, \lstinline|n| et \lstinline|v| de la fonction
\lstinline'is_present' sont mémorisées lignes 3--5, un
nouveau tableau \lstinline|old_val_t| stocke les anciennes valeurs contenues
dans \lstinline|t|, il est alloué ligne 3, rempli ligne 5 et désalloué ligne 35.

\textbf{Traduction des annotations.}
Une fois ce pré-traitement effectué, toute annotation \eacsl de la forme
\lstinline'kwd w' (où \lstinline'kwd' $\in$ \bopen \lstinline|assert|,
\lstinline|requires|, \lstinline|typically|, \lstinline|ensures|,
\lstinline|loop variant|, \lstinline|loop invariant|, \lstinline|assigns|,
\lstinline|loop assigns| \bclose et \lstinline'w' est un terme ou un prédicat)
est traduite.
D'autres constructions \eacsl ne sont pas détaillées ici car elles peuvent être
réduites au fragment \eacsl considéré.
Par exemple, un \lstinline'behavior' peut être réécrit comme une implication
dans une clause \lstinline'ensures' et les contrats d'instruction peuvent être
réécrits comme des implications dans des assertions.

\input{figures/fig_code_gen}

\input{figures/fig_code_ins}

Les figures~\ref{fig:code-gen} et~\ref{fig:code-ins} illustrent la traduction
d'un invariant de boucle \lstinline'loop invariant x<y' à un label de boucle
$L$.
La figure~\ref{fig:code-gen} montre quelles insertions de code sont générées
pour chaque composant de l'annotation.
Les insertions nécessaires à l'évaluation du prédicat \lstinline'x < y' au
label $L$ et au label $EndIter_L$ apparaissent en partie gauche de la figure,
les symboles \insertball[fill=gray!40,xshift=-1mm,yshift=1mm]{n} dénotent les
fragments de code et font le lien entre les deux parties de la figure.
La partie droite de la figure montre la séquence d'insertions étiquetées par
des labels obtenue après traduction complète de l'invariant de boucle.
La figure~\ref{fig:code-ins} illustre le principe d'insertion des fragments de
code de la figure~\ref{fig:code-gen}, qui produit le programme après
instrumentation.


Maintenant que le principe général de l'instrumentation a été présenté, revenons
sur l'instrumentation de la fonction du listing~\ref{lst:normalized}.
Chaque annotation du listing~\ref{lst:normalized} est traduite en une séquence
d'insertions de code.
La clause \lstinline'requires' de la ligne 1 (listing~\ref{lst:normalized}) est
traduite à la ligne 6 du listing~\ref{lst:abbrv}.
La clause \lstinline'requires' de la ligne 2 (listing~\ref{lst:normalized}) est
traduite à la ligne 7 du listing~\ref{lst:abbrv}.
La clause \lstinline'typically' de la ligne 3 du listing~\ref{lst:normalized}
est traduite ligne 8 du listing~\ref{lst:abbrv}.
L'invariant de boucle de la ligne 9 du listing~\ref{lst:normalized} est traduit
aux lignes 10--12 du listing~\ref{lst:abbrv} pour vérifier que l'invariant est
vrai avant la première itération (établissement), et aux lignes 20--24 du
listing~\ref{lst:abbrv} pour vérifier la préservation de l'invariant après
chaque itération.
Le variant de boucle ligne 10 du listing~\ref{lst:normalized} est traduit aux
lignes 15--16 du listing~\ref{lst:abbrv} pour vérifier que le variant est
positif ou nul avant chaque itération de la boucle et aux lignes 24--25 du
listing~\ref{lst:abbrv} pour vérifier que le
variant décroît strictement après chaque itération, assurant ainsi la
terminaison de la boucle.
La postcondition des lignes 4--5 du listing~\ref{lst:normalized} est traduite
aux lignes 28--33 du listing~\ref{lst:abbrv}.

La traduction d'annotations est définie par les règles de la
partie~\ref{sec:annot}.
Cela requiert de traduire les termes et les prédicats \eacsl.
Ces transformations sont décrites par les règles des parties~\ref{sec:term}
et~\ref{sec:pred}.
Dans ces règles, les notations suivantes sont utilisées :
\begin{itemize}
\item $c_1$, $c_2$, $c_i$ et $c_n$ sont des fragments de programmes C;
\item $l$, $l_1$, $l_2$, $l_i$, $l_n$, $Beg_f$, $End_f$, $BegIter_l$ et
  $EndIter_l$ sont des labels du programme;
\item $i$ et $k$ sont des identificateurs de variables liées
  dans un prédicat \eacsl et un compteur d'itérations dans un programme C;
\item $x$ est un identificateur de variable C;
\item $I$, $I_1$, $I_2$ et $I_3$ sont des listes d'insertions de code
  $(l_i, c_i)^*$;
\item $x$, $y$ et $z$ sont des left-values;
\item $var_n$ est un identificateur de variable fraîche;
\item $v$ est une valeur;
\item $i$, $i_1$, $i_2$ sont des instructions C;
\item $A$, $B$ sont des blocs d'instructions;
\item $e$, $e_1$, $e_2$ et $e_3$ sont des expressions C;
\item $t$, $t_1$, $t_2$ et $t_3$ sont des termes \eacsl;
\item $p$, $p_1$, $p_2$ et $p_3$ sont des prédicats \eacsl;
\item $cst$ est une constante;
\item $G$ et $X$ sont des listes de termes \eacsl;
\item $unop$ est un opérateur unaire;
\item $binop$ est un opérateur binaire;
\item $rel$ est un opérateur binaire relationnel;
\item $P$ est un programme C annoté et $P'$ est le programme instrumenté
  obtenu après traduction du programme $P$.
\end{itemize}

Les variables \lstinline'res', \lstinline'var_n', \lstinline'i_n',
\lstinline|old_x| et \lstinline'old_val_x' sont
``fraîches'' (fresh), c'est-à-dire que ces identificateurs sont supposés
différents de tous les autres identifiants de variables du programme instrumenté
: quand on utilise plusieurs fois une règle introduisant une variable fraîche,
toutes les occurrences de la variable créée doivent être différentes.
Ceci peut être implémenté en incrémentant le compteur \lstinline'n' à chaque
occurrence dans \lstinline'var_n' et \lstinline'i_n', et en utilisant le nom de
la variable d'origine à la place de \lstinline'x' dans \lstinline'old_x' et
\lstinline'old_val_x'.

Pour des raisons de commodité, nous supposons que toutes les variables logiques
liées dans les annotations et toutes les variables du programme sont
différentes, ceci nous permet en particulier de traduire les variables logiques
en C sans les renommer.


\subsection{Arithmétique non bornée}
\label{sec:integers}


\lstinputlisting[style=c,escapechar=§,caption={Propriétés des entiers : faux
    négatif dû à une traduction naïve},label=lst:Z:1]
                {listings/naive_false_negative.c}

\lstinputlisting[style=c,caption={Propriétés des entiers : faux positif dû à
    une traduction naïve},label=lst:Z:2]
                {listings/naive_false_positive.c}


Les listings~\ref{lst:Z:1} et~\ref{lst:Z:2} montrent deux exemples où
une traduction naïve des annotations contenant des entiers mathématiques mène
à un résultat incorrect.
Soit \lstinline'x' de type \lstinline'int'.
L'assertion ligne 1 du listing~\ref{lst:Z:1} est fausse lorsque
\lstinline'x = INT_MAX'.
La traduction naïve de cette assertion (ligne 3) utilise les entiers machine
avec arithmétique modulaire (supposons une architecture 32 bits), donc
\lstinline'x+1' reste inférieur ou égal à \lstinline'INT_MAX' pour toute valeur
de \lstinline'x', rendant tout échec de l'assertion impossible.
La traduction correcte pour cette annotation (lignes 6--9) conserve la
sémantique de l'arithmétique entière non bornée en utilisant une bibliothèque
externe (nous avons choisi GMP, la bibliothèque GNU Multi-Precision) pour
représenter les valeurs pouvant provoquer un débordement d'entier (ici
\lstinline'INT_MAX+1').
Les variables nécessaires pour la gestion des entiers non bornés sont créées et
initialisées, puis le résultat est calculé et les comparaisons sont faites en
tant qu'entier non borné.
Le second exemple (listing~\ref{lst:Z:2}) définit une assertion \eacsl (ligne 2)
qui est toujours correcte : pour tout entier positif \lstinline'x', son
successeur est aussi positif.
Une traduction naïve de cette annotation (ligne 3) génèrera une erreur à
l'exécution pour \lstinline'x = INT_MAX' : en arithmétique modulaire
\lstinline'x+1' déborde et devient négatif, violant l'assertion ligne 2.
Une traduction correcte utilisant les entiers non bornés (non présentée ici)
conserve le comportement attendu : l'assertion est vraie pour tout entier
positif \lstinline'x'.
Une traduction naïve des annotations dans ces deux exemples résulterait en un
faux négatif dans le premier cas et en un faux positif dans le deuxième cas, ce
qui porterait atteinte à la correction et à la précision de notre méthode.
Les règles de traduction pour les constructions \eacsl que nous présentons
respectent la sémantique des entiers non bornés d'\eacsl et suppose
l'utilisation d'une bibliothèque externe telle GMP, comme illustré dans le
listing~\ref{lst:Z:1}.



\section{Traduction des annotations \eacsl}
\label{sec:annot}


Définissons maintenant les règles de traduction de haut niveau pour les
annotations, qui permettent de mettre en évidence les échecs d'annotation.
Pour chaque annotation, un fragment de programme C se terminant par le test
d'une expression par la fonction \lstinline'fassert' est inséré dans le
programme.
Le générateur de tests essaiera de couvrir tous les chemins d'exécution
faisables, donc s'il existe des entrées permettant de provoquer un échec de
l'expression de \lstinline'fassert', l'erreur sera trouvée.

\input{figures/fig_rules_annot}

La figure~\ref{fig:annot} décrit les règles de traduction pour les assertions
(\textsc{$\alpha$-assert}), les préconditions (\textsc{$\alpha$-check-pre} et
\textsc{$\alpha$-assume-pre}), les clauses \lstinline'assigns'
(\textsc{$\alpha$-check-assigns}) et les postconditions
(\textsc{$\alpha$-check-post}).
La règle \textsc{$\alpha$-assert} vérifie simplement avec la fonction
\lstinline'fassert' la valeur \lstinline'e' de la traduction du prédicat
\lstinline'p' au label $l$.
La règle \textsc{$\alpha$-check-pre} vérifie avec la fonction
\lstinline'fassert' la valeur \lstinline'e' de la traduction du prédicat
\lstinline'p' au début de la fonction instrumentée.
La règle \textsc{$\alpha$-assume-pre} traite la précondition de la fonction sous
test, qui est supposée vraie par définition.
Cette même règle permet de traduire les clauses \lstinline'typically'
(précondition pour le test qui permet de limiter l'explosion combinatoire du
nombre de chemins du programme) et les clauses \lstinline'requires', elle
suppose avec la fonction \lstinline'fassume' que la valeur \lstinline'e' de la
traduction du prédicat \lstinline'p' au début de la fonction soit vrai.
La règle \textsc{$\alpha$-check-assigns} vérifie que les left-values qui ne sont
pas dans une clause \lstinline'assigns' ne sont pas modifiées par la fonction.
L'ensemble des left-values considérées est la différence $G-X$, où $G$ est
l'ensemble des left-values dans le contexte courant et $X$ est l'ensemble des
left-values de la clause \lstinline'assigns'.
Dans cette règle :
\[
\forall (x:ctype) \in G-X :
((Beg_f, ctype~\mbox{\lstinline'var'}_x = x\semicolon)
\concat (End_f, \mbox{\lstinline'fassert(x == var'}_x\mbox{\lstinline');'}) )
\]
dénote la liste de fragments de code contenant ces deux fragments de code pour
chaque left-value $x$ de $G-X$.
Pour chacune de ces left-values, une sauvegarde de leur valeur est faite au
début de la fonction, puis on vérifie que leur valeur n'a pas été modifiée en
fin de fonction.
La règle \textsc{$\alpha$-check-post} vérifie la validité de la postcondition
à la fin de la fonction instrumentée.

\input{figures/fig_rules_loop_annot}

La figure~\ref{fig:loop-annot} présente les règles de traduction pour les
invariants de boucle (\textsc{$\alpha$-check-invariant}), les variants de boucle
(\textsc{$\alpha$-variant}) et les loop assigns
(\textsc{$\alpha$-check-loop-assigns}) pour une boucle au label $l$.
La règle \textsc{$\alpha$-check-loop-assigns} vérifie que les left-values qui ne
sont pas dans la clause \lstinline'loop assigns' ne sont pas modifiées par la
boucle.
Pour chacune de ces left-values, une sauvegarde de leur valeur courante est
faite au début de chaque itération, puis on vérifie que leur valeur n'a pas été
modifiée en fin de boucle.
La règle \textsc{$\alpha$-check-invariant} vérifie le prédicat de l'invariant
avant la boucle et après chaque itération de la boucle.
La règle \textsc{$\alpha$-variant} vérifie que le terme variant est non-négatif
au début de chaque itération.
Enfin, on vérifie à la fin de chaque itération que le variant décroît
strictement (par rapport à sa valeur au début de l'itération).



\section{Traduction des termes \eacsl}
\label{sec:term}


La fonction de traduction des termes, notée $\tau$, est définie comme une
fonction partielle qui, à un label $l$ et un terme \lstinline't' de type $T$,
associe une séquence d'insertions de code $(l_i, c_i)^*$ et une expression
\lstinline'e' du C :

\[
(l, \mbox{\lstinline't'}:T) \rulearrow
(\underbracket{(l_1, c_1) \concat (l_2, c_2) \concat \ldots
  \concat (l_n, c_n)}_{I : \text{ liste d'insertions de code}}, \mbox{\lstinline'e'})
\]

Les instances de cette fonction sont définies par les
figures~\ref{fig:const-id}, \ref{fig:coerce}, \ref{fig:op} et~\ref{fig:builtin},
ces figures présentes les règles permettant de traduire les termes du langage
\eacsl considéré.
$T$ peut être $\mathbb{Z}$ (\lstinline'integer'), un type pointeur quelconque
(\lstinline'int*', \lstinline'char*', etc.) noté $ptr$ ou un type intégral du C
(\lstinline'char', \lstinline'int', \lstinline'long', etc.) noté $ctype$.
Les insertions de code sont les instructions C nécessaires à l'évaluation du
terme.
Elles permettent notamment d'évaluer les sous-termes dont est composé le terme
\lstinline't'.
L'expression \lstinline'e' est pure (elle ne provoque pas d'effet de bord) et
correspond à l'évaluation du terme \lstinline't' au point de programme $l$.
L'évaluation de \lstinline'e' requiert le plus souvent plusieurs opérations,
qui sont effectuées par les fragments de programme qui résultent de la
traduction du terme et seront insérés aux endroits adéquats dans le programme
instrumenté.
Par exemple, un terme quantifié (comme une somme : \lstinline'\sum') a besoin de
plusieurs instructions pour être évalué, et notamment d'une boucle (voir la
figure~\ref{fig:builtin}).
Dans ce cas, le second élément \lstinline'e' de la paire retournée est la
variable calculée par la boucle.
Quand un terme $t$ peut être traduit directement sans nécessiter de code C
supplémentaire, la séquence d'insertions de code est vide et notée $\emptylist$.
Pour un terme $t:\mathbb{Z}$, le résultat de traduction $e$ est toujours une
variable de type \lstinline'Z_t' (ce qui justifie une désallocation
\lstinline{e}${}^{\boxtimes}$, voir figure~\ref{fig:coerce}).

\input{figures/fig_rules_const_id}

La figure~\ref{fig:const-id} présente les règles de traduction pour les
identificateurs de variable (\textsc{$\tau$-var}), pour le terme
\lstinline|\result| (\textsc{$\tau$-res}) et pour les constantes
(\textsc{$\tau$-const}).
Deux règles sont nécessaires pour traduire la construction \eacsl
\lstinline|\old|.
Appliquée à un identificateur $x$ (règle \textsc{$\tau$-old}), le terme est
traduit en variable fraîche \lstinline|old_x| qui contient la valeur de $x$ au
début de la fonction.
Appliquée à un accès mémoire (règle \textsc{$\tau$-old-val}), on utilise le
tableau alloué dynamiquement \lstinline|old_val_x| qui contient les valeurs du
tableau ou pointeur \lstinline'x' au début de la fonction (se référer à la
partie~\ref{sec:principles}).
Le terme \lstinline|\result| est traduit par la règle \textsc{$\tau$-res}, il
fait référence à la valeur de retour de la fonction en \eacsl qui est écrite
dans la variable \lstinline|res|.
Cette variable est unique dans chaque fonction après normalisation de l'arbre de
syntaxe abstrait (AST) par \framac.
La règle \textsc{$\tau$-const} établit qu'une variable entière est définie pour
prendre la valeur d'une contante entière.

\input{figures/fig_rules_coerce}

La figure~\ref{fig:coerce} détaille les règles de conversions implicites, de
\lstinline'integer' vers type C et de type C vers \lstinline'integer'.

\input{figures/fig_rules_op}

La figure~\ref{fig:op} détaille les règles pour les opérations unaires
(\textsc{$\tau$-unop$_{j}$}), les opérations binaires
(\textsc{$\tau$-binop$_{j}$}) et la condition ternaire sur les termes
(\textsc{$\tau$-if}).
\textsc{$\tau$-unop$_1$} traite le cas de l'indirection de pointeur
(\lstinline'*').
\textsc{$\tau$-unop$_2$} traite le cas du moins unaire et du complément
bit-à-bit ($\sim$) et on suppose que ces opérations prennent un
\lstinline'integer' en entrée et en sortie.

\textsc{$\tau$-binop$_1$} traite l'arithmétique de pointeur, l'opérande gauche
est un pointeur, $binop$ doit être \lstinline|+| ou \lstinline|-|, et l'opérande
droite est de type \lstinline'int'.
\textsc{$\tau$-binop$_2$} traite les opérations arithmétiques entières (les
opérandes et le résultat sont des entiers), $binop$ est un des opérateurs
arithmétiques suivants : \lstinline|+|, \lstinline|-|, \lstinline|/|,
\lstinline|%|, \lstinline|*|.
Dans la règle \textsc{$\tau$-if}, les évaluations de $t_2$ et $t_3$ sont dans
des branches conditionnelles : on calcule uniquement l'un des deux, en fonction
de l'évaluation de $t_1$.
La notation
\[
(l,
\mbox{\lstinline'if('}
\underline{\mbox{\lstinline'e1'}\Zclear \mbox{\lstinline' \!= 0'}}
\mbox{\lstinline')'} \bopen
I_2
\concat
(l, \underline{\Zinit \mbox{\lstinline'var_n = e2'} \Zclear}
\semicolon )
\bclose
\mbox{\lstinline'else'} \bopen
I_3
\concat
(l, \underline{\Zinit \mbox{\lstinline'var_n = e3'} \Zclear}
\semicolon )
\bclose )
\]
signifie que les blocs du \lstinline'if' et du \lstinline'else' contiendront,
après l'étape d'insertion (voir partie~\ref{sec:principles}), les instructions à
insérer au label $l$ obtenues à partir des fragments de code de $I_2$ et $I_3$
respectivement.
Dans la suite cette notation sera utilisée pour chaque conditionnelle
\lstinline'if' et chaque boucle \lstinline'while' générée par les règles de
traduction.

\input{figures/fig_rules_builtin}

La figure~\ref{fig:builtin} présente les règles de traduction pour les fonctions
logiques \lstinline|\sum| (\textsc{$\tau$-sum}) et \lstinline|\numof|
(\textsc{$\tau$-numof}).
\lstinline'\sum(t1, t2, \lambda integer k; t3)' calcule la somme généralisée
$\sum_{\mbox{\lstinline'k = t1'}}^{\mbox{\lstinline't2'}}\mbox{\lstinline't3'}$.
La règle \textsc{$\tau$-sum} permet de calculer cette somme.
Elle initialise une variable entière fraîche \lstinline|var_n| à $0$ et
l'incrémente avec la valeur du \lstinline|\lambda|-terme \lstinline't3' à chaque
itération.
\lstinline'\product(t1, t2, \lambda integer k; t3)' calcule le produit
généralisé $\Pi_{\mbox{\lstinline'k = t1'}}^{\mbox{\lstinline't2'}}\mbox{\lstinline't3'}$.
La règle permettant de calculer ce produit n'est pas donnée mais est similaire à
la règle \textsc{$\tau$-sum} et peut être facilement dérivée à partir de
celle-ci.
\lstinline'\numof(t1, t2, \lambda integer k; t3)' calcule le nombre de
\lstinline'k' tel que
$\mbox{\lstinline't1'} \le \mbox{\lstinline'k'} \le \mbox{\lstinline't2'}$ et
$\mbox{\lstinline't3'} \neq 0$.
La règle \textsc{$\tau$-numof} permet de traduire ce terme.
Elle initialise une variable entière fraîche \lstinline|var_n| à $0$ et
incrémente sa valeur quand le \lstinline|\lambda|-terme \lstinline't3' (non
entier) s'évalue en une expression non nulle.


\section{Traduction des prédicats \eacsl}
\label{sec:pred}


De manière similaire à la fonction de traduction $\tau$ pour les termes
(partie~\ref{sec:term}), la fonction de traduction des prédicats, notée $\pi$,
est définie comme une fonction partielle qui, à un label et un prédicat \eacsl
\lstinline'p', associe une séquence d'insertions de code $(l_i, c_i)^*$ et une
expression $\mbox{\lstinline'e'} \in \{0, 1\}$  du C (que nous encoderons dans
un \lstinline'int') :

\[
(l, \mbox{\lstinline'p'}) \rulearrow
(\underbracket{(l_1, c_1) \concat (l_2, c_2) \concat \ldots
  \concat (l_n, c_n)}_{I : \text{ liste d'insertions de code}}, \mbox{\lstinline'e'})
\]

Les insertions de code sont les instructions C nécessaires à l'évaluation du
prédicat, elles permettent notamment d'évaluer les termes et prédicats
auxiliaires dont est composé le prédicat \lstinline'p'.
Quand un prédicat \lstinline'p' peut être traduit directement et ne nécessite
pas la création d'instructions C, la séquence d'insertions est vide et notée
$\emptylist$.

Nous définissons dans les figures~\ref{fig:pred-logic}, \ref{fig:valid}
et~\ref{fig:quantif} les règles de traduction pour les principaux
prédicats \eacsl que nous traitons.
Pour chacune de ces règles, une variable fraîche \lstinline'var_n' est générée
(même quand la traduction du prédicat est triviale) afin de faciliter la preuve
de correction des règles au prochain chapitre.

\input{figures/fig_rules_pred}

La figure~\ref{fig:pred-logic} détaille les règles de traduction pour les
prédicats les plus simples du langage \eacsl.
Les règles \textsc{$\pi$-true} et \textsc{$\pi$-false} indiquent que
\lstinline'\true' (respectivement \lstinline'\false') se traduit en $1$
(respectivement $0$).
Les règles \textsc{$\pi$-equiv} et \textsc{$\pi$-not} sont compositionnelles :
les prédicats fils sont traduits récursivement, puis le résultat de la
traduction est construit à partir des valeurs des prédicats fils.
Les règles \textsc{$\pi$-and}, \textsc{$\pi$-or} et \textsc{$\pi$-impl}
reflètent l'évaluation paresseuse de ces opérateurs selon la sémantique d'\eacsl
: le premier opérande est toujours évalué (en $I_1$) mais le deuxième n'est
évalué (en $I_2$) que si nécessaire.
La règle \textsc{$\pi$-if} est similaire à \textsc{$\tau$-if} (voir
partie~\ref{sec:term}).
Dans l'exemple du listing~\ref{lst:normalized}, la traduction de la
postcondition
\lstinline{\result != 0 <==> \exists integer i; 0<=i<n && *(t+i)==v} requiert
la traduction des prédicats \lstinline|\result != 0| et
\lstinline{\exists(...)} qui sont respectivement traduits en \lstinline|var_32|
et \lstinline|var_35|.
Ces deux prédicats sont assemblés pour construire la traduction du prédicat
composé, d'après la règle \textsc{$\pi$-equiv},:
\lstinline{(!var_32 || var_35) && (!var_35 || var_32)} (line 33 du
listing~\ref{lst:abbrv}).
Dans la règle \textsc{$\pi$-rel}, $rel$ est un des opérateurs relationnels
suivants : \lstinline[style=c]{<, <=, >, >=, ==, !=}.

\input{figures/fig_rules_valid}

La figure~\ref{fig:valid} montre les règles de traduction pour le prédicat
\lstinline|\valid|, qui est vrai si le pointeur en argument pointe vers une
case mémoire valide et peut être déréférencé.
\lstinline'\valid(t)' exprime la validité d'un seul pointeur et
\lstinline'\valid(t1+(t2..t3))' exprime la validité du pointeur \lstinline't1'
dans l'intervalle d'offsets \lstinline't2..t3', ce qui veut dire que
\lstinline'(t1+t2)', \lstinline'(t1+t2+1)' \dots, \lstinline'(t1+t3)' sont
valides.
Les règles \textsc{$\pi$-valid} et \textsc{$\pi$-valid-range} couvrent les deux
cas.
Le support de ces prédicats nécessite une représentation précise de la mémoire
du programme, la réalisation de telles fonctions est abordée dans le
chapitre~\ref{sec:runtime}.
Dans notre exemple du listing~\ref{lst:normalized}, le prédicat
\lstinline|\valid(t+(0..n-1))| de la clause \lstinline|requires| de la ligne 2
est traduit en \lstinline[style=c]|fvalidr(t,0,(n-1))| (ligne 7 du
listing~\ref{lst:abbrv}).

\input{figures/fig_rules_quantif}

Dans la figure~\ref{fig:quantif}, la règle \textsc{$\pi$-forall} traite de la
traduction du prédicat universel \lstinline'\forall', quantifié sur les entiers.
Le code généré met à jour une variable \lstinline'var_n' (initialisée à $true$)
à chaque itération de boucle, jusqu'à ce que toutes les valeurs de \lstinline'k'
soient considérés ou que \lstinline'var_n' soit évalué à $false$.
La règle \textsc{$\pi$-exists} (figure~\ref{fig:quantif}) aborde la traduction
du prédicat existentiel \lstinline'\exists', quantifié sur les entiers.
Le code généré met à jour une variable \lstinline'var_n' (initialement $false$)
à chaque itération de la boucle, jusqu'à ce que toutes les valeurs de
\lstinline'k' soient considérées ou que \lstinline'var_n' soit évalué à $true$.
Dans le listing~\ref{lst:normalized}, le prédicat
\lstinline{\exists integer i; 0<=i<n && *(t+i)==v} de la ligne 4 est traduit
aux lignes 28--32 du listing~\ref{lst:abbrv} et la variable fraîche contenant la
valeur du prédicat après évaluation est \lstinline|var_35| (déclarée à la
ligne 31).





\section[Test vs. Validation à l'Exécution]{Similarités et Différences selon
  l'objectif Test vs. Validation à l'Exécution}
\label{sec:rac}


La traduction d'annotations \eacsl en code C a été implémentée dans deux
greffons \framac : \eacsltoc \cite{Delahaye/SAC13,Kosmatov/RV13} et \stady
\cite{Petiot/TAP14,Petiot/SCAM14}.
Le premier génère un programme instrumenté pour la validation d'assertions à
l'exécution, le second génère un programme instrumenté pour la génération de
tests avec \pathcrawler \cite{\citepathcrawler}.
Cette partie discute les similarités et les différences entre ces deux façons
d'instrumenter.

La traduction et la traduction pour la validation à l'exécution et pour la
génération de test ont toutes deux besoin de générer du code exécutable, c'est
pourquoi un sous-ensemble exécutable du langage de spécification est considéré
dans les deux cas.
La plupart des règles définies dans les parties~\ref{sec:term},
\ref{sec:pred} et \ref{sec:annot} sont autant valables pour la validation à
l'exécution que pour le test, le code généré devant être correct vis-à-vis de la
sémantique des annotations.
Cependant, il y a plusieurs différences liées à la différence d'objectif.
Les quatre différences sont :
\begin{itemize}
\item la manière de considérer la précondition de la fonction sous test;
\item la manière de traiter les annotations liées au modèle mémoire;
\item la manière de traiter les fonctions sur les entiers mathématiques;
\item et la manière de traiter les potentielles erreurs à l'exécution
  introduites par les fragments de code résultant de la traduction.
\end{itemize}


\textbf{Précondition de la fonction sous test.}
Une première différence est le traitement de la précondition de la fonction sous
test.
En vérification à l'exécution, elle est vérifiée comme n'importe quelle autre
annotation.
En génération de tests, la précondition est utilisée pour éviter de tester le
programme avec des valeurs d'entrées incorrectes, pour lesquelles le bon
fonctionnement du programme n'est pas garanti.
La précondition de la fonction sous test est donc supposée vraie pour la
génération de tests, afin de s'assurer que toutes les entrées générées par le
test satisfont cette précondition.

\textbf{Annotations liées au modèle mémoire.}
La validation à l'exécution nécessite une instrumentation complexe pour traiter
les constructions \eacsl liées au modèle mémoire comme \lstinline'\valid',
\lstinline'\block_length', \lstinline'\base_addr', etc.
Chaque opération affectant la mémoire doit être instrumentée et les informations
de chaque case mémoire doivent être enregistrées afin de pouvoir évaluer ces
annotations \cite{Kosmatov/RV13}.
Nous aborderons les spécificités d'une telle instrumentation dans le
chapitre~\ref{sec:runtime}.
Certaines de ces constructions peuvent être traitées symboliquement en test
concolique sans nécessiter d'instrumentation spécifique dans le code C.
C'est ce que nous faisons ici en supposant la définition de fonctions C
\lstinline'fvalid' et \lstinline'fvalidr' supportées par le générateur de tests,
qui retournent la valeur de validité du pointeur en argument si celui-ci est
une variable globale ou un paramètre formel de la fonction sous test
\cite{Chebaro/ICSSEA12}.

\textbf{Arithmétique non bornée.}
Tandis que l'utilisation d'une bibliothèque externe d'arithmétique non bornée
(comme GMP) pour traduire les entiers d'\eacsl est appropriée pour la validation
à l'exécution, il n'en est pas de même pour la génération de tests :
si le code des fonctions de la bibliothèque est analysé par le
générateur de tests, alors cette solution se révèlera inefficace.
En effet, la génération de tests à partir du programme instrumenté aura à
traiter un code beaucoup plus compliqué, avec de nombreux appels de fonctions, 
des allocations/désallocations dynamiques, etc.
Ceci peut être évité en exécutant symboliquement les fonctions de la
bibliothèque : \pathcrawler offre un support dédié aux fonctions de la
bibliothèque GMP, dont les opérations sont traduites efficacement en contraintes
sur les entiers non bornés, que le solveur de contraintes sous-jacent peut
traiter.

\textbf{Erreurs à l'exécution.}
La traduction d'annotations en C peut introduire des erreurs à l'exécution dues
aux termes dont la sémantique est indéfinie dans les annotations, comme
\lstinline'1/0'.
Ce problème peut être évité pour la génération de tests (comme proposé dans
\cite{Delahaye/SAC13} pour la validation à l'exécution), en utilisant le greffon
\rte \cite{\citeframac} sur le code résultant de l'instrumentation.
Celui-ci ajoute des gardes supplémentaires et il suffit ensuite de
ré-instrumenter le programme en tenant compte de ces nouvelles annotations.
Les erreurs à l'exécution liées aux entiers non bornés (division d'un entier
GMP par $0$, débordement pendant une conversion
\lstinline[mathescape=true]{(int)(t:$\mathbb{Z}$)}, etc.) ne sont pas traités
par \rte mais ces erreurs peuvent être évitées en ajoutant les gardes
nécessaires aux règles de traduction.
Par exemple, le cast d'un terme $t$ d'\lstinline'integer' vers \lstinline'int'
(voir la règle \textsc{$\tau$-coerce$_1$} de la figure~\ref{fig:coerce}) peut
être gardé en ajoutant
\lstinline{fassert(}\underline{\lstinline{INT\_MIN <= e}}\lstinline{ && }
\underline{\lstinline{e <= INT\_MAX}}\lstinline{)} avant l'affectation
\underline{\lstinline'var_n = e'}.




%% \subsection{Définition des séquences d'insertions de code}

%% Une insertion de code est un couple $(LABEL \times INSTR)$.
%% Une liste (ou séquence) d'insertions de code résulte de la traduction d'un
%% terme, d'un prédicat ou d'une annotation \eacsl.
%% Une séquence d'insertions de code est notée :

%% \begin{itemize}
%% \item $\emptylist$ pour une séquence vide;
%% \item $(l, i) \concat I$ pour l'ajout du couple $(l, i)$ au début de la
%%   séquence $I$;
%% \item $I_1 \concat I_2$ pour la concaténation de deux séquences $I_1$ et $I_2$.
%% \end{itemize}

%% Par exemple, la règle suivante montre la séquence d'insertions de code $I$
%% générée pour la traduction du prédicat \lstinline'p1 && p2' :

%% {\myinference[$\pi$-and]
%%   { (l, \mbox{\lstinline'p1'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
%%     (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'}) }
%%   { (l, \mbox{\lstinline'p1 && p2'}) \rulearrow
%%     (
%%     \underbracket{
%%       I_1 \cdot
%%       \underbracket{ (l, \mbox{\lstinline'int e = e1;'}) }_{i_1}
%%       \cdot
%%       \underbracket{ (l, \mbox{\lstinline'if(e)'}
%%         \bopen
%%         I_2 \cdot
%%         \underbracket{ (l, \mbox{\lstinline'e = e2;'}) }_{i_2}
%%         \bclose ) }_{i_3} \concat \emptylist
%%       }_{I},
%%     \mbox{\lstinline'e'}) }
%% }~\\

%% Dans cet exemple, $i_1$, $i_2$ et $i_3$ sont des insertions de code, tandis que
%% $I_1$, $I_2$ et $I$ sont des séquences d'insertions de code.
%% \lstinline'e' est une left-value qui a une valeur dans l'environnement courant.


%% \subsection{Sémantique dénotationnelle des insertions de code}

%% La sémantique dénotationnelle des insertions de code est exprimée avec la
%% fonction $\mathcal{I} : list(LABEL \times INSTR) \mapsto ENV \mapsto ENV$.
%% À chaque séquence d'insertions de code C et à un environnement est associé un
%% nouvel environnement.

%% La fonction $\mathcal{I}$ est définie comme suit :

%% \begin{tabular}{rclr}
%%   \compi{$\emptylist$}{\env} & = & \env & \eqlabel{I-empty} \\
%%   \compi{($l$, $i$) $\concat~\emptylist$}{\env}
%%   & = & \comp{$i$}{\env$_l$} & \eqlabel{I-instr} \\
%%   \compi{$I_1 \concat I_2$}{\env} & = & \compi{$I_2$}{(\compi{$I_1$}{\env})}
%%   & \eqlabel{I-split} \\
%% \end{tabular}

%% La règle \eqlabel{I-empty} énonce qu'une séquence vide ne modifie pas
%% l'environnement.
%% La règle \eqlabel{I-instr} évalue l'instruction $i$ au label $l$ afin de
%% calculer le nouvel environnement.
%% La règle \eqlabel{I-split} traite le cas de la concaténation d'insertions de
%% code.


\section{Propriétés de l'instrumentation}
\label{sec:properties}


Définissons maintenant les propriétés maintenues par le processus
d'instrumentation des programmes annotés.
Ces propriétés sont prouvées dans les parties suivantes.


\begin{theorem}{Préservation des erreurs}\label{th:error}~\\
  L'exécution des instructions obtenues par traduction d'une annotation $a$ du
  programme $P$ provoque une erreur dans le programme instrumenté par la
  traduction de $a$ si et seulement si l'annotation $a$ est invalide.
\end{theorem}

Le théorème~\ref{th:error} assure l'absence de faux positifs et l'absence de
faux négatifs lors de la génération de tests sur le programme instrumenté.

\begin{theorem}{Inclusion des environnements}\label{th:inclusion}~\\
  Si toutes les annotations d'un programme $P$ sont valides, l'environnement de
  $P$ est inclus dans l'environnement du programme après traduction $P'$.
\end{theorem}

\commentGP{reformuler pour avoir une inclusion en chaque point de programme}

Le théorème~\ref{th:inclusion} implique que les seules variables modifiées sont
les variables fraîchement créées par l'instrumentation, les variables de
l'environnement du programme d'origine ne sont pas modifiées par
l'instrumentation.


\section{Preuve de la Traduction des Termes}
\label{sec:term-translation}

Afin de prouver la correction de la traduction des prédicats et des annotations,
nous devons prouver la correction de la traduction des termes.

\begin{lemma}
  \label{lem:term-correct}
  Soit \lstinline't' : $\tau$ un terme de type $\tau$ au label $l$ qui est
  traduit par le couple $(I, \mbox{\lstinline'e'})$ où $I$ est une liste
  d'insertions de code et \lstinline'e' l'expression donnant la valeur du terme
  \lstinline't'.
  La traduction est correcte si le fragment de programme $A$ obtenu à partir de
  $I$ et exécuté à partir d'un environnement quelconque \env$_l$ donne un
  environnement \env{} tel que
  \eval{\lstinline't'}{\env} = \eval{\lstinline'e'}{\env}, où
  \env = \comp{$A$}{\env$_l$}.
\end{lemma}

\begin{corollary}
  \label{lem:term-noerror}
  \env $\neq$ \errorenv
\end{corollary}

\begin{corollary}
  \label{lem:term-subset}
  \env$_l$ \subenv{} \env
\end{corollary}

Le lemme~\ref{lem:term-correct} énonce que l'évaluation des insertions de code
$I$ générées lors de la traduction d'un terme \lstinline't' ajoute une nouvelle
variable \lstinline'e' (fraîche) à l'environnement courant, dont la valeur
correspond à l'évaluation de \lstinline't' dans \env.
Les variables qui sont déjà dans l'environnement initial \env$_l$ ne sont pas
impactées dans l'environnement \env{} (Corollaire~\ref{lem:term-subset}), et
l'environnement résulant de la traduction du terme n'est pas l'environnement
d'erreur \errorenv (Corollaire~\ref{lem:term-noerror}).
Ces propriétés sont vérifiées par la traduction de chaque terme.
Elles nous permettent de prouver les deux théorèmes~\ref{th:error}
et~\ref{th:inclusion}.
%Pour des raisons de lisibilité, la preuve est uniquement fournie pour la règle
%\textsc{$\tau$-const} de traduction des constantes.




%% \subsection{Preuve de la Traduction des Constantes}

%% {\myinference[$\tau$-const]
%%   {}
%%   { (l, \mbox{\lstinline'v'} : \mathbb{Z}) \rulearrow
%%     ((l, \Zinit\underline{\mbox{\lstinline'x = v;'}}), \mbox{\lstinline'x'}) }
%% }

%% Nous prouvons que pour n'importe quel environnement \env  :

%% \eval{\lstinline'x'}{
%%   (\compi{$(l, \Zinit$\underline{\lstinline'x = v;'}$)$}{\env})}
%% = \eval{\lstinline'v'}{\env}

%% et

%% \env \subenv \compi{$(l, \Zinit$\underline{\lstinline'x = v;'}$)$}{\env}

%% et

%% \compi{$(l, \Zinit$\underline{\lstinline'x = v;'}$)$}{\env} $\neq$ \errorenv.

%% \begin{proof}
%%   ~\\
%%   \begin{tabular}{rclr}
%%     \compi{$(l, \Zinit$\underline{\lstinline'x = v;'}$)$}{\env}
%%     &$\eq{\eqlabel{I-instr}}$&
%%     \comp{$\Zinit$\underline{\lstinline'x = v;'}}{\env} \\
%%     &$\eq{\eqlabel{C-Z-set}}$&
%%     \env[\lstinline'x' $\mapsto$ \eval{\lstinline'v'}{\env}] \\
%%   \end{tabular}

%%   En substituant \compi{$(l, \Zinit$\underline{\lstinline'x = v;'}$)$}{\env} on
%%   prouve la première partie du lemme~\ref{lem:term-correct} :
  
%%   \eval{\lstinline'x'}{
%%     (\env[\lstinline'x' $\mapsto$ \eval{\lstinline'v'}{\env}])}
%%   $\eq{\eqlabel{E-lval}}$ \eval{\lstinline'v'}{\env}.

%%   La variable \lstinline'x' étant fraîche dans l'environnement, la deuxième
%%   partie du lemme~\ref{lem:term-correct} est également vérifiée :
%%   \env \subenv \env[\lstinline'x' $\mapsto$ \eval{\lstinline'v'}{\env}].

%%   Le nouvel environnement étant \env auquel on a ajouté une nouvelle liaison
%%   $(x, v)$, ce n'est pas un environnement d'erreur si \env lui-même n'était pas
%%   un environnement d'erreur, ce qui prouve la troisième partie du lemme.
%%   \env ne peut pas être \errorenv puisque la traduction se serait arrêtée dès
%%   l'obtention de l'erreur.
%% \end{proof}


\section{Preuve de la Traduction des Prédicats}
\label{sec:predicate-translation}


Afin de prouver la correction de la traduction des annotations,
nous devons prouver la correction de la traduction des prédicats.

\begin{lemma}
  \label{lem:pred-correct}
  Soit \lstinline'p' un prédicat au label $l$ qui est
  traduit par le couple $(I, \mbox{\lstinline'e'})$ où $I$ est une liste
  d'insertions de code et \lstinline'e' l'expression donnant la valeur du
  prédicat \lstinline'p'.
  La traduction est correcte si le fragment de programme $A$ obtenu à partir de
  $I$ et exécuté à partir d'un environnement quelconque \env$_l$ donne un
  environnement \env{} tel que
  \eval{\lstinline'p'}{\env} = \eval{\lstinline'e'}{\env}, où
  \env = \comp{$A$}{\env$_l$}.
\end{lemma}

\begin{corollary}
  \label{lem:pred-noerror}
  \env $\neq$ \errorenv
\end{corollary}

\begin{corollary}
  \label{lem:pred-subset}
  \env$_l$ \subenv{} \env
\end{corollary}

Le lemme~\ref{lem:pred-correct} énonce que l'évaluation des insertions de code
$I$ générées lors de la traduction d'un prédicat \lstinline'p' ajoute une
nouvelle variable \lstinline'e' (fraîche) à l'environnement courant, dont la
valeur correspond à l'évaluation de \lstinline'p' dans \env.
Les variables qui sont déjà dans l'environnement initial \env$_l$ ne sont pas
impactées dans l'environnement \env{} (Corollaire~\ref{lem:pred-subset}), et
l'environnement résulant de la traduction du prédicat n'est pas l'environnement
d'erreur \errorenv (Corollaire~\ref{lem:pred-noerror}).
Ces propriétés sont vérifiées par la traduction de chaque prédicat.
Elles nous permettent de prouver les deux théorèmes~\ref{th:error}
et~\ref{th:inclusion}.
Pour des raisons de lisibilité, la preuve est uniquement fournie pour les règles
\textsc{$\pi$-and} et \textsc{$\pi$-forall} (en annexe).


\subsection{Preuve de la Traduction des Conjonctions}

La règle de traduction du prédicat de conjonction est \textsc{$\pi$-and},
définie ainsi :

{\myinference[$\pi$-and]
  { (l, \mbox{\lstinline'p1'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
    (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'}) }
  { (l, \mbox{\lstinline'p1 && p2'}) \rulearrow
    (I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
    (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
    (l, \mbox{\lstinline'e = e2;'}) \bclose ),
    \mbox{\lstinline'e'})
  }
}~\\

Prouvons que pour n'importe quel environnement \env :

1.
\eval{\lstinline'p1 && p2'}{\env} =
\eval{\lstinline'e'}{(
  \comp{$A_1\semicolon~ \mbox{\lstinline' int e = e1;'} \cdot
    \mbox{\lstinline'if(e)'} \bopen A_2\semicolon~
    \mbox{\lstinline' e = e2;'}) \bclose$
  }{\env}
  )}
en admettant que le fragment de programme
$A_1\semicolon~ \mbox{\lstinline' int e = e1;'} \cdot
\mbox{\lstinline'if(e)'} \bopen A_2\semicolon~
\mbox{\lstinline' e = e2;'}) \bclose$
est obtenu à partir des listes d'insertions
$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
(l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
(l, \mbox{\lstinline'e = e2;'}) \bclose )$.

2.
\env{} \subenv{}
\comp{$A_1\semicolon~ \mbox{\lstinline' int e = e1;'} \cdot
  \mbox{\lstinline'if(e)'} \bopen A_2\semicolon~
  \mbox{\lstinline' e = e2;'}) \bclose$
}{\env}.

3.
\comp{$A_1\semicolon~ \mbox{\lstinline' int e = e1;'} \cdot
  \mbox{\lstinline'if(e)'} \bopen A_2\semicolon~
  \mbox{\lstinline' e = e2;'}) \bclose$
}{\env} $\neq$ \errorenv.



\begin{proof}[Preuve du point 1.]~\\
  Par hypothèse, les traductions de \lstinline'p1' et \lstinline'p2' sont
  correctes, c'est-à-dire :

  \begin{center}
    \begin{tabular}{rclr}
      \eval{\lstinline'p1'}{\env}
      &=& \eval{\lstinline'e1'}{(\comp{$A_1$}{\env})} & \eqlabel{h1} \\
      \eval{\lstinline'p2'}{\env}
      &=& \eval{\lstinline'e2'}{(\comp{$A_2$}{\env})} & \eqlabel{h2} \\
      %\env & \subenv & \compi{$I_1$}{\env} & \eqlabel{h3} \\
      %\env & \subenv & \compi{$I_2$}{\env} & \eqlabel{h4} \\
      %\compi{$I_1$}{\env} & $\neq$ & \errorenv & \eqlabel{h5} \\
      %\compi{$I_2$}{\env} & $\neq$ & \errorenv & \eqlabel{h6} \\
    \end{tabular}
  \end{center}

  Développons le membre droit :
  
  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
        (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
        (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env}} \\
    & $\eq{\eqlabel{I-split}}$ & \compi{
      $(l, \mbox{\lstinline'if(e)'} \bopen I_2 \concat
      (l, \mbox{\lstinline'e = e2;'}) \bclose )$
    }{
      (\compi{$(l, \mbox{\lstinline'int e = e1;'})$}{(\compi{$I_1$}{\env})
      })
    } \\
    & $\eq{\eqlabel{I-instr}}$ & \compi{
      $(l, \mbox{\lstinline'if(e)'} \bopen I_2 \concat
      (l, \mbox{\lstinline'e = e2;'}) \bclose )$
    }{
      (\comp{\lstinline'int e = e1;'}{(\compi{$I_1$}{\env})
      })
    } \\
    & $\eq{\eqlabel{C-set}}$ & \compi{
      $(l, \mbox{\lstinline'if(e)'} \bopen I_2 \concat
      (l, \mbox{\lstinline'e = e2;'}) \bclose )$
    }{
      ((\compi{$I_1$}{\env})
      [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
      )
    } \\
    & $\eq{\eqlabel{I-instr}}$ & \comp{
      $\mbox{\lstinline'if(e)'} \bopen I_2 \concat
      (l, \mbox{\lstinline'e = e2;'}) \bclose$
    }{
      ((\compi{$I_1$}{\env})
      [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
      )
    } \\

    %% cas true
    \multicolumn{3}{l}{
      (1) Cas où la valeur de l'expression de la conditionnelle est vraie :} \\
    \multicolumn{3}{l}{
      Nouvelle hypothèse : \eval{\lstinline'p1'}{\env} = \textit{true}
      ~~\eqlabel{h7}
    } \\
    \multicolumn{3}{l}{
      Car
      \eval{\lstinline'e'}{(
        (\compi{$I_1$}{\env})
        [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
      )} = \textit{true}} \\
    & $\eq{\eqlabel{C-if}}$ & \compi{
      $I_2 \concat (l, \mbox{\lstinline'e = e2;'})$
    }{(
      (\compi{$I_1$}{\env})
      [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
      )} \\
    & $\eq{\eqlabel{I-split}}$ & \compi{
      $(l, \mbox{\lstinline'e = e2;'})$
    }{(\compi{$I_2$}{(
        (\compi{$I_1$}{\env})
        [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
        )}
      )} \\
    & $\eq{\eqlabel{I-instr}}$ & \comp{
      \lstinline'e = e2;'
    }{(\compi{$I_2$}{(
        (\compi{$I_1$}{\env})
        [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
        )}
      )} \\
    & $\eq{\eqlabel{C-set}}$ & (\compi{$I_2$}{(
      (\compi{$I_1$}{\env})
      [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
      )}
    )[\lstinline'e' $\mapsto$ \eval{\lstinline'p2'}{\env}] \\
    \multicolumn{3}{l}{
      En évaluant \lstinline'e' dans ce nouvel environnement, on obtient :
    } \\
    \multicolumn{3}{l}{
      \eval{\lstinline'e'}{(\compi{$I_2$}{(
          (\compi{$I_1$}{\env})
          [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
          )}
        )[\lstinline'e' $\mapsto$ \eval{\lstinline'p2'}{\env}]}
    } \\
    & $\eq{\eqlabel{E-lval}}$ & \eval{\lstinline'p2'}{\env} \\
    & $\eq{\eqlabel{h7}}$
    & \eval{\lstinline'p1'}{\env} $\land$ \eval{\lstinline'p2'}{\env} \\
    & $\eq{\eqlabel{P-and}}$ & \eval{\lstinline'p1 \&\& p2'}{\env} \\

    %% cas false
    \multicolumn{3}{l}{
      (2) Cas où la valeur de l'expression de la conditionnelle est fausse :} \\
    \multicolumn{3}{l}{
      Nouvelle hypothèse : \eval{\lstinline'p1'}{\env} = \textit{false}
      ~~\eqlabel{h8}
    }\\
    \multicolumn{3}{l}{
      Car \eval{\lstinline'e'}{(
        (\compi{$I_1$}{\env})
        [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
        )} = \textit{false}}\\
    &$\eq{\eqlabel{C-if}}$
    & (\compi{$I_1$}{\env})[\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
    \\
    \multicolumn{3}{l}{
      En évaluant \lstinline'e' dans ce nouvel environnement, on obtient :
    } \\
    \multicolumn{3}{l}{
      \eval{\lstinline'e'}{(
        (\compi{$I_1$}{\env})
        [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
        )}
    } \\
    & $\eq{\eqlabel{E-lval}}$
    & \eval{\lstinline'p1'}{\env} \\
    & $\eq{\eqlabel{h8}}$
    & \eval{\lstinline'p1'}{\env} $\land$ \eval{\lstinline'p2'}{\env} \\
    & $\eq{\eqlabel{P-and}}$ & \eval{\lstinline'p1 \&\& p2'}{\env} \\
  \end{tabular}

  Nous avons donc prouvé, pour tout environnement \env :

  \eval{\lstinline'e'}{(
    \compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
      (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
      (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env}
    )} = \eval{\lstinline'p1 && p2'}{\env}.

  De manière informelle, la preuve de la seconde propriété est assurée par le
  fait que d'une part les fragments de code générés ne modifient que la
  variable fraîche \lstinline'e' et d'autre part, les hypothèses \eqlabel{h3}
  et \eqlabel{h4} nous assurent que les fragments $I_1$ et $_2$ ne modifient pas
  les variables de l'environnement \env.
  On en conclut donc que les fragments générés
  $I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
  (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
  (l, \mbox{\lstinline'e = e2;'}) \bclose )$ ne modifient pas les variables de
  l'environnement \env, et donc :

  \env \subenv
  \compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
    (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
    (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env}.

  Les hypothèses \eqlabel{h5} et \eqlabel{h6} et le fait que les fragments de
  code générés ne produisent pas d'erreur (seule la variable fraîche
  \lstinline'e' est affectée) nous assurent que si \env n'est pas un
  environnement d'erreur (ici encore, \env ne peut pas être \errorenv puisque la
  traduction se serait arrêtée dès l'obtention de l'erreur), alors :

  \compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
  (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
  (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env} $\neq$ \errorenv.
  ~\\
\end{proof}


\begin{proof}[Preuve du point 2.]~\\
  ...
~\\
\end{proof}

\begin{proof}[Preuve du point 3.]~\\
  ...
~\\
\end{proof}


\section{Preuve de la Traduction des Annotations}
\label{sec:annotation-translation}


Nous allons maintenant prouver les théorèmes~\ref{th:error} et
\ref{th:inclusion} pour chaque classe d'annotations : les assertions, les
contrats de boucle et les contrats de fonction.
Ces preuves s'appuient sur les preuves de correction de la traduction des termes
et des prédicats établies dans les parties précédentes.


\subsection{Preuve de la Traduction des Assertions}


{\myinference[$\alpha$-assert]
  {(l, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
  {(l, \mbox{\lstinline'assert p;'})
    \rulearrow I \concat (l, \mbox{\lstinline'fassert(e);'})}
}


Prouvons que pour tout environnement \env (théorème~\ref{th:error}) :

\comp{\lstinline'/*@ assert p; */ ;'}{\env} = \errorenv
$\equiv$ \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}
= \errorenv

et si l'assertion est valide (théorème~\ref{th:inclusion}) :

\env \subenv \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}.


\begin{proof}
  ~\\
  Hypothèses : le prédicat \lstinline'p' est correctement traduit.
  Pour tout environnement \env :
  \begin{tabular}{rclr}
    \eval{\lstinline'e'}{(\compi{$I$}{\env})} &=& \eval{\lstinline'p'}{\env}
    & \eqlabel{h1} \\
    \env & \subenv & \compi{$I$}{\env} & \eqlabel{h2} \\
    \compi{$I$}{\env} & $\neq$ & \errorenv & \eqlabel{h3} \\
  \end{tabular}

  (1) Cas où l'assertion est valide :

  Nouvelle hypothèse : \eval{\lstinline'p'}{\env} = \textit{true} \eqlabel{h4}

  Développons le membre gauche :

  \begin{tabular}{rcl}
    \comp{\lstinline'/*@ assert p; */ ;'}{\env} = \errorenv
    &$\eqv{\eqlabel{C-assert}}$& \env = \errorenv \\
    &$\equiv$ & \textit{false}, car si \env = \errorenv, la traduction
    se serait arrêtée. \\
  \end{tabular}

  Développons le membre droit :

  \begin{tabular}{rcl}
    \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env} = \errorenv
    &$\eqv{\eqlabel{I-split}}$
    & \compi{$(l, \mbox{\lstinline'fassert(e);'})$}{(\compi{$I$}{\env})}
    = \errorenv \\
    &$\eqv{\eqlabel{I-instr}}$
    & \comp{\lstinline'fassert(e);'}{(\compi{$I$}{\env})} = \errorenv \\
    &$\eqv{\eqlabel{C-fassert}}$ & \compi{$I$}{\env} = \errorenv \\
    &$\eqv{\eqlabel{h3}}$ & \textit{false} \\
  \end{tabular}

  Quand l'assertion est valide, on a bien :

  \comp{\lstinline'/*@ assert p; */ ;'}{\env} = \errorenv
  $\equiv$ \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}
  = \errorenv.

  D'autre part, d'après le développement du membre droit, on a :

   \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}
   = \compi{$I$}{\env}.
   
   En substituant dans l'hypothèse \eqlabel{h2} on obtient directement :

   \env \subenv \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}.

  (2) Cas où l'assertion est invalide :

  Nouvelle hypothèse : \eval{\lstinline'p'}{\env} = \textit{false} \eqlabel{h5}

  Développons le membre gauche :

  \begin{tabular}{rcl}
    \comp{\lstinline'/*@ assert p; */ ;'}{\env} = \errorenv
    &$\eqv{\eqlabel{C-assert}}$& \errorenv = \errorenv \\
    &$\equiv$& \textit{true}
  \end{tabular}

  Développons le membre droit :

  \begin{tabular}{rcl}
    \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env} = \errorenv
    &$\eqv{\eqlabel{I-split}}$
    & \compi{$(l, \mbox{\lstinline'fassert(e);'})$}{(\compi{$I$}{\env})}
    = \errorenv \\
    &$\eqv{\eqlabel{I-instr}}$
    & \comp{\lstinline'fassert(e);'}{(\compi{$I$}{\env})} = \errorenv \\
    &$\eqv{\eqlabel{C-fassert}}$ & \errorenv = \errorenv \\
    &$\equiv$& \textit{true}
  \end{tabular}

  On a donc bien :

  \comp{\lstinline'/*@ assert p; */ ;'}{\env} = \errorenv
  $\equiv$ \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}
  = \errorenv.
  ~\\
\end{proof}


\subsection{Preuve de la Traduction des Contrats de Boucles}


Nous considérons une boucle complètement annotée avec
\lstinline'loop invariant', \lstinline'loop variant' et
\lstinline'loop assigns'.
La traduction utilise les trois règles suivantes :


{\scriptsize
  {\myinference[$\alpha$-check-loop-assigns]
    {}
    {
      \splitfrac {
        (l, \mbox{\lstinline'loop assigns X;'}) \rulearrow
      }{
        \splitfrac {
          I \concat
          \forall (\mbox{\lstinline'x'}:ctype) \in G-X:
          (BegIter_l, \mbox{\lstinline'ctype var_x = x;'})
        }{
          \concat (EndIter_l, \mbox{\lstinline'fassert(x == var_x);'})
        }
      }
    }
  }
}

{\scriptsize
  {\myinference[$\alpha$-check-invariant]
    {(l, \mbox{\lstinline'p'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
      (EndIter_l, \mbox{\lstinline'p'}) \rulearrow (I_2, \mbox{\lstinline'e2'})}
    {
      (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
      I_1 \concat (l, \mbox{\lstinline'fassert(e1);'})
      \concat I_2 \concat (EndIter_l, \mbox{\lstinline'fassert(e2);'})
    }
  }
}

{\scriptsize
  {\myinference[$\alpha$-variant]
    {
      (BegIter_l, \mbox{\lstinline't'}) \rulearrow (I_1, \mbox{\lstinline'e1'})
      \\
      (EndIter_l, \mbox{\lstinline't'}) \rulearrow (I_2, \mbox{\lstinline'e2'})
    }
    {
      \splitfrac{
        (l, \mbox{\lstinline'loop variant t;'}) \rulearrow
      }{
        I_1 \concat ((BegIter_l,
        \mbox{\lstinline'fassert('}
        \underline{\mbox{\lstinline'0 <= e1'}}
        \mbox{\lstinline');' })
        \concat I_2
        \concat(EndIter_l,
        \mbox{\lstinline'fassert('}
        \underline{\mbox{\lstinline'e2'}\Zclear
          \mbox{\lstinline'< e1'} \Zclear}
        \mbox{\lstinline');'})
      }
    }
  }
}


Donnons une intuition de la preuve de correction de la traduction des
contrats de boucle à partir de ces règles.
La figure~\ref{fig:proof-loop-contract} illustre le principe de la preuve.
La partie gauche de la figure montre une boucle disposant d'un contrat de boucle
(\lstinline'loop invariant', \lstinline'loop assigns' et
\lstinline'loop variant') au label $L$, avec un corps quelconque \lstinline'A'.
En partie droite est affiché le code résultant de la traduction de cette
boucle, où chaque ensemble d'instructions (regroupées avec une accolade) est
mis en relation avec l'annotation du programme original dont il est la
traduction.
Les lignes 2--3 et 13--14 résultent de la traduction de l'invariant ligne 2,
les lignes 6--8 et 15--17 résultent de la traduction de la clause assigns ligne
3 et les lignes 9--10 et 18--19 résultent de la traduction du variant ligne 4.
$Spec2Code$\lstinline'('$I_1$\lstinline', e1)' est une notation signifiant que
\lstinline'p' se traduit en $(I_1, \mbox{\lstinline'e1'})$ en accord avec la
règle \textsc{$\alpha$-check-invariant}.
La règle \eqlabel{C-while-1} de la sémantique de la boucle correspond aux
lignes 2--3 du code instrumenté : si $\lnot$ \eval{\lstinline'p'}{\env}, alors
\lstinline'fassert(e1)' produit \errorenv.
La règle \eqlabel{C-while-2} correspond au cas où la condition de boucle n'est
pas respectée.
Le code que nous générons n'impacte pas les variables
du programme original, donc la condition de boucle \lstinline'e' a la même
valeur en chaque point dans le programme original et le programme instrumenté.
La règle \eqlabel{C-while-3} correspond aux lignes 9--10 : \errorenv est
produit si $\lnot$ \eval{\lstinline't >= 0'}{\env}.
La règle \eqlabel{C-while-4} correspond aux lignes 13--14 : \errorenv est
produit si $\lnot$ \eval{\lstinline'p'}{(\compi{$A$}{\env})}.
La règle \eqlabel{C-while-5} correspond aux lignes 18--19 (en réutilisant
la valeur du variant au début de l'itération de la boucle, calculée ligne 9) :
\errorenv est produit si (\eval{\lstinline't'}{(\compi{$A$}{\env})}) $\ge$
 (\eval{\lstinline't'}{\env}).
La règle \eqlabel{C-while-6} correspond aux lignes 6--8 et 15--17 :
\errorenv est produit si $\exists x. x \in G-X.$
(\eval{\lstinline'x'}{(\compi{$A$}{\env})}) $\ne$  (\eval{\lstinline'x'}{\env}),
où $G-X = \{\mbox{\lstinline'x1'},\ldots,\mbox{\lstinline'xN'}\}$.
La règle \eqlabel{C-while-7} correspond à l'exécution récursive de la boucle.


\input{figures/fig_proof_loop_contract}


\subsection{Preuve de la Traduction des Contrats de Fonctions}

Il nous faut distinguer deux cas pour la preuve des contrats de fonction : le
cas où la fonction est ``sous vérification'' -- c'est-à-dire où c'est la
fonction de plus haut niveau et sa précondition est supposée vraie -- et le cas
où la fonction est appelée -- et sa précondition doit être vérifiée au point
d'appel.
Nous traitons les deux cas de manière séparée dans les deux sous-parties
suivantes.

\subsubsection{Fonction sous vérification}

Nous considérons une fonction \lstinline'f' sous vérification annotée avec
\lstinline'requires' (ou \lstinline'typically'), \lstinline'assigns' et
\lstinline'ensures'.
La traduction utilise les trois règles suivantes :

{\scriptsize
  {\myinference[$\alpha$-assume-pre\hspace{-2mm}]
    {(Beg_f, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
    {(Beg_f, \left \{\hspace{-2mm}
      \begin{array}{r}
        \mbox{\lstinline'typically'} \\
        \mbox{\lstinline'requires'}
      \end{array} \mbox{\lstinline'p;'} \right.
      )
      \rulearrow
      I \concat (Beg_f, \mbox{\lstinline'fassume(e);'})}
  }
}

{\scriptsize
  {\myinference[$\alpha$-check-assigns]
    {}
    {
      \splitfrac{
        (End_f, \mbox{\lstinline'assigns X;'}) \rulearrow
      } {
        I \concat
        \forall (\mbox{\lstinline'x'}:ctype) \in G-X:
        (Beg_f, \mbox{\lstinline'ctype var_x = x;'})
        \concat (End_f, \mbox{\lstinline'fassert(x == var_x);'})
      }
    }
  }
}

{\scriptsize
  {\myinference[$\alpha$-check-post]
    {(End_f, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
    {(End_f, \mbox{\lstinline'ensures p;'})
      \rulearrow
      I \concat (End_f, \mbox{\lstinline'fassert(e);'})}
  }
}


\input{figures/fig_proof_fct_contract_main}

La figure~\ref{fig:proof-fct-contract-main}, illustre la preuve de correction
de la traduction des contrats pour la fonction sous vérification sur un schéma
générique normalisé de fonction.
La partie gauche de la figure montre une fonction \lstinline'f' disposant d'un
contrat, avec un corps quelconque \lstinline'A'.
En partie droite est affichée le code résultant de la traduction de cette
fonction, où chaque ensemble d'instructions (regroupées avec une accolade) est
mis en relation avec l'annotation du programme original dont il est la
traduction.

Les lignes 3--4 résultent de la traduction de la précondition ligne 1,
les lignes 5--7 et 10--12 résultent de la traduction de la clause assigns ligne
2 et les lignes 13--14 résultent de la traduction de la postcondition ligne 3.
La règle \eqlabel{f-1} de la sémantique dénotationnelle des fonctions
(figure~\ref{fig:sem-fct} du chapitre~\ref{sec:lang}) correspond aux lignes
3--4 du code instrumenté :
si $\lnot$ \eval{\lstinline'p1'}{\env} (la précondition de la fonction sous
vérification n'est pas valide) on arrive à une contradiction.
La règle \eqlabel{f-2} ne s'applique pas à la fonction sous vérification.
La règle \eqlabel{f-3} correspond aux lignes 5--7 et 10--12 : \errorenv est
produit si $\exists x. (x \in G-X.$
(\eval{\lstinline'x'}{(\compi{$A$}{\env})}) $\ne$ (\eval{\lstinline'x'}{\env})
$)$,
où $G-X = \{\mbox{\lstinline'x1'},\ldots,\mbox{\lstinline'xN'}\}$.
La règle \eqlabel{f-4} correspond aux lignes 13--14 : \errorenv est produit
si $\lnot$ \eval{\lstinline'p2'}{(\compi{$A$}{\env})}.
La règle \eqlabel{f-5} correspond à l'exécution normale de la fonction.


\subsubsection{Fonctions appelées}

Nous considérons une fonction \lstinline'f' appelée annotée avec
\lstinline'requires', \lstinline'assigns' et \lstinline'ensures'.
La traduction des contrats d'une fonction appelée réutilise les règles
\textsc{$\alpha$-check-assigns} et \textsc{$\alpha$-check-post} de la partie
précédente.
En revanche, afin de vérifier la précondition d'une fonction appelée et non la
supposer vraie, la règle \textsc{$\alpha$-assume-pre} est remplacée par la règle
suivante :

{\scriptsize
  {\myinference[$\alpha$-check-pre\hspace{-2mm}]
    {(Beg_f, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
    {(Beg_f, \mbox{\lstinline'requires p;'})
      \rulearrow
      I \concat (Beg_f, \mbox{\lstinline'fassert(e);'})}
  }
}

La figure~\ref{fig:proof-fct-contract-call}, illustre la preuve de correction
de la traduction des contrats pour la fonction sous vérification sur un exemple.
La partie gauche de la figure montre une fonction \lstinline'f' disposant d'un
contrat, avec un corps quelconque \lstinline'A'.
En partie droite est affichée le code résultant de la traduction de cette
fonction, où chaque ensemble d'instructions (regroupées avec une accolade) est
mis en relation avec l'annotation du programme original dont il est la
traduction.

Les lignes 3--4 résultent de la traduction de la précondition ligne 1,
les lignes 5--7 et 10--12 résultent de la traduction de la clause assigns ligne
2 et les lignes 13--14 résultent de la traduction de la postcondition ligne 3.
La règle \eqlabel{f-1} de la sémantique dénotationnelle des fonctions
(figure~\ref{fig:sem-fct} du chapitre~\ref{sec:lang}) ne s'applique par aux
fonctions appelées.
La règle \eqlabel{f-2} correspond aux lignes 3--4 du code instrumenté :
\errorenv est produit si $\lnot$ \eval{\lstinline'p1'}{\env}.
Les autres règles sont traduites de manière similaire à la partie précédente.
La règle \eqlabel{f-3} correspond aux lignes 5--7 et 10--12 : \errorenv est
produit si $\exists x. x \in G-X.$
(\eval{\lstinline'x'}{(\compi{$A$}{\env})}) $\ne$ (\eval{\lstinline'x'}{\env}),
où $G-X = \{\mbox{\lstinline'x1'},\ldots,\mbox{\lstinline'xN'}\}$.
La règle \eqlabel{f-4} correspond aux lignes 13--14 : \errorenv est produit
si $\lnot$ \eval{\lstinline'p2'}{(\compi{$A$}{\env})}.
La règle \eqlabel{f-5} correspond à l'exécution normale de la fonction.


\input{figures/fig_proof_fct_contract_call}



\section*{Conclusion du chapitre}

L'objectif de ce chapitre était de définir une traduction en C des annotations
\eacsl pour la génération de tests et de fournir une justification de la
correction de cette traduction.

Nous avons tout d'abord présenté le processus de la traduction dans sa
généralité.
Puis nous avons défini les règles permettant pour chaque terme et prédicat
\eacsl d'obtenir un code C calculant cette expression tout en préservant la
sémantique d'\eacsl.
Ces règles nous ont permis de définir différentes manières de traduire les
annotations \eacsl : \lstinline'assert', \lstinline'requires',
\lstinline'typically', \lstinline'assigns', \lstinline'ensures',
\lstinline'loop invariant', \lstinline'loop assigns' et
\lstinline'loop variant'.
Ces différentes instrumentations des annotations nous permettront par la suite
de détecter différentes erreurs dans le code et la spécification.
Le chapitre suivant aborde la preuve de correction des règles de traduction des
termes, prédicats et annotations.

Grâce à notre justification de correction, nous pouvons assurer l'absence de
faux positifs et de faux négatifs lors de la génération de tests sur le
programme instrumenté, ainsi que la non-modification par le code généré des
variables du programme d'origine.
La preuve de cette propriété est fournie de manière formelle pour les assertions
et de manière informelle mais intuitive pour les contrats de boucle et les
contrats de fonction.



%% \newpage
%% \commentGP{mettre toute la preuve en annexe ?}
%% \commentGP{juste mettre la preuve des invariants en annexe ?}
%% \section{Annexe : Preuve de la Traduction des Quantifications Universelles}

%% {\myinference[$\pi$-forall]
%%   {
%%     (l, \mbox{\lstinline't1'} : \mathbb{Z}) \rulearrow
%%     (I_1, \mbox{\lstinline'e1'}) \\
%%     (l, \mbox{\lstinline't2'} : \mathbb{Z}) \rulearrow
%%     (I_2, \mbox{\lstinline'e2'}) \\
%%     (l, \mbox{\lstinline'p'}) \rulearrow (I_3, \mbox{\lstinline'e3'})
%%   }
%%   {
%%     \splitfrac {
%%       (l, \mbox{\lstinline'\\forall integer k; t1 <= k <= t2 ==> p'})
%%       \rulearrow
%%     } {
%%       \splitfrac {
%%         (I_1 \cdot I_2
%%         \cdot (l, \mbox{\lstinline'int e = 1;'})
%%         \cdot
%%           (l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} )
%%       } {
%%         \cdot
%%           (l, \mbox{\lstinline'while('}
%%           \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%           \bopen
%%           I_3
%%           \cdot (l, \mbox{\lstinline'e = e3;'})
%%           \cdot (l, \underline{\mbox{\lstinline'k++'}} \semicolon)
%%           \bclose )
%%         \cdot
%%           (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon )
%%         \cdot
%%           (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon )
%%         \cdot
%%           (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon ),
%%         \mbox{\lstinline'e'})
%%       }
%%     }
%%   }
%% }~\\


%% Prouvons que pour n'importe quel environnement \env :

%% \eval{\lstinline'e'}{(\compi{$I$}{\env})} =
%% \eval{\lstinline'\\forall integer k; t1 <= k <= t2 ==> p'}{\env}

%% et

%% \env \subenv \compi{$I$}{\env}

%% et

%% \compi{$I$}{\env} $\neq$ \errorenv.


%% \begin{proof}
%%   ~\\
%%   Hypothèses : \lstinline't1', \lstinline't2' et \lstinline'p' sont correctement
%%   traduits.
%%   Pour tout environnement \env :

%%   \begin{tabular}{rclr}
%%     \eval{\lstinline'e1'}{(\compi{$I_1$}{\env})}
%%     & = & \eval{\lstinline't1'}{\env} & \eqlabel{h1} \\
%%     \eval{\lstinline'e2'}{(\compi{$I_2$}{\env})}
%%     & = & \eval{\lstinline't2'}{\env} & \eqlabel{h2} \\
%%     \eval{\lstinline'e3'}{(\comp{$I_3$}{\env})}
%%     & = & \eval{\lstinline'p'}{\env} & \eqlabel{h3} \\
%%     \env & \subenv & \compi{$I_1$}{\env} & \eqlabel{h4} \\
%%     \env & \subenv & \compi{$I_2$}{\env} & \eqlabel{h5} \\
%%     \env & \subenv & \compi{$I_3$}{\env} & \eqlabel{h6} \\
%%     \compi{$I_1$}{\env} & $\neq$ & \errorenv & \eqlabel{h7} \\
%%     \compi{$I_2$}{\env} & $\neq$ & \errorenv & \eqlabel{h8} \\
%%     \compi{$I_3$}{\env} & $\neq$ & \errorenv & \eqlabel{h9} \\
%%   \end{tabular}

%%   Développons \compi{$I$}{\env} :
  
%%   \begin{tabular}{p{0cm} p{.5cm} p{14cm}}
%%     \multicolumn{3}{l}{\compi{$I$}{\env}} \\
%%     &=&
%%     \compi{$I_1 \cdot I_2 \cdot (l, \mbox{\lstinline'int e = 1;'}) \cdot
%%       (l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
%%       (l, \mbox{\lstinline'while('}
%%       \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%       \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%       (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
%%       (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{\env}
%%     \\
%%     &$\eq{\eqlabel{I-split}}$&
%%     \compi{$I_2 \cdot (l, \mbox{\lstinline'int e = 1;'}) \cdot
%%       (l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
%%       (l, \mbox{\lstinline'while('}
%%       \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%       \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%       (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
%%       (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       (\compi{$I_1$}{\env})}
%%     \\
%%     &$\eq{\eqlabel{I-split}}$&
%%     \compi{$(l, \mbox{\lstinline'int e = 1;'}) \cdot
%%       (l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
%%       (l, \mbox{\lstinline'while('}
%%       \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%       \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%       (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
%%       (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       (\compi{$I_2$}{(\compi{$I_1$}{\env})})
%%     }
%%     \\
%%     &$\eq{\eqlabel{I-split}}$&
%%     \compi{$(l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
%%       (l, \mbox{\lstinline'while('}
%%       \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%       \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%       (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
%%       (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       (\compi{$(l, \mbox{\lstinline'int e = 1;'})$}{
%%         (\compi{$I_2$}{(\compi{$I_1$}{\env})})})
%%     }
%%     \\
%%     &$\eq{\eqlabel{I-instr}}$&
%%     \compi{$(l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
%%       (l, \mbox{\lstinline'while('}
%%       \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%       \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%       (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
%%       (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       (\comp{\lstinline'int e = 1;'}{(\compi{$I_2$}{(\compi{$I_1$}{\env})})})
%%     }
%%     \\
%%     &$\eq{\eqlabel{C-set}}$&
%%     \compi{$(l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
%%       (l, \mbox{\lstinline'while('}
%%       \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%       \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%       (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
%%       (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
%%     }
%%     \\
%%     &$\eq{\eqlabel{I-split}}$&
%%     \compi{$(l, \mbox{\lstinline'while('}
%%       \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%       \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%       (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
%%       (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       (\compi{$(l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} )$}{
%%         ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])})
%%     }
%%     \\
%%     &$\eq{\eqlabel{I-instr}}$&
%%     \compi{$(l, \mbox{\lstinline'while('}
%%       \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%       \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%       (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
%%       (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       (\comp{$\Zinit \underline{\mbox{\lstinline'k = e1;'}}$}{
%%         ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])})
%%     }
%%     \\
%%     &$\eq{\eqlabel{C-Z-set}}$&
%%     \compi{$(l, \mbox{\lstinline'while('}
%%       \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%       \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%       (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
%%       (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
%%         \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
%%     }
%%     \\
%%     &$\eq{\eqlabel{I-split}}$&
%%     \compi{$(l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       (\compi{$(l, \mbox{\lstinline'while('}
%%         \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%         \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%         (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose )$}{
%%         ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
%%           \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
%%       })
%%     }
%%     \\
%%     &$\eq{\eqlabel{I-instr}}$&
%%     \compi{$(l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       (\comp{$\mbox{\lstinline'while('}
%%         \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%         \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%         (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose$}{
%%         ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
%%           \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
%%       })
%%     }
%%     \\
%%   \end{tabular}

%%   (1) Cas \eval{\lstinline't1'}{\env} $>$ \eval{\lstinline't2'}{\env}
%%   (nouvelle hypothèse \eqlabel{rel1}) :

%%   \begin{tabular}{p{0cm} p{.5cm} p{14cm}}
%%     &$\eq{\eqlabel{C-while}}$&
%%     \compi{$(l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
%%         \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
%%     }
%%     \\
%%     &$\eq{\eqlabel{I-split}}$&
%%     \compi{$(l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       (\compi{$(l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon )$}{
%%         ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
%%           \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
%%       })
%%     }
%%     \\
%%     &$\eq{\eqlabel{I-instr}}$&
%%     \compi{$(l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       (\comp{$\underline{\mbox{\lstinline'k'}} \Zclear \semicolon$}{
%%         ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
%%           \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
%%       })
%%     }
%%     \\
%%     &$\eq{\eqlabel{C-Z-unset}}$&
%%     \compi{$(l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%       (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%       ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
%%     }
%%     \\
%%     &$\eq{\eqlabel{I-split}}$&
%%     \compi{$(l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{(
%%       \compi{$(l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon )$}{
%%         ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
%%       })
%%     }
%%     \\
%%     &$\eq{\eqlabel{I-instr}}$&
%%     \compi{$(l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{(
%%       \comp{$\underline{\mbox{\lstinline'e1'}} \Zclear \semicolon$}{
%%         ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
%%       })
%%     }
%%     \\
%%     &$\eq{\eqlabel{C-Z-unset}}$&
%%     \compi{$(l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{(
%%       ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
%%       $-~\{\mbox{\lstinline'e1'}\}$)
%%     }
%%     \\
%%     &$\eq{\eqlabel{I-instr}}$&
%%     \comp{$\underline{\mbox{\lstinline'e2'}} \Zclear \semicolon$}{(
%%       ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
%%       $-~\{\mbox{\lstinline'e1'}\}$)
%%     }
%%     \\
%%     &$\eq{\eqlabel{C-Z-unset}}$&
%%       ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
%%       $-~\{\mbox{\lstinline'e1',\lstinline'e2'}\}$
%%     \\
%%   \end{tabular}

%%   En évaluant \lstinline'e' dans ce nouvel environnement, on obtient :

%%   \begin{tabular}{rcl}
%%     \eval{\lstinline'e'}{
%%       (((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
%%       $-~\{\mbox{\lstinline'e1',\lstinline'e2'}\}$)}
%%     & $\eq{\eqlabel{E-lval}}$ & 1 \\
%%     & = & \lstinline'\forall integer k; \false ==> p' \\
%%     & $\eq{\eqlabel{rel1}}$
%%     & \lstinline'\forall integer k; t1 <= k <= t2 ==> p' \\
%%   \end{tabular}

%%   D'après les hypothèses \eqlabel{h4}, \eqlabel{h5} et le fait que les seules
%%   variables modifiées ont été générées par l'instrumentation (\lstinline'e',
%%   \lstinline'e1' et \lstinline'e2'), on a :

%%   \env \subenv
%%   (((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
%%   $-~\{\mbox{\lstinline'e1',\lstinline'e2'}\}$).

%%   Les hypothèses \eqlabel{h7} et \eqlabel{h8} nous permettent de déduire que :

%%   (((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
%%   $-~\{\mbox{\lstinline'e1',\lstinline'e2'}\}$) $\neq$ \errorenv.

%%   (2) Cas \eval{\lstinline't1'}{\env} $\le$ \eval{\lstinline't2'}{\env}
%%   (nouvelle hypothèse \eqlabel{rel2}) :

%%   Pour calculer le nouvel environnement résultant de l'exécution de la boucle
%%   nous avons besoin de deux invariants de boucle :

%%   \begin{tabular}{rclr}
%%     \multicolumn{3}{c}{
%%       \eval{\lstinline't1'}{\env} $\le$ \eval{\lstinline'k'}{\env} $\le$
%%       \eval{\lstinline't2'}{\env} + 1
%%     }
%%     & \eqlabel{inv-1} \\
%%     \eval{\lstinline'e'}{\env} &=&
%%     \eval{\lstinline'\\forall integer z; t1 <= z < k ==> p'}{\env}
%%     & \eqlabel{inv-2} \\
%%   \end{tabular}

%%   Supposons que ces propriétés ont été prouvées.
%%   \commentGP{Preuve longue. Pas nécessaire ?}
%%   Notons \env$'$ l'environnement après exécution de la boucle :

%%   \env$'$ = 
%%   \comp{$\mbox{\lstinline'while('}
%%     \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%     \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%     (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose$}{
%%     ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
%%       \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
%%   }

%%   \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
%%     \eval{\lstinline'e'}{\compi{$I$}{\env}}
%%     &=&
%%     \eval{\lstinline'e'}{
%%       (\compi{$(l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
%%         (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
%%         (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
%%         (\compi{$(l, \mbox{\lstinline'while('}
%%           \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%           \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%           (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose )$}{
%%           ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
%%             \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
%%         })
%%       })
%%     } \\
%%     &=&
%%     \eval{\lstinline'e'}{
%%         (\compi{$(l, \mbox{\lstinline'while('}
%%           \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
%%           \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%           (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose )$}{
%%           ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
%%             \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
%%         })
%%     } \\
%%     &=& \eval{\lstinline'e'}{\env$'$} \\
%%     &=& \eval{\lstinline'\\forall integer z; t1 <= z < k ==> p'}{\env} \\
%%   \end{tabular}

%%   Rappelons que
%%   \eval{\lstinline't1'}{\env$'$} $\le$ \eval{\lstinline'k'}{\env$'$} $\le$
%%   \eval{\lstinline't2'}{\env$'$} + 1
%%   (premier invariant de boucle).

%%   On sait que la condition de boucle est fausse dans cet environnement \env$'$ :

%%   \eval{\lstinline'k <= e2 && e'}{\env$'$} = \textit{false}

%%   Il y a donc deux cas non exclusifs :
%%   \begin{itemize}
%%   \item[$\bullet$] \eval{\lstinline'k <= e2'}{\env$'$} = \textit{false}
%%   \item[$\bullet$] \eval{\lstinline'e'}{\env$'$} = \textit{false}
%%   \end{itemize}

%%   (2-a) Cas \eval{\lstinline'k <= e2'}{\env$'$} = \textit{false}, soit
%%   \eval{\lstinline'k > t2'}{\env$'$} = \textit{true} :
  
%%   On sait que \eval{\lstinline'k > t2'}{\env$'$} et
%%   \eval{\lstinline'k <= t2+1'}{\env$'$},
%%   donc on
%%   a \eval{\lstinline'k'}{\env$'$} = \eval{\lstinline't2+1'}{\env$'$}.
%%   Avec cette nouvelle connaissance, on a :

%%   \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
%%     \eval{\lstinline'e'}{\compi{$I$}{\env}}
%%     &=& \eval{\lstinline'\\forall integer z; t1 <= z < k ==> p'}{\env} \\
%%     &=& \eval{\lstinline'\\forall integer z; t1 <= z < t2+1 ==> p'}{\env} \\
%%     &=& \eval{\lstinline'\\forall integer z; t1 <= z <= t2 ==> p'}{\env} \\
%%   \end{tabular}

%%   (2-b) Cas \eval{$e$}{\env$'$} = \textit{false} :

%%   \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
%%     \eval{\lstinline'e'}{\env$'$} = \textit{false}
%%     &$\equiv$&
%%     \eval{\lstinline'\\forall integer z; t1 <= z < k ==> p'}{\env$'$}
%%     = \textit{false} \\
%%     &$\equiv$&
%%     \eval{\lstinline'\\forall integer z; t1 <= z < t2+1 ==> p'}{\env$'$}
%%     = \textit{false} \\
%%     \multicolumn{3}{c}{car \eval{\lstinline'k'}{\env$'$} $\le$
%%       \eval{\lstinline't2+1'}{\env$'$}} \\
%%     &$\equiv$&
%%     \eval{\lstinline'\\forall integer z; t1 <= z <= t2 ==> p'}{\env$'$}
%%     = \textit{false} \\
%%     &$\equiv$&
%%     \eval{\lstinline'\\forall integer z; t1 <= z <= t2 ==> p'}{\env}
%%     = \textit{false} \\
%%     \multicolumn{3}{c}{
%%       car (\eval{\lstinline't1'}{\env}) = (\eval{\lstinline't1'}{\env$'$}) et
%%       (\eval{\lstinline't2'}{\env}) = (\eval{\lstinline't2'}{\env$'$})
%%     } \\
%%   \end{tabular}

%%   Donc on a :
%%   \eval{\lstinline'e'}{\env$'$} $\equiv$
%%   \eval{\lstinline'\\forall integer z; t1 <= z <= t2 ==> p'}{\env}.

%%   On a donc aussi :

%%   \eval{\lstinline'e'}{\compi{$I$}{\env}} =
%%   \eval{\lstinline'\\forall integer z; t1 <= z <= t2 ==> p'}{\env}.

%%   Grâce aux hypothèses \eqlabel{h4}, \eqlabel{h5}, \eqlabel{h6} et le fait que
%%   les seules variables affectées sont \lstinline'e' et \lstinline'k', qui
%%   n'appartiennent pas à l'environnement initial \env, on peut établir :
%%   \env \subenv \compi{$I$}{\env}.

%%   De manière similaire, grâce aux hypothèses \eqlabel{h7}, \eqlabel{h8},
%%   \eqlabel{h9}, et le fait que les fragments de code générés de provoquent pas
%%   d'erreur, le nouvel environnement est différent de \errorenv.
%% \end{proof}



%% \newpage

%% \begin{proof}
%%   ~\\
%%   \commentGP{à mettre en annexe ou pas ?}
%%   \commentGP{je pense que la preuve n'est pas nécessaire}

%%   Montrons que \eqlabel{inv-1} et \eqlabel{inv-2} sont vrais pour tout
%%   environnement \env.
%%   Montrons tout d'abord que ces invariants sont établis avant la première
%%   itération.

%%   Développons
%%   \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} + 1 :

%%   \begin{tabular}{rcl}
%%     \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} + 1
%%     &=& \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env}
%%     $\le$ \eval{$t_2$}{\env} + 1 \\
%%     &=& \eval{$t_1$}{\env} $\le$ \eval{$t_2$}{\env} + 1 \\
%%     &$\eq{rel2}$& \textit{true} \\
%%   \end{tabular}

%%   Développons le membre droit de

%%   \eval{$e$}{\env} =
%%   \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env} :

%%   \begin{tabular}{rcl}
%%     \multicolumn{3}{l}{
%%       \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}
%%     } \\
%%     &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= k-1 ==> p'}{\env} \\
%%     &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= t_1-1 ==> p'}{\env} \\
%%     &=& \eval{\lstinline'\\forall integer z; \\false ==> p'}{\env} \\
%%     &=& \eval{\lstinline'\\true'}{\env} \\
%%     &=& 1 \\
%%     &=& \eval{$e$}{\env} \\
%%   \end{tabular}

%%   Ces deux invariants sont établis avant la première itération, montrons qu'ils
%%   sont maintenus après chaque itération.
%%   On suppose donc que ces invariants sont vrais après une itération quelconque
%%   et sont donc des hypothèses.
%%   Soit \env l'environnement au début de l'itération.

%%   Prouvons que le premier invariant est maintenu après chaque itération :

%%   On a : \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} + 1
  
%%   Ce qui peut être réécrit en :
%%   \eval{$t_1 \le k \le t_2 + 1$}{\env} = \textit{true}

%%   Montrons :

%%   \eval{$t_1 \le k \le t_2 + 1$}{\compi{
%%       $I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
%%       (l, \underline{\mbox{\lstinline'k++'}} \semicolon)$
%%     }{
%%       (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
%%         $e_2 \mapsto$ \eval{$t_2$}{\env},
%%         $e \mapsto$
%%         \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
%%     }} = \textit{true}

%%   Développons le membre gauche :

%%   \begin{tabular}{p{6cm} p{.5cm} p{9cm}}
%%     \eval{$t_1 \le k \le t_2 + 1$}{\comp{
%%       $I_3 \cdot \mbox{\lstinline'e = e_3;'}
%%       \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
%%     }{
%%       (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
%%         $e_2 \mapsto$ \eval{$t_2$}{\env},
%%         $e \mapsto$
%%         \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
%%     }}
%%     &=&
%%     \eval{$t_1 \le k \le t_2 + 1$}{
%%       \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
%%         $e_2 \mapsto$ \eval{$t_2$}{\env},
%%         $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
%%         $e \mapsto$ \eval{\lstinline'p'}{\env},
%%         $k \mapsto$ (\eval{\lstinline'k'}{\env})+1]
%%     } \\
%%     &=&
%%     \eval{$t_1 \le k+1 \le t_2 + 1$}{
%%       \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
%%         $e_2 \mapsto$ \eval{$t_2$}{\env},
%%         $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
%%         $e \mapsto$ \eval{\lstinline'p'}{\env},
%%         $k \mapsto$ (\eval{\lstinline'k'}{\env})]
%%     } \\
%%     &=& \eval{$t_1 \le k+1 \le t_2 + 1$}{\env} \\
%%     &=& \eval{$t_1 \le k+1$}{\env} $\land$ \eval{$k+1 \le t_2 + 1$}{\env} \\
%%     &=& \eval{$t_1 \le k+1$}{\env} $\land$ \eval{$k \le t_2$}{\env} \\
%%     &=& \textit{true} $\land$ \eval{$k \le t_2$}{\env} \\
%%     \multicolumn{3}{c}{par hypothèse de récurrence} \\
%%     &=& \eval{$k \le t_2$}{\env} \\
%%     &=& \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} \\
%%     &=& \eval{$k$}{\env} $\le$ \eval{$e_2$}{\env} \\
%%     &=& \eval{$k \le e_2$}{\env} \\
%%     &=& \textit{true} \\
%%     \multicolumn{3}{c}{la condition de boucle est vraie sinon on n'exécuterait
%%       pas le code de la boucle} \\
%%   \end{tabular}
  
%%   Le premier invariant est donc maintenu après chaque itération.
%%   Prouvons maintenant que le deuxième invariant est maintenu après chaque
%%   itération.
%%   Développons le membre gauche :

%%   \begin{tabular}{p{6cm} p{.5cm} p{9cm}}
%%     (\comp{
%%       $I_3 \cdot \mbox{\lstinline'e = e_3;'}
%%       \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
%%     }{
%%       (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
%%         $e_2 \mapsto$ \eval{$t_2$}{\env},
%%         $e \mapsto$
%%         \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
%%     })(e)
%%     &=&
%%     (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
%%       \comp{\lstinline'e = e_3;'}{(
%%         \comp{$I_3$}{(
%%           \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
%%             $e_2 \mapsto$ \eval{$t_2$}{\env},
%%             $e \mapsto$
%%             \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}]
%%           )}
%%         )}
%%       )}
%%     )(e) \\
%%     &=&
%%     (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
%%       \comp{\lstinline'e = e_3;'}{(
%%         \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
%%           $e_2 \mapsto$ \eval{$t_2$}{\env},
%%           $e \mapsto$
%%           \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env},
%%           $e_3 \mapsto$ \eval{\lstinline'p'}{\env}]
%%         )}
%%       )}
%%     )(e) \\
%%     &=&
%%     (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
%%       \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
%%         $e_2 \mapsto$ \eval{$t_2$}{\env},
%%         $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
%%         $e \mapsto$ \eval{\lstinline'p'}{\env}]
%%       )}
%%     )(e) \\
%%     &=&
%%     (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
%%       $e_2 \mapsto$ \eval{$t_2$}{\env},
%%       $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
%%       $e \mapsto$ \eval{\lstinline'p'}{\env},
%%       $k \mapsto$ (\eval{\lstinline'k'}{\env})+1]
%%     )(e) \\
%%     &=& \eval{\lstinline'p'}{\env} \\
%%     &=& \eval{\lstinline'e'}{\env} $\land$ \eval{\lstinline'p'}{\env} \\
%%     \multicolumn{3}{c}{\eval{\lstinline'e'}{\env} est vrai sinon on
%%       n'exécuterait pas le code de la boucle} \\
%%   \end{tabular}

%%   Développons le membre droit :

%%   \begin{tabular}{p{5cm} p{.5cm} p{9cm}}
%%     \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{
%%       (\comp{
%%         $I_3 \cdot \mbox{\lstinline'e = e_3;'}
%%         \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
%%       }{
%%         (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
%%           $e_2 \mapsto$ \eval{$t_2$}{\env},
%%           $e \mapsto$
%%           \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
%%       })
%%     }
%%     &=&
%%     \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{
%%       (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
%%         $e_2 \mapsto$ \eval{$t_2$}{\env},
%%         $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
%%         $e \mapsto$ \eval{\lstinline'p'}{\env},
%%         $k \mapsto$ (\eval{\lstinline'k'}{\env})+1])
%%     } \\
%%     &=& \eval{\lstinline'\\forall integer z; t_1 <= z < k+1 ==> p'}{\env} \\
%%     &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= k ==> p'}{\env} \\
%%     &=&
%%     \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env} \newline
%%     $\land$ \eval{\lstinline'\\forall integer z; z == k ==> p'}{\env} \\
%%     &=&
%%     \eval{\lstinline'e'}{\env}
%%     $\land$ \eval{\lstinline'\\forall integer z; z == k ==> p'}{\env} \\
%%     &=& \eval{\lstinline'e'}{\env} $\land$ \eval{\lstinline'p'}{\env} \\
%%     \multicolumn{3}{c}{car \eval{\lstinline'p'}{\env} est la valeur de $p$ pour
%%     le $k$ courant} \\
%%   \end{tabular}

%%   Le deuxième invariant est donc lui aussi maintenu après chaque itération.
%% \end{proof}
