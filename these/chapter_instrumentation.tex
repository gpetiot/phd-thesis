
\chapter{Traduction en C des Annotations pour le Test}
\label{sec:traduction}

\chapterintro

Ce chapitre présente une transformation d'un programme C annoté avec \eacsl en
un programme C, appelé programme instrumenté, dans lequel les annotations
\eacsl du programme initial ont été traduites en fragments de programme C
ajoutés au programme initial.
Ces fragments mettent en \oe{}uvre les annotations \eacsl afin de générer des
tests satisfaisant ou violant ces annotations.

Le programme instrumenté est analysé dynamiquement par un générateur de tests
structurels qui prend en entrée des programmes C.
L'instrumentation permet de l'utiliser pour détecter des erreurs dans les
programmes C annotés sans que cet outil n'ait à traiter les annotations dans
leur format d'origine.
Il détecte ces erreurs par analyse du code C produit par l'instrumentation.

Dans la partie~\ref{sec:process} nous présentons les principes de la traduction
des programmes annotés définis par la syntaxe présentée au chapitre précédent.
Ensuite nous détaillons les règles de traduction des annotations \eacsl en code
C.
Les règles de traduction pour les annotations sont décrites dans la
partie~\ref{sec:annot}.
Elles reposent sur les règles de traduction des termes et des prédicats, qui
sont détaillées dans les parties~\ref{sec:term} et~\ref{sec:pred}.
Nous discutons dans la partie~\ref{sec:rac} les différences et les
similitudes entre l'instrumentation pour la génération de tests et
l'instrumentation pour la validation à l'exécution.

Nous donnons également une justification de correction des règles de
traduction.
Nous voulons notamment nous assurer que si une erreur est trouvée par le
générateur de tests alors y a une inconsistance entre le code et sa
spécification.

Pour atteindre cet objectif, nous montrons que l'exécution du code inséré par
la traduction d'un terme, d'un prédicat ou d'une annotation a pour effet de
calculer la même valeur que la valeur de ce terme, ce prédicat ou cette
annotation évalués à leur place dans le programme initial.
Pour cela, nous nous basons sur la sémantique dénotationnelle des instructions
définie au chapitre précédent.
Cette justification est présentée en partie~\ref{sec:justif}.


\section{Processus de transformation de programmes}
\label{sec:process}


Cette partie présente le processus d'instrumentation des fonctions C annotées
avec le langage d'annotations \eacsl pour la génération de tests.
Elle l'illustre sur l'exemple donné dans le listing~\ref{lst:normalized} au
chapitre précédent.


\subsection{Principes généraux de la traduction}
\label{sec:principles}


Présentons maintenant les principes de la traduction d'une fonction annotée
respectant la grammaire de la figure~\ref{fig:gram-c} du
chapitre~\ref{sec:lang}.

Le programme instrumenté obtenu après traduction des annotations de la fonction
du listing~\ref{lst:normalized} est présenté dans le listing~\ref{lst:abbrv}.
Les principes de la traduction sont illustrés par des extraits de ce listing,
au fur et à mesure de leur présentation.

Pour simplifier la lecture des insertions de code générées par la traduction,
nous utilisons la notation abrégée ${}^{\square}$\lstinline'var' pour indiquer
que la variable \lstinline'var' doit être déclarée et allouée
au début de la portion de code insérée, et la notation
\lstinline'var'${}^{\boxtimes}$ pour indiquer que la variable \lstinline'var' doit
être désallouée à la fin du code inséré.
Nous soulignons les opérations (affectation, comparaison, \dots) qui utilisent
l'arithmétique non bornée (par opposition à l'arithmétique modulaire), et
doivent être traduites en utilisant une bibliothèque comme GMP afin de conserver
la sémantique de l'arithmétique entière non bornée d'\eacsl et de pouvoir
raisonner sur les débordements d'entiers.
La partie~\ref{sec:integers} illustre la détection de débordements d'entiers par
GMP.


\lstinputlisting[style=c,escapechar=§,caption={Version instrumentée du programme
    du listing~\ref{lst:normalized}},label=lst:abbrv]
                {listings/is_present_instrumented.c}


Durant le processus d'instrumentation, chaque fonction C est considérée
indépendamment des autres.
Les fonctions sont traduites dans l'ordre dans lequel elles apparaissent dans le
programme.
Pour chacune de ces fonctions, les annotations \eacsl sont également considérées
dans l'ordre dans lequel elles apparaissent.

Nous associons un label à chaque annotation -- qui caractérise sa position dans
le programme initial et l'endroit où elle doit être évaluée -- ce qui nous
donne une paire $(label, annotation)$.
Chacune de ces paires est traduite en une séquence
d'\emph{insertions de code} dénotée par :
$(l_1, c_1) \concat (l_2, c_2) \concat \ldots \concat (l_n, c_n)$.
Elle représente une liste de fragments de programmes C $c_1, c_2, \ldots, c_n$
où le fragment $c_i$ sera inséré dans le programme instrumenté au label $l_i$.
Si plusieurs fragments ont le même label (et doivent donc être insérés au
même endroit), ils sont insérés dans le programme instrumenté en respectant leur
ordre dans la séquence.

Les fragments de programmes -- ou insertions de code -- sont les instructions
nécessaires à l'évaluation d'une annotation, d'un prédicat ou d'un terme
\eacsl.
Ces insertions de code générées à partir des annotations sont placées
dans une séquence d'insertions de code globale.

\textbf{Sauvegarde des valeurs  au début de la fonction.}
Indépendamment de la traduction des annotations, un traitement particulier est
effectué pour chaque fonction, nous permettant de faire référence à la valeur
du terme \lstinline'\old(x)' si \lstinline'x' est une variable globale ou un
paramètre formel de la fonction.
En effet, chaque valeur d'entrée \lstinline'x' (un paramètre formel de la
fonction ou une variable globale) de type $T$ est mémorisée par
une instruction \lstinline'T old_x = x;' au début de la fonction
instrumentée, c'est-à-dire au label $Beg_{\mbox{\lstinline'f'}}$, dans la section
\textit{instr}$^{*}$.
Pour chaque tableau ou pointeur \lstinline'x', les valeurs pointées sont
mémorisées dans un tableau alloué dynamiquement \lstinline'old_val_x' dont la
taille est inférée à partir du prédicat \lstinline'\valid' dont on suppose la
présence en précondition de la fonction à traduire.
Dans l'exemple du listing~\ref{lst:abbrv}, les valeurs des paramètres formels
\lstinline't', \lstinline'n' et \lstinline'v' de la fonction
\lstinline'is_present' sont mémorisées lignes 3--5, un
nouveau tableau \lstinline'old_val_t' stocke les anciennes valeurs contenues
dans \lstinline't', il est alloué ligne 3, rempli ligne 5 et désalloué ligne 35.

\textbf{Traduction des annotations.}
Une fois ce pré-traitement effectué, toute annotation \eacsl de la forme
\lstinline'kwd w' (où \lstinline'kwd' $\in$ \bopen \lstinline'assert',
\lstinline'requires', \lstinline'typically', \lstinline'ensures',
\lstinline'loop variant', \lstinline'loop invariant', \lstinline'assigns',
\lstinline'loop assigns' \bclose et \lstinline'w' est un terme ou un prédicat)
est traduite.
D'autres constructions \eacsl ne sont pas détaillées ici car elles peuvent être
réduites au fragment \eacsl considéré.
Par exemple, un \lstinline'behavior' est réécrit dans la forme normalisée des
programmes comme une implication dans une clause \lstinline'ensures' et les
contrats d'instruction peuvent être réécrits comme des implications dans des
assertions.

\input{figures/fig_code_gen}

\input{figures/fig_code_ins}

Les figures~\ref{fig:code-gen} et~\ref{fig:code-ins} illustrent la traduction
d'un invariant de boucle \lstinline'loop invariant x<y' à un label de boucle
$l$.
La figure~\ref{fig:code-gen} montre quelles insertions de code sont générées
pour chaque composant de l'annotation.
Les insertions nécessaires à l'évaluation du prédicat \lstinline'x < y' au
label $l$ et au label $\mathit{EndIter_l}$ apparaissent en partie gauche de la
figure.
$(\mathbb{Z})\mbox{\lstinline'x'}$ explicite la conversion (qui est implicite
dans la suite) du terme \lstinline'x' (qui est une variable du programme et est
donc du type \lstinline'int' ou autre type C) vers le type logique
\lstinline'integer'.
Les symboles dénotés \insertball[fill=gray!40,xshift=-1mm,yshift=1mm]{n}
désignent les fragments de code et font le lien entre les deux parties de la
figure.
La partie droite de la figure montre la séquence d'insertions, étiquetées par
des labels, obtenue après traduction complète de l'invariant de boucle.
La figure~\ref{fig:code-ins} illustre le principe d'insertion des fragments de
code de la figure~\ref{fig:code-gen}, qui produit le programme instrumenté en
appliquant les règles d'insertion décrites ci-dessus.


Maintenant que le principe général de la traduction a été présenté, revenons
sur celle de la fonction du listing~\ref{lst:normalized}.
Chaque annotation du listing~\ref{lst:normalized} est traduite en une séquence
d'insertions de code.
La première précondition à la ligne 1 (listing~\ref{lst:normalized}) est
traduite à la ligne 6 du listing~\ref{lst:abbrv}.
La seconde précondition à la ligne 2 (listing~\ref{lst:normalized}) est
traduite à la ligne 7 du listing~\ref{lst:abbrv}.
La clause \lstinline'typically' de la ligne 3 du listing~\ref{lst:normalized}
est traduite ligne 8 du listing~\ref{lst:abbrv}.
L'invariant de boucle de la ligne 9 du listing~\ref{lst:normalized} est traduit
aux lignes 10--12 du listing~\ref{lst:abbrv} pour vérifier que l'invariant est
vrai avant la première itération (établissement), et aux lignes 19--23 du
listing~\ref{lst:abbrv} pour vérifier la préservation de l'invariant après
chaque itération.
Le variant de boucle ligne 10 du listing~\ref{lst:normalized} est traduit aux
lignes 15--16 du listing~\ref{lst:abbrv} pour vérifier que le variant est
positif ou nul avant chaque itération de la boucle et aux lignes 24--25 du
listing~\ref{lst:abbrv} pour vérifier que le
variant décroît strictement après chaque itération, assurant ainsi la
terminaison de la boucle.
La postcondition des lignes 4--5 du listing~\ref{lst:normalized} est traduite
aux lignes 29--34 du listing~\ref{lst:abbrv}.

La traduction d'annotations est définie par les règles de la
partie~\ref{sec:annot}.
Cela requiert de traduire les termes et les prédicats \eacsl.
Ces transformations sont décrites par les règles des parties~\ref{sec:term}
et~\ref{sec:pred}.
Dans ces règles, les notations supplémentaires suivantes sont utilisées :
\begin{itemize}
\item $c_1$, $c_2$, $c_i$ et $c_n$ sont des fragments de programmes C;
\item $l$, $l_1$, $l_2$, $l_i$, $l_n$, $\mathit{Beg_f}$, $\mathit{End_f}$,
  $\mathit{BegIter_l}$ et $\mathit{EndIter_l}$ sont des labels du programme;
\item $i$ et $k$ sont des identificateurs de variables liées
  dans un prédicat \eacsl et un compteur d'itérations dans un programme C;
\item $x$ est un identificateur de variable C (donc une left-value);
\item $I$, $I_1$, $I_2$ et $I_3$ sont des listes d'insertions de code
  $(l_i, c_i)^*$;
\item $y$ et $z$ sont des left-values;
\item $i$, $i_1$, $i_2$ sont des instructions C;
\item $P$ est un programme C annoté et $P'$ est le programme instrumenté
  obtenu après traduction du programme $P$.
\end{itemize}

Les variables \lstinline'res', \lstinline'var_'$n$, \lstinline'i_'$n$,
\lstinline'old_'$x$ et \lstinline'old_val_'$x$ sont
``fraîches'' (fresh), c'est-à-dire que ces identificateurs sont supposés
différents de tous les autres identifiants de variables du programme instrumenté
: quand on utilise plusieurs fois une règle introduisant une variable fraîche,
toutes les occurrences de la variable créée doivent être différentes.
Ceci peut être implémenté en incrémentant le compteur $n$ à chaque
occurrence dans \lstinline'var_'$n$ et \lstinline'i_'$n$, et en utilisant le nom
de la variable d'origine à la place de $x$ dans \lstinline'old_'$x$ et
\lstinline'old_val_'$x$.

Pour des raisons de commodité, nous supposons que toutes les variables logiques
liées dans les annotations et toutes les variables du programme sont
différentes, ceci nous permet en particulier de traduire les variables logiques
en C sans les renommer.


\subsection{Arithmétique non bornée}
\label{sec:integers}


\lstinputlisting[style=c,escapechar=§,caption={Propriétés des entiers : faux
    négatif dû à une traduction naïve},label=lst:Z:1]
                {listings/naive_false_negative.c}

\lstinputlisting[style=c,caption={Propriétés des entiers : faux positif dû à
    une traduction naïve},label=lst:Z:2]
                {listings/naive_false_positive.c}


Les listings~\ref{lst:Z:1} et~\ref{lst:Z:2} montrent deux exemples où
une traduction naïve des annotations contenant des entiers mathématiques mène
à un résultat incorrect.
Soit \lstinline'x' de type \lstinline'int'.
L'assertion ligne 1 du listing~\ref{lst:Z:1} est fausse lorsque
\lstinline'x = INT_MAX'.
La traduction naïve de cette assertion (ligne 3) utilise les entiers machine
avec arithmétique modulaire (supposons une architecture 32 bits), donc
\lstinline'x+1' reste inférieur ou égal à \lstinline'INT_MAX' pour toute valeur
de \lstinline'x', rendant tout échec de l'assertion impossible.
La traduction correcte pour cette annotation (lignes 6--9) conserve la
sémantique de l'arithmétique entière non bornée en utilisant une bibliothèque
externe (nous avons choisi GMP, la bibliothèque GNU Multi-Precision) pour
représenter les valeurs pouvant provoquer un débordement d'entier (ici
\lstinline'INT_MAX+1').
Les variables nécessaires pour la gestion des entiers non bornés sont créées et
initialisées, puis le résultat est calculé et les comparaisons sont faites en
tant qu'entier non borné.
Le second exemple (listing~\ref{lst:Z:2}) définit une assertion \eacsl (ligne 2)
qui est toujours correcte : pour tout entier positif \lstinline'x', son
successeur est aussi positif.
Une traduction naïve de cette annotation (ligne 3) génèrera une erreur à
l'exécution pour \lstinline'x = INT_MAX' : en arithmétique modulaire
\lstinline'x+1' déborde et devient négatif, violant l'assertion ligne 2.
Une traduction correcte utilisant les entiers non bornés (non présentée ici)
conserve le comportement attendu : l'assertion est vraie pour tout entier
positif \lstinline'x'.
D'une traduction naïve des annotations dans ces deux exemples résulterait un
faux négatif dans le premier cas et un faux positif dans le deuxième cas, ce
qui porterait atteinte à la correction et à la précision de notre méthode.
Les règles de traduction pour les constructions \eacsl que nous présentons
respectent la sémantique des entiers non bornés d'\eacsl et suppose
l'utilisation d'une bibliothèque externe telle GMP, comme illustré dans le
listing~\ref{lst:Z:1}.



\section{Traduction des annotations \eacsl}
\label{sec:annot}


Définissons maintenant les règles de traduction des
annotations, qui permettent de mettre en évidence les échecs d'annotation.
Pour chaque annotation, un fragment de programme C se terminant par le test
d'une expression par la fonction \lstinline'fassert' est inséré dans le
programme.
Le générateur de tests essaiera de couvrir tous les chemins d'exécution
faisables, donc s'il existe des entrées permettant de rendre fausse
l'expression de \lstinline'fassert', une erreur sera trouvée et un cas de test
la produisant sera donné.

\input{figures/fig_rules_annot}

La figure~\ref{fig:annot} décrit les règles de traduction pour les assertions
(\textsc{$\alpha$-assert}), les préconditions (\textsc{$\alpha$-check-pre} et
\textsc{$\alpha$-assume-pre}), les clauses \lstinline'assigns'
(\textsc{$\alpha$-check-assigns}) et les postconditions
(\textsc{$\alpha$-check-post}).
La règle \textsc{$\alpha$-assert} vérifie simplement avec la fonction
\lstinline'fassert' la valeur \lstinline'e' de la traduction du prédicat
\lstinline'p' au label $l$.
La règle \textsc{$\alpha$-check-pre} vérifie avec la fonction
\lstinline'fassert' la valeur \lstinline'e' de la traduction du prédicat
\lstinline'p' au début de la fonction instrumentée.
La règle \textsc{$\alpha$-assume-pre} traite la précondition de la fonction sous
test, qui est supposée vraie par définition.
Cette même règle permet de traduire les clauses \lstinline'typically'
(précondition pour le test qui permet de limiter l'explosion combinatoire du
nombre de chemins du programme) et les clauses \lstinline'requires', elle
suppose avec la fonction \lstinline'fassume' que la valeur \lstinline'e' de la
traduction du prédicat \lstinline'p' au début de la fonction est vraie.
La règle \textsc{$\alpha$-check-assigns} vérifie que les left-values qui ne sont
pas dans une clause \lstinline'assigns' ne sont pas modifiées par la fonction.
L'ensemble des left-values considérées est la différence $G-X$, où $G$ est
l'ensemble des left-values dans le contexte courant et $X$ est l'ensemble des
left-values de la clause \lstinline'assigns'.
Dans cette règle, l'expression suivante :
\[
\forall (x:\mathit{ctype}) \in G-X :
((Beg_f, \mathit{ctype}~\mbox{\lstinline'var_'}x = x\semicolon)
\concat (End_f, \mbox{\lstinline'fassert(x == var_'}x\mbox{\lstinline');'}) )
\]
dénote la liste d'insertions de fragments de code contenant ces deux fragments
de code $\mathit{ctype}~\mbox{\lstinline'var_'}x = x\semicolon$ et
$\mbox{\lstinline'fassert(x == var_'}x\mbox{\lstinline');'}$ pour chaque
left-value $x$ de $G-X$.
Le premier fragment sauvegarde la valeur de $x$ dans \lstinline'var_'$x$ au
début de la fonction, le second fragment vérifie que leur valeur de $x$ n'a pas
été modifiée en fin de fonction.
La règle \textsc{$\alpha$-check-post} vérifie la validité de la postcondition
à la fin de la fonction instrumentée.

\input{figures/fig_rules_loop_annot}

La figure~\ref{fig:loop-annot} présente les règles de traduction pour les
invariants de boucle (\textsc{$\alpha$-check-invariant}), les variants de boucle
(\textsc{$\alpha$-variant}) et les loop assigns
(\textsc{$\alpha$-check-loop-assigns}) pour une boucle au label $l$.
La règle \textsc{$\alpha$-check-loop-assigns} vérifie que les left-values qui ne
sont pas dans la clause \lstinline'loop assigns' ne sont pas modifiées par la
boucle.
Pour chacune de ces left-values, une sauvegarde de leur valeur courante est
faite au début de chaque itération, puis on vérifie que leur valeur n'a pas été
modifiée en fin de boucle.
La règle \textsc{$\alpha$-check-invariant} vérifie le prédicat de l'invariant
avant la boucle et après chaque itération de la boucle.
La règle \textsc{$\alpha$-variant} vérifie que le terme variant est non-négatif
au début de chaque itération.
Enfin, on vérifie à la fin de chaque itération que le variant décroît
strictement (par rapport à sa valeur au début de l'itération).



\section{Traduction des termes \eacsl}
\label{sec:term}


La fonction de traduction des termes, notée $\tau$, est définie comme une
fonction partielle qui, à un label $l$ et un terme \lstinline't' de type $T$,
associe une séquence d'insertions de code $(l_i, c_i)^*$ et une expression C
dénotée \lstinline'e' :

\[
(l, \mbox{\lstinline't'}:T) \rulearrow
(\underbracket{(l_1, c_1) \concat (l_2, c_2) \concat \ldots
  \concat (l_n, c_n)}_{I : \text{ liste d'insertions de code}}, \mbox{\lstinline'e'})
\]

Les instances de cette fonction sont définies par les
figures~\ref{fig:const-id}, \ref{fig:coerce}, \ref{fig:op} et~\ref{fig:builtin},
ces figures présentent les règles permettant de traduire les termes du langage
\eacsl considéré.
$T$ peut être $\mathbb{Z}$ (\lstinline'integer'), un type pointeur quelconque
(\lstinline'int*', \lstinline'char*', etc.) noté $ptr$ ou un type scalaire du C
(\lstinline'char', \lstinline'int', \lstinline'long', etc.) noté $ctype$.
Les insertions de code sont les instructions C nécessaires à l'évaluation du
terme.
Elles permettent notamment d'évaluer les sous-termes dont est composé le terme
\lstinline't'.
L'expression \lstinline'e' est pure (elle ne provoque pas d'effet de bord) et
correspond à l'évaluation du terme \lstinline't' au point de programme $l$.
L'évaluation de \lstinline'e' requiert le plus souvent plusieurs opérations,
qui sont effectuées par les fragments de programme qui résultent de la
traduction du terme et seront insérés aux endroits adéquats dans le programme
instrumenté.
Par exemple, un terme quantifié (comme une somme : \lstinline'\sum') a besoin de
plusieurs instructions pour être évalué, et notamment d'une boucle (voir la
figure~\ref{fig:builtin}).
Dans ce cas, le second élément \lstinline'e' de la paire retournée est la
variable calculée par la boucle.
Quand un terme $t$ peut être traduit directement sans nécessiter de code C
supplémentaire, la séquence d'insertions de code est vide et notée $\emptylist$.
Pour un terme $t:\mathbb{Z}$, le résultat de traduction $e$ est toujours une
variable de type \lstinline'Z_t' (ce qui justifie une désallocation
\lstinline{e}${}^{\boxtimes}$, voir figure~\ref{fig:coerce}).

\input{figures/fig_rules_const_id}

La figure~\ref{fig:const-id} présente les règles de traduction pour les
identificateurs de variable (\textsc{$\tau$-var}), pour le terme
\lstinline'\result' (\textsc{$\tau$-res}) et pour les constantes
(\textsc{$\tau$-const}).
Deux règles sont nécessaires pour traduire la construction \eacsl
\lstinline'\old'.
Appliquée à un identificateur $x$ (règle \textsc{$\tau$-old}), le terme est
traduit en variable fraîche \lstinline'old_'$x$ qui contient la valeur de $x$ au
début de la fonction.
Appliquée à un accès mémoire (règle \textsc{$\tau$-old-val}), on utilise le
tableau alloué dynamiquement \lstinline'old_val_'$x$ qui contient les valeurs du
tableau ou pointeur $x$ au début de la fonction (se référer à la
partie~\ref{sec:principles}).
Le terme \lstinline'\result' est traduit par la règle \textsc{$\tau$-res}, il
fait référence à la valeur de retour de la fonction en \eacsl qui, par la
normalisation, est désignée par la variable \lstinline'res'.
Cette variable est unique dans chaque fonction après normalisation de l'arbre de
syntaxe abstraite par \framac.
La règle \textsc{$\tau$-const} établit qu'une variable entière est définie pour
prendre la valeur d'une contante entière.

\input{figures/fig_rules_coerce}

La figure~\ref{fig:coerce} détaille les règles de conversions implicites, de
\lstinline'integer' vers le type C \lstinline'int' et du type C \lstinline'int'
vers \lstinline'integer'.

\input{figures/fig_rules_op}

La figure~\ref{fig:op} détaille les règles pour les opérations unaires
(\textsc{$\tau$-lv} et \textsc{$\tau$-unop}), les opérations binaires
(\textsc{$\tau$-binop$_{j}$}) et la condition ternaire sur les termes
(\textsc{$\tau$-if}).
\textsc{$\tau$-lv} traite le cas de l'indirection de pointeur
(\lstinline'*').
\textsc{$\tau$-unop} traite le cas du moins unaire et du complément
bit-à-bit ($\sim$) pour lesquels on suppose que ces opérations prennent un
\lstinline'integer' en entrée et en sortie.

\textsc{$\tau$-binop$_1$} traite l'arithmétique de pointeur, l'opérande gauche
est un pointeur, $binop$ doit être \lstinline'+' ou \lstinline'-', et l'opérande
droite est de type \lstinline'int'.
\textsc{$\tau$-binop$_2$} traite les opérations arithmétiques entières (les
opérandes et le résultat sont des entiers), $binop$ est un des opérateurs
arithmétiques suivants : \lstinline'+', \lstinline'-', \lstinline'/',
\lstinline'%', \lstinline'*'.
Dans la règle \textsc{$\tau$-if}, les évaluations de $t_2$ et $t_3$ sont dans
des branches conditionnelles : on calcule paresseusement l'un des deux, en
fonction de l'évaluation de $t_1$.
La notation suivante :
\[
(l,
\mbox{\lstinline'if('}
\underline{\mbox{\lstinline'e1'}\Zclear \mbox{\lstinline' \!= 0'}}
\mbox{\lstinline')'} \bopen
I_2
\concat
(l, \underline{\Zinit \mbox{\lstinline'var_n = e2'} \Zclear}
\semicolon )
\bclose
\mbox{\lstinline'else'} \bopen
I_3
\concat
(l, \underline{\Zinit \mbox{\lstinline'var_n = e3'} \Zclear}
\semicolon )
\bclose )
\]
signifie que les blocs du \lstinline'if' et du \lstinline'else' contiendront,
après l'étape d'insertion (voir partie~\ref{sec:principles}), les instructions à
insérer au label $l$ obtenues à partir des fragments de code de $I_2$ et $I_3$
respectivement.
Dans la suite cette notation sera utilisée pour chaque conditionnelle
\lstinline'if' et chaque boucle \lstinline'while' générée par les règles de
traduction.

\input{figures/fig_rules_builtin}

La figure~\ref{fig:builtin} présente les règles de traduction pour les fonctions
logiques \lstinline'\sum' (\textsc{$\tau$-sum}) et \lstinline'\numof'
(\textsc{$\tau$-numof}).
\lstinline'\sum(t1, t2, \lambda integer k; t3)' calcule la somme généralisée
$\sum_{\mbox{\lstinline'k = t1'}}^{\mbox{\lstinline't2'}}\mbox{\lstinline't3'}$.
La règle \textsc{$\tau$-sum} permet de calculer cette somme.
Elle initialise une variable entière fraîche \lstinline'var_n' à $0$ et
l'incrémente avec la valeur du \lstinline'\lambda'-terme \lstinline't3' à chaque
itération.
\lstinline'\product(t1, t2, \lambda integer k; t3)' calcule le produit
généralisé $\Pi_{\mbox{\lstinline'k = t1'}}^{\mbox{\lstinline't2'}}\mbox{\lstinline't3'}$.
La règle permettant de calculer ce produit n'est pas donnée mais est similaire à
la règle \textsc{$\tau$-sum} et peut être facilement dérivée à partir de
celle-ci.
\lstinline'\numof(t1, t2, \lambda integer k; t3)' calcule le nombre de
\lstinline'k' tel que
$\mbox{\lstinline't1'} \le \mbox{\lstinline'k'} \le \mbox{\lstinline't2'}$ et
$\mbox{\lstinline't3'} \neq 0$.
La règle \textsc{$\tau$-numof} permet de traduire ce terme.
Elle initialise une variable entière fraîche \lstinline'var_n' à $0$ et
incrémente sa valeur quand le \lstinline'\lambda'-terme \lstinline't3' (non
entier) s'évalue en une expression non nulle.


\section{Traduction des prédicats \eacsl}
\label{sec:pred}


De manière similaire à la fonction de traduction $\tau$ pour les termes
(partie~\ref{sec:term}), la fonction de traduction des prédicats, notée $\pi$,
est définie comme une fonction partielle qui, à un label et un prédicat \eacsl
\lstinline'p', associe une séquence d'insertions de code $(l_i, c_i)^*$ et une
expression $\mbox{\lstinline'e'} \in \{0, 1\}$ du langage C (que nous encoderons
dans un \lstinline'int') :

\[
(l, \mbox{\lstinline'p'}) \rulearrow
(\underbracket{(l_1, c_1) \concat (l_2, c_2) \concat \ldots
  \concat (l_n, c_n)}_{I : \text{ liste d'insertions de code}}, \mbox{\lstinline'e'})
\]

Les insertions de code sont les instructions C nécessaires à l'évaluation du
prédicat, elles permettent notamment d'évaluer les termes et prédicats
auxiliaires dont est composé le prédicat \lstinline'p'.
Quand un prédicat \lstinline'p' peut être traduit directement et ne nécessite
pas la création d'instructions C, la séquence d'insertions est vide et notée
$\emptylist$.

Nous définissons dans les figures~\ref{fig:pred-logic}, \ref{fig:valid}
et~\ref{fig:quantif} les règles de traduction pour les principaux
prédicats \eacsl que nous traitons.
Pour chacune de ces règles, une variable fraîche \lstinline'var_n' est générée
(même quand la traduction du prédicat est triviale) afin de standardiser les
règles et ainsi de faciliter la justification de leur correction des règles.

\input{figures/fig_rules_pred}

La figure~\ref{fig:pred-logic} détaille les règles de traduction pour les
prédicats les plus simples du langage \eacsl.
Les règles \textsc{$\pi$-true} et \textsc{$\pi$-false} indiquent que
\lstinline'\true' (respectivement \lstinline'\false') se traduit en $1$
(respectivement $0$).
Les règles \textsc{$\pi$-equiv} et \textsc{$\pi$-not} sont compositionnelles :
les prédicats fils sont traduits récursivement, puis le résultat de la
traduction est construit à partir des valeurs des prédicats fils.
Les règles \textsc{$\pi$-and}, \textsc{$\pi$-or} et \textsc{$\pi$-impl}
reflètent l'évaluation paresseuse de ces opérateurs selon la sémantique d'\eacsl
: le premier opérande est toujours évalué (en $I_1$) mais le deuxième n'est
évalué (en $I_2$) que si nécessaire.
La règle \textsc{$\pi$-if} est similaire à \textsc{$\tau$-if} (voir
partie~\ref{sec:term}).
Dans l'exemple du listing~\ref{lst:normalized}, la traduction de la
postcondition
\lstinline{\result != 0 <==> \exists integer i; 0<=i<n && *(t+i)==v} requiert
la traduction des prédicats \lstinline'\result != 0' et
\lstinline{\exists(...)} qui sont respectivement traduits en \lstinline'var_32'
et \lstinline'var_35'.
Ces deux prédicats sont assemblés pour construire la traduction du prédicat
composé, d'après la règle \textsc{$\pi$-equiv},:
\lstinline'(!var_32 || var_35) && (!var_35 || var_32)' (line 33 du
listing~\ref{lst:abbrv}).
Dans la règle \textsc{$\pi$-rel}, $rel$ est un des opérateurs relationnels
suivants : \lstinline[style=c]'<, <=, >, >=, ==, !='.

\input{figures/fig_rules_valid}

La figure~\ref{fig:valid} montre les règles de traduction pour le prédicat
\lstinline'\valid', qui est vrai si le pointeur en argument pointe vers une
case mémoire valide et peut être déréférencé.
\lstinline'\valid(t)' exprime la validité d'un seul pointeur et
\lstinline'\valid(t1+(t2..t3))' exprime la validité du pointeur \lstinline't1'
dans l'intervalle d'offsets \lstinline't2..t3', ce qui veut dire que
\lstinline'(t1+t2)', \lstinline'(t1+t2+1)' \dots, \lstinline'(t1+t3)' sont
valides.
Les règles \textsc{$\pi$-valid} et \textsc{$\pi$-valid-range} couvrent les deux
cas.
Le support de ces prédicats nécessite une représentation précise de la mémoire
du programme, la réalisation de telles fonctions est abordée dans le
chapitre~\ref{sec:runtime}.
Dans notre exemple du listing~\ref{lst:normalized}, le prédicat
\lstinline'\valid(t+(0..n-1))' de la clause \lstinline'requires' de la ligne 2
est traduit en \lstinline[style=c]'fvalidr(t,0,(n-1))' (ligne 7 du
listing~\ref{lst:abbrv}).

\input{figures/fig_rules_quantif}

Dans la figure~\ref{fig:quantif}, la règle \textsc{$\pi$-forall} traite de la
traduction du prédicat universel \lstinline'\forall', quantifié sur les entiers.
Le code généré met à jour une variable \lstinline'var_n' (initialisée à $true$)
à chaque itération de boucle, jusqu'à ce que toutes les valeurs de \lstinline'k'
soient considérés ou que \lstinline'var_n' soit évalué à $false$.
La règle \textsc{$\pi$-exists} (figure~\ref{fig:quantif}) aborde la traduction
du prédicat existentiel \lstinline'\exists', quantifié sur les entiers.
Le code généré met à jour une variable \lstinline'var_n' (initialement $false$)
à chaque itération de la boucle, jusqu'à ce que toutes les valeurs de
\lstinline'k' soient considérées ou que \lstinline'var_n' soit évalué à $true$.
Dans le listing~\ref{lst:normalized}, le prédicat
\lstinline{\exists integer i; 0<=i<n && *(t+i)==v} de la ligne 4 est traduit
aux lignes 29--33 du listing~\ref{lst:abbrv} et la variable fraîche contenant la
valeur du prédicat après évaluation est \lstinline'var_35' (déclarée à la
ligne 31).





\section[Test vs. Validation à l'Exécution]{Similarités et Différences selon
  l'objectif, Test vs. Validation à l'Exécution}
\label{sec:rac}


La traduction d'annotations \eacsl en code C a été implémentée dans deux
greffons \framac : \eacsltoc \cite{Delahaye/SAC13,Kosmatov/RV13} et \stady
\cite{Petiot/TAP14,Petiot/SCAM14}.
Le premier génère un programme instrumenté pour la validation d'assertions à
l'exécution, le second génère un programme instrumenté pour la génération de
tests avec \pathcrawler \cite{\citepathcrawler}.
Cette partie discute les similarités et les différences entre ces deux façons
d'instrumenter.

La traduction pour la validation à l'exécution et la traduction pour la
génération de tests ont toutes deux besoin de générer du code exécutable, c'est
pourquoi un sous-ensemble exécutable du langage de spécification est considéré
dans les deux cas.
La plupart des règles définies dans les parties~\ref{sec:term},
\ref{sec:pred} et \ref{sec:annot} sont autant valables pour la validation à
l'exécution que pour le test, le code généré devant être correct vis-à-vis de la
sémantique des annotations.
Cependant, il y a plusieurs différences liées à la différence d'objectif.
Les quatre différences sont :
\begin{itemize}
\item la manière de considérer la précondition de la fonction sous test;
\item la manière de traiter les annotations liées au modèle mémoire;
\item la manière de traiter les fonctions sur les entiers mathématiques;
\item et la manière de traiter les potentielles erreurs à l'exécution
  introduites par les fragments de code résultant de la traduction.
\end{itemize}


\textbf{Précondition de la fonction sous test.}
Une première différence est le traitement de la précondition de la fonction sous
test.
En vérification à l'exécution, elle est vérifiée comme n'importe quelle autre
annotation.
En génération de tests, la précondition est utilisée pour éviter de tester le
programme avec des valeurs d'entrées incorrectes, pour lesquelles le bon
fonctionnement du programme n'est pas garanti.
La précondition de la fonction sous test est donc supposée vraie pour la
génération de tests, afin de s'assurer que toutes les entrées générées par le
test satisfont cette précondition.

\textbf{Annotations liées au modèle mémoire.}
La validation à l'exécution nécessite une instrumentation complexe pour traiter
les constructions \eacsl liées au modèle mémoire comme \lstinline'\valid',
\lstinline'\block_length', \lstinline'\base_addr', etc.
Chaque opération affectant la mémoire doit être instrumentée et les informations
de chaque case mémoire doivent être enregistrées afin de pouvoir évaluer ces
annotations \cite{Kosmatov/RV13}.
Nous aborderons les spécificités d'une telle instrumentation dans le
chapitre~\ref{sec:runtime}.
Certaines de ces constructions peuvent être traitées symboliquement en test
concolique sans nécessiter de traduction spécifique dans le code C.
C'est ce que nous faisons ici en supposant la définition de fonctions C
\lstinline'fvalid' et \lstinline'fvalidr' supportées par le générateur de tests,
qui retournent la valeur de validité du pointeur en argument si celui-ci est
une variable globale ou un paramètre formel de la fonction sous test
\cite{Chebaro/ICSSEA12}.

\textbf{Arithmétique non bornée.}
Tandis que l'utilisation d'une bibliothèque externe d'arithmétique non bornée
(comme GMP) pour traduire les entiers d'\eacsl est appropriée pour la validation
à l'exécution, il n'en est pas de même pour la génération de tests :
si le code des fonctions de la bibliothèque est analysé par le
générateur de tests, alors cette solution se révèlera inefficace.
En effet, la génération de tests à partir du programme instrumenté aura à
traiter un code beaucoup plus compliqué, avec de nombreux appels de fonctions, 
des allocations/désallocations dynamiques, etc.
Ceci peut être évité en exécutant symboliquement les fonctions de la
bibliothèque : \pathcrawler offre un support dédié aux fonctions de la
bibliothèque GMP, dont les opérations sont traduites efficacement en contraintes
sur les entiers non bornés, que le solveur de contraintes sous-jacent peut
traiter.

\textbf{Erreurs à l'exécution.}
La traduction d'annotations en C peut introduire des erreurs à l'exécution dues
aux termes dont la sémantique est indéfinie dans les annotations, comme
\lstinline'1/0'.
Ce problème peut être évité pour la génération de tests (comme proposé dans
\cite{Delahaye/SAC13} pour la validation à l'exécution), en utilisant le greffon
\rte \cite{\citeframac} sur le code résultant de l'instrumentation.
Celui-ci ajoute des gardes supplémentaires et il suffit ensuite de
ré-instrumenter le programme en tenant compte de ces nouvelles annotations.
Les erreurs à l'exécution liées aux entiers non bornés (division d'un entier
GMP par $0$, débordement pendant une conversion
\lstinline[mathescape=true]{(int)(t:$\mathbb{Z}$)}, etc.) ne sont pas traités
par \rte mais ces erreurs peuvent être évitées en ajoutant les gardes
nécessaires aux règles de traduction.
Par exemple, le cast d'un terme $t$ d'\lstinline'integer' vers \lstinline'int'
(voir la règle \textsc{$\tau$-coerce$_1$} de la figure~\ref{fig:coerce}) peut
être gardé en ajoutant
\lstinline{fassert(}\underline{\lstinline{INT\_MIN <= e}}\lstinline{ && }
\underline{\lstinline{e <= INT\_MAX}}\lstinline{)} avant l'affectation
\underline{\lstinline'var_n = e'}.


\section{Justification de Correction de la Traduction}
\label{sec:justif}


Nous ne détaillons pas les justifications de toutes les constructions.
Nous avons choisi un échantillon représentatif du langage formé, des constantes
pour les termes, des conjonctions pour les prédicats, des assertions, des
contrats de boucle et des contrats de fonction.
Les propriétés que nous vérifions sont définies en partie~\ref{sec:properties}.
Les parties~\ref{sec:term-translation}, \ref{sec:predicate-translation} et
\ref{sec:annotation-translation} justifient la correction de ces propriétés
respectivement sur les termes, sur les prédicats et sur les annotations.


\subsection{Propriétés de l'instrumentation}
\label{sec:properties}


Définissons maintenant les propriétés exprimant la correction de la traduction,
c'est-à-dire que le code instrumenté a la même sémantique que le code annoté
dont il est issu.

Ces propriétés se décomposent en deux parties qui sont la préservation des
erreurs et l'inclusion des mémoires.

\begin{myproperty}[Préservation des erreurs]
  \label{th:error}
  Pour toute mémoire $\mem$, si l'exécution des instructions obtenues
  par traduction d'une annotation $a$
  du programme $P$ provoque une erreur dans le programme instrumenté $P'$ par
  cette traduction de $a$, alors l'annotation $a$ est invalide.
\end{myproperty}

La préservation des erreurs (propriété~\ref{th:error}) assure l'absence de faux
positifs lors de la génération de tests sur le programme instrumenté,
c'est-à-dire que toute erreur détectée par la génération de tests correspond à
une erreur du programme annoté.


\begin{myproperty}[Inclusion des mémoires]
  \label{th:inclusion}
  Soit le fragment de programme $A$ obtenu à partir d'une liste d'insertions de
  code $I$.
  Soit une mémoire quelconque $(\env, \store)$.
  Pour tout préfixe $B$ de $A$ tel que :
  $(\env', \store')$ = \comps{$B$}{$(\env, \store)$} alors
  $\env \subenv \env'$ et $\store \subenv \store'$
\end{myproperty}

\begin{myproperty}[Absence d'erreur]
  \label{lem:noerror}
  Soit le fragment de programme $A$ obtenu à partir d'une liste d'insertions de
  code $I$.
  Soit une mémoire quelconque $\mem$.
  Pour tout préfixe $B$ de $A$ tel que :
  $\mem'$ = \comps{$B$}{$\mem$} alors
  $\mem' \neq \errormem$
\end{myproperty}

\begin{definition}[Point d'exécution associé]
  \label{def:exec-point}
  Soit un compteur de programme $c_P$ du programme source $P$, incrémenté de 1 à
  chaque exécution d'instruction.
  Soit un compteur de programme $c_{P'}$ du programme instrumenté $P'$,
  incrémenté de 1 à chaque instruction de $P'$ qui est une instruction de $P$.
  Un point d'exécution du programme source est associé à un point d'exécution du
  programme instrumenté si et seulement si $c_P = c_{P'}$.
\end{definition}

L'inclusion des mémoires (propriété~\ref{th:inclusion}) est un lemme
nécessaire à la justification de la propriété~\ref{th:error}.
Il énonce que les seules variables modifiées dans les instructions ajoutées dans
le programme instrumenté sont les variables fraîchement créées par la
traduction, les variables existantes dans le programme d'origine ne sont pas
modifiées par la traduction.
Il affirme que si toutes les annotations d'un programme $P$ sont valides, à
chaque point d'exécution de $P$ la mémoire $(\env, \store)$ produite par
l'exécution du programme $P$ est incluse dans la mémoire $(\env', \store')$
produite par l'exécution du programme instrumenté $P'$ au point d'exécution
associé (voir définition~\ref{def:exec-point}) :
$\env \subenv \env'$ et $\store \subenv \store'$.

Dans les sections~\ref{sec:term-translation} et~\ref{sec:predicate-translation}
nous déclinons ces propriétés sur les termes et sur les prédicats.
Dans la section~\ref{sec:annotation-translation} nous justifions les
propriétés~\ref{th:error} et~\ref{th:inclusion} à partir des propriétés prouvées
dans les sections~\ref{sec:term-translation} et~\ref{sec:predicate-translation}.


\subsection{Justification de la correction de la Traduction des Termes}
\label{sec:term-translation}

Afin de prouver la correction de la traduction des prédicats et des annotations,
nous devons prouver la correction de la traduction des termes.

\begin{myproperty}[Correction de la Traduction des Termes]
  \label{lem:term-correct}
  Soit \lstinline't' : $\tau$ un terme de type $\tau$ au label $l$ qui est
  traduit par le couple $(I, \mbox{\lstinline'e'})$ où $I$ est une liste
  d'insertions de code et \lstinline'e' l'expression donnant la valeur du terme
  \lstinline't'.
  La traduction est correcte si le fragment de programme $A$ obtenu à partir de
  $I$ et exécuté à partir d'une mémoire quelconque $\mem$ donne une
  mémoire $\mem'$ = \comps{$A$}{$\mem$}, telle que :
  \eval{\lstinline't'}{$\mem$} = \eval{\lstinline'e'}{$\mem'$}.
\end{myproperty}

La propriété~\ref{lem:term-correct} est la déclinaison sur les termes de la
propriété~\ref{th:error}.
La propriété~\ref{lem:term-correct} énonce que l'évaluation des insertions de
code $I$ générées lors de la traduction d'un terme \lstinline't' ajoute une
nouvelle variable \lstinline'e' (fraîche) à la mémoire courante, dont la valeur
correspond à l'évaluation de \lstinline't' dans la mémoire $\mem$.
Les variables qui sont déjà dans la mémoire initiale ne sont pas
impactées dans la mémoire résultante (propriété~\ref{th:inclusion}), et
la mémoire résultant de la traduction du terme n'est pas la mémoire d'erreur
$\errormem$ (propriété~\ref{lem:noerror}).
Ces propriétés sont vérifiées par la traduction de chaque terme.
Elles nous permettent de prouver la propriété~\ref{th:error}.
Pour ne pas alourdir ce chapitre, la preuve est uniquement fournie pour la règle
\textsc{$\tau$-const} de traduction des constantes.


\subsubsection{Justification de correction de la Traduction des Constantes}

Rappelons la règle de traduction des constantes :

{\myinference{$\tau$-const}
  {}
  { (l, \mbox{\lstinline'cst'} : \mathbb{Z}) \rulearrow
    ((l, \Zinit\underline{\mbox{\lstinline'var_n = cst;'}}),
    \mbox{\lstinline'var_n'}) }{}
}

Les propriétés~\ref{th:inclusion}, \ref{lem:noerror} et~\ref{lem:term-correct}
sont déclinées ainsi sur le cas de la constante :

Propriété~\ref{lem:term-correct}. \eval{\lstinline'cst'}{$\mem$} =
\eval{\lstinline'var_n'}{
  (\comps{$\Zinit$\underline{\lstinline'var_n = cst;'}}{$\mem$})}.


Propriété~\ref{th:inclusion}.
$\env \subenv \env'$ et $\store \subenv \store'$ où
 $(\env', \store') =$
\comps{$\Zinit$\underline{\lstinline'var_n = cst;'}}{$(\env, \store)$}.


Propriété~\ref{lem:noerror}.
\comps{$\Zinit$\underline{\lstinline'var_n = cst;'}}{$\mem$}
$\neq \errormem$.

Nous les justifions une à une :

\begin{proof}[Justification de la propriété~\ref{lem:term-correct}.]~\\
  Nous transformons le membre droit en une expression identique au membre gauche
  en appliquant les règles de sémantique dénotationnelle et de définition des
  mémoires :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \eval{\lstinline'var_n'}{
        (\comps{$\Zinit$\underline{\lstinline'var_n = cst;'}
        }{$(\env, \store)$})}
    }\\ 
    &$\eq{\eqlabel{C-Z-set}}$&
    \eval{\lstinline'var_n'}{
      ($\env$[\lstinline'var_n' $\mapsto \loc]$,
      $\store$[$\loc \mapsto$
        \eval{\lstinline'cst'}{$(\env, \store)$}])} \\
    && où $\loc$ est une adresse fraîche \\
    &$\eq{\eqlabel{E-lval}}$&
    $\store$[$\loc \mapsto$
      \eval{\lstinline'cst'}{$(\env, \store)$}]
    (
    $\env$[\lstinline'var_n' $\mapsto \loc]$
    (\lstinline'var_n')
    )\\
    &$\eq{\eqlabel{env-get-1}}$&
    $\store$[$\loc \mapsto$
      \eval{\lstinline'cst'}{$(\env, \store)$}]
    ($\loc$)\\
    &$\eq{\eqlabel{store-get-1}}$&
    \eval{\lstinline'cst'}{$(\env, \store)$} \\
  \end{tabular}
  ~\\
\end{proof}


\begin{proof}[Justification de la propriété~\ref{th:inclusion}.]~\\
  L'instruction générée $\Zinit$\underline{\lstinline'var_n = cst;'} ne modifie
  que la variable fraîche \lstinline'var_n'.
  Le nouvel environnement est
  $\env' = \env[$\lstinline'var_n' $\mapsto \loc]$
  et le nouveau store est
  $\store' = \store[\loc \mapsto$ \eval{\lstinline'cst'}{$(\env, \store)$}$]$.
  On peut donc en conclure $\env \subenv \env'$ et $\store \subenv \store'$.
  ~\\
\end{proof}


\begin{proof}[Justification de la propriété~\ref{lem:noerror}.]~\\
  La nouvelle mémoire est
  $(\env[$\lstinline'var_n' $\mapsto \loc],$
  $\store[\loc \mapsto$ \eval{\lstinline'cst'}{$(\env, \store)$}$])$.
  Ce n'est pas une mémoire d'erreur car l'évaluation d'une constante ne produit
  pas d'erreur.
  On a donc bien
  \comps{$\Zinit$\underline{\lstinline'var_n = cst;'}}{$\mem$} $\neq \errormem$.
  ~\\
\end{proof}


\subsection{Justification de correction de la Traduction des Prédicats}
\label{sec:predicate-translation}


Afin de prouver la correction de la traduction des annotations,
nous devons prouver la correction de la traduction des prédicats.

\begin{myproperty}[Correction de la Traduction des Prédicats]
  \label{lem:pred-correct}
  Soit \lstinline'p' un prédicat au label $l$ qui est
  traduit par le couple $(I, \mbox{\lstinline'e'})$ où $I$ est une liste
  d'insertions de code et \lstinline'e' l'expression donnant la valeur du
  prédicat \lstinline'p'.
  La traduction est correcte si le fragment de programme $A$ obtenu à partir de
  $I$ et exécuté à partir d'une mémoire quelconque $\mem$ donne une
  mémoire $\mem'$ = \comps{$A$}{$\mem$} telle que :
  \eval{\lstinline'p'}{$\mem$} = \eval{\lstinline'e'}{$\mem'$}.
\end{myproperty}

La propriété~\ref{lem:pred-correct} est la déclinaison sur les prédicats de la
propriété~\ref{th:error}.
La propriété~\ref{lem:pred-correct} énonce que l'évaluation des insertions de
code $I$ générées lors de la traduction d'un prédicat \lstinline'p' ajoute une
nouvelle variable \lstinline'e' (fraîche) à la mémoire, dont la
valeur correspond à l'évaluation de \lstinline'p' dans $\mem$.
Les variables qui sont déjà dans la mémoire initiale ne sont pas
impactées dans la mémoire résultante (propriété~\ref{th:inclusion}), et
la mémoire résultant de la traduction du prédicat n'est pas la mémoire
d'erreur $\errormem$ (propriété~\ref{lem:noerror}).
Ces propriétés sont vérifiées par la traduction de chaque prédicat.
Elles nous permettent de prouver la propriété~\ref{th:error}.
Pour des raisons de lisibilité, la justification est uniquement fournie pour la
règle \textsc{$\pi$-and}.% et \textsc{$\pi$-forall} (en annexe).


\subsubsection{Justification de correction de la Traduction des Conjonctions}

La règle de traduction du prédicat de conjonction \textsc{$\pi$-and} est
définie ainsi :

{\myinference{$\pi$-and}
  { (l, \mbox{\lstinline'p1'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
    (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'}) }
  { (l, \mbox{\lstinline'p1 && p2'}) \rulearrow
    (I_1 \cdot (l, \mbox{\lstinline'int var_n = e1;'}) \cdot
    (l, \mbox{\lstinline'if(var_n)'} \bopen I_2 \cdot
    (l, \mbox{\lstinline'var_n = e2;'}) \bclose ),
    \mbox{\lstinline'var_n'})
  }{}
}~\\

Les propriétés~\ref{th:inclusion}, \ref{lem:noerror} et~\ref{lem:pred-correct}
sont déclinées ainsi sur le cas de la conjonction :

Propriété~\ref{lem:pred-correct}.\\
\eval{\lstinline'p1 && p2'}{$\mem$} =
\eval{\lstinline'var_n'}{(
  \comps{$A_1\semicolon~ \mbox{\lstinline' int var_n = e1;'}
    \mbox{\lstinline'if(var_n)'} \bopen A_2\semicolon~
    \mbox{\lstinline' var_n = e2;'} \bclose$
  }{$\mem$}
  )}
en admettant que le fragment de programme
$A_1\semicolon~ \mbox{\lstinline' int var_n = e1;'}
\mbox{\lstinline'if(var_n)'} \bopen A_2\semicolon~
\mbox{\lstinline' var_n = e2;'} \bclose$
est obtenu à partir des listes d'insertions
$I_1 \cdot (l, \mbox{\lstinline'int var_n = e1;'}) \cdot
(l, \mbox{\lstinline'if(var_n)'} \bopen I_2 \cdot
(l, \mbox{\lstinline'var_n = e2;'}) \bclose )$.

Propriété~\ref{th:inclusion}.\\
$\env \subenv \env'$ et $\store \subenv \store'$ où
$(\env', \store')$ =
\comps{$A_1\semicolon~ \mbox{\lstinline' int var_n = e1;'}
  \mbox{\lstinline'if(var_n)'} \bopen A_2\semicolon~
  \mbox{\lstinline' var_n = e2;'} \bclose$
}{$(\env, \store)$}.

Propriété~\ref{lem:noerror}.\\
\comps{$A_1\semicolon~ \mbox{\lstinline' int var_n = e1;'}
  \mbox{\lstinline'if(var_n)'} \bopen A_2\semicolon~
  \mbox{\lstinline' var_n = e2;'} \bclose$
}{$\mem$} $\neq \errormem$.

Nous les justifions une à une :

\begin{proof}[Justification de la propriété~\ref{lem:pred-correct}.]~\\
  Par hypothèse, les traductions de \lstinline'p1' et \lstinline'p2' sont
  correctes, c'est-à-dire :

  \begin{center}
    \begin{tabular}{rclr}
      \eval{\lstinline'p1'}{$\mem$}
      &=& \eval{\lstinline'e1'}{(\comps{$A_1$}{$\mem$})} & \eqlabel{h1} \\
      \eval{\lstinline'p2'}{$\mem$}
      &=& \eval{\lstinline'e2'}{(\comps{$A_2$}{$\mem$})} & \eqlabel{h2} \\
    \end{tabular}
  \end{center}

  Nous transformons le membre droit en une expression identique au membre gauche
  en appliquant les règles de sémantique dénotationnelle et de définition des
  mémoires :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \eval{\lstinline'var_n'}{(
        \comps{$A_1\semicolon~ \mbox{\lstinline' int var_n = e1;'}
          \mbox{\lstinline'if(var_n)'} \bopen A_2\semicolon~
          \mbox{\lstinline' var_n = e2;'} \bclose$
        }{$\mem$}
        )}
    } \\
    &=& \eval{\lstinline'var_n'}{(\comps{$\mbox{\lstinline' int var_n = e1;'}
        \mbox{\lstinline'if(var_n)'} \bopen A_2\semicolon~
        \mbox{\lstinline' var_n = e2;'} \bclose$}{(\comps{$A_1$}{$\mem$})})} \\
    &$\eq{\eqlabel{C-decl} \circ \eqlabel{C-set}}$
    & \eval{\lstinline'var_n'}{(\comps{
        \lstinline'if(var_n)' $\bopen A_2\semicolon~
        \mbox{\lstinline' var_n = e2;'} \bclose$}{
        $(\env'[$\lstinline'var_n' $\mapsto \loc],$
        $\store'[\loc \mapsto$ \eval{\lstinline'e1'}{$\mem'$} $])$
      }
      )
    } \\
    && où $(\env', \store') = \mem' = $ \comps{$A_1$}{$\mem$}
    et $\loc$ est une adresse fraîche. \\
  \end{tabular}

  (a) Cas où la valeur de l'expression conditionnelle \lstinline'var_n' est
  vraie, soit \eval{\lstinline'e1'}{(\comps{$A_1$}{$\mem$})} = true,
  c'est-à-dire par hypothèse \eqlabel{h1} : \eval{\lstinline'p1'}{$\mem$} =
  true.
  Dans ce cas, par définition de \eqlabel{C-if} on exécute le bloc
  $A_2\semicolon~ \mbox{\lstinline' var_n = e2;'}$ :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \comps{
        \lstinline'if(var_n)' $\bopen A_2\semicolon~
        \mbox{\lstinline' var_n = e2;'} \bclose$}{
        $(\env'[$\lstinline'var_n' $\mapsto \loc],$
        $\store'[\loc \mapsto$ \eval{\lstinline'e1'}{$\mem'$} $])$
      }
    } \\
    &$\eq{\eqlabel{C-if}}$& \comps{
      $A_2\semicolon~\mbox{\lstinline' var_n = e2;'}$}{
      $(\env'[$\lstinline'var_n' $\mapsto \loc],$
      $\store'[\loc \mapsto$ \eval{\lstinline'e1'}{$\mem'$} $])$
    } \\
    &=& \comp{
      \lstinline' var_n = e2;'
    }{$\underbracket{
        \mbox{
          (\comps{$A_2$}{
            $(\env'[$\lstinline'var_n' $\mapsto \loc],$
            $\store'[\loc \mapsto$ \eval{\lstinline'e1'}{$\mem'$} $])$
          })
        }
      }_{\mem_f}$
    } \\
    &$\eq{\eqlabel{C-set}}$
    & $(\env_f, \store_f[\env_f($\lstinline'var_n'$) \mapsto$ \eval{
        \lstinline'e2'}{$\mem_f$}$])$
    où $\mem_f = (\env_f, \store_f)$ \\
    &$\eq{\eqlabel{env-get-1}}$
    & $(\env_f, \store_f[\loc \mapsto$ \eval{\lstinline'e2'}{$\mem_f$}$])$
    car $\env_f($\lstinline'var_n'$) = \loc$. \\
  \end{tabular}

  Donc :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \eval{\lstinline'var_n'}{
        $(\env_f, \store_f[\loc \mapsto$ \eval{\lstinline'e2'}{$\mem_f$}$])$
      }
    } \\
    &$\eq{\eqlabel{E-lval}}$
    &$\store_f[\loc \mapsto$ \eval{\lstinline'e2'}{
        $\mem_f$}$](\env_f($\lstinline'var_n'$))$ \\
    &$\eq{\eqlabel{env-get-1}}$
    &$\store_f[\loc \mapsto$ \eval{\lstinline'e2'}{$\mem_f$}$](\loc)$ \\
    &$\eq{\eqlabel{store-get-1}}$
    &\eval{\lstinline'e2'}{$\mem_f$}\\
    &=
    &\eval{\lstinline'e2'}{
      (\comps{$A_2$}{
        $(\env'[$\lstinline'var_n' $\mapsto \loc],$
        $\store'[\loc \mapsto$ \eval{\lstinline'e1'}{$\mem'$} $])$
      })
    }\\
    &$\eq{\eqlabel{h2}}$& \eval{\lstinline'p2'}{$\mem$} \\
    &=& \eval{\lstinline'p1'}{$\mem$} $\land$ \eval{\lstinline'p2'}{$\mem$}
         {\scriptsize
           (car on est dans le cas \eval{\lstinline'p1'}{$\mem$} = true)} \\
         &$\eq{\eqlabel{P-and}}$& \eval{\lstinline'p1 \&\& p2'}{$\mem$} \\
  \end{tabular}

  (b) Cas où la valeur de l'expression conditionnelle \lstinline'var_n' est
  fausse, soit \eval{\lstinline'e1'}{(\comps{$A_1$}{$\mem$})} = false,
  c'est-à-dire par hypothèse \eqlabel{h1} : \eval{\lstinline'p1'}{$\mem$} =
  false.
  Dans ce cas, par définition de \eqlabel{C-if} on exécute le bloc du
  \lstinline'else' (qui ici est vide et n'apparaît pas car facultatif) :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \comps{
        \lstinline'if(var_n)' $\bopen A_2\semicolon~
        \mbox{\lstinline' var_n = e2;'} \bclose$}{
        $(\env'[$\lstinline'var_n' $\mapsto \loc],$
        $\store'[\loc \mapsto$ \eval{\lstinline'e1'}{$\mem'$} $])$
      }
    } \\
    &$\eq{\eqlabel{C-if}}$
    & $(\env'[$\lstinline'var_n' $\mapsto \loc],$
    $\store'[\loc \mapsto$ \eval{\lstinline'e1'}{$\mem'$} $])$ \\
  \end{tabular}

  Donc :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \eval{\lstinline'var_n'}{
        $(\env'[$\lstinline'var_n' $\mapsto \loc],$
        $\store'[\loc \mapsto$ \eval{\lstinline'e1'}{$\mem'$} $])$
      }
    } \\
    &$\eq{\eqlabel{E-lval}}$
    &$\store'[\loc \mapsto$ \eval{\lstinline'e1'}{$\mem'$} $]$
    $(\env'[$\lstinline'var_n' $\mapsto \loc] ($
    \lstinline'var_n'
    $))$ \\
    &$\eq{\eqlabel{env-get-1}}$
    &$\store'[\loc \mapsto$ \eval{\lstinline'e1'}{$\mem'$} $](\loc)$ \\
    &$\eq{\eqlabel{store-get-1}}$
    &\eval{\lstinline'e1'}{$\mem'$} \\
    &=&\eval{\lstinline'e1'}{(\comps{$A_1$}{$\mem$})} \\
    &$\eq{\eqlabel{h1}}$& \eval{\lstinline'p1'}{$\mem$} \\
    &=& \eval{\lstinline'p1'}{$\mem$} $\land$ \eval{\lstinline'p2'}{$\mem$} {
      \scriptsize
      (car on est dans le cas \eval{\lstinline'p1'}{$\mem$} = false)} \\
    &$\eq{\eqlabel{P-and}}$& \eval{\lstinline'p1 \&\& p2'}{$\mem$} \\
  \end{tabular}
  
  On a donc bien :

  \eval{\lstinline'p1 && p2'}{$\mem$} =
  \eval{\lstinline'var_n'}{(
    \comps{$A_1\semicolon~ \mbox{\lstinline' int var_n = e1;'}
      \mbox{\lstinline'if(var_n)'} \bopen A_2\semicolon~
      \mbox{\lstinline' var_n = e2;'} \bclose$
    }{$\mem$}
    )}.
  ~\\
\end{proof}


\begin{proof}[Justification de la propriété~\ref{th:inclusion}.]~\\
  Par hypothèse, les traductions de \lstinline'p1' et \lstinline'p2' sont
  correctes, c'est-à-dire :

  \begin{center}
    \begin{tabular}{lr}
      $\env \subenv \env_1$ & \eqlabel{h3} \\
      $\store \subenv \store_1$
      où $(\env_1, \store_1) = $ \comps{$A_1$}{$(\env, \store)$}
      & \eqlabel{h4} \\
      $\env \subenv \env_2$ & \eqlabel{h5} \\
      $\store \subenv \store_2$
      où $(\env_2, \store_2) = $ \comps{$A_2$}{$(\env, \store)$}
      & \eqlabel{h6} \\
    \end{tabular}
  \end{center}

  De manière informelle, les instructions générées \lstinline'int var_n = e1;'
  et \lstinline'var_n = e2;' ne modifient que la variable fraîche
  \lstinline'var_n' et les hypothèses \eqlabel{h3} à \eqlabel{h6} nous assurent
  que les blocs $A_1$ et $A_2$ ne modifient pas les variables de
  la mémoire $\mem = (\env, \store)$.
  On en conclut donc que le fragment de programme instrumenté
  $A_1\semicolon~ \mbox{\lstinline' int var_n = e1;'}
  \mbox{\lstinline'if(var_n)'} \bopen A_2\semicolon~
  \mbox{\lstinline' var_n = e2;'} \bclose$
  ne modifie pas la mémoire $\mem$.
  On a donc bien :

  $\env \subenv \env'$ et $\store \subenv \store'$ où
  $(\env', \store')$ =
  \comps{$A_1\semicolon~ \mbox{\lstinline' int var_n = e1;'}
    \mbox{\lstinline'if(var_n)'} \bopen A_2\semicolon~
    \mbox{\lstinline' var_n = e2;'} \bclose$
  }{$(\env, \store)$}.
~\\
\end{proof}


\begin{proof}[Justification de la propriété~\ref{lem:noerror}.]~\\
  Par hypothèse, les traductions de \lstinline'p1' et \lstinline'p2' sont
  correctes, c'est-à-dire :

  \begin{center}
    \begin{tabular}{rclr}
      \comps{$A_1$}{$\mem$} & $\neq$ & $\errormem$ & \eqlabel{h7} \\
      \comps{$A_2$}{$\mem$} & $\neq$ & $\errormem$ & \eqlabel{h8} \\
    \end{tabular}
  \end{center}

  Les hypothèses \eqlabel{h7} et \eqlabel{h8} et le fait que les fragments de
  code générés ne produisent pas d'erreur (seule la variable fraîche
  \lstinline'var_n' est affectée) nous assurent que si $\mem$ n'est pas une
  mémoire d'erreur ($\mem$ ne peut pas être $\errormem$ puisque la
  traduction se serait arrêtée dès l'obtention de l'erreur).
  On a donc bien :

  \comps{$A_1\semicolon~ \mbox{\lstinline' int var_n = e1;'}
    \mbox{\lstinline'if(var_n)'} \bopen A_2\semicolon~
    \mbox{\lstinline' var_n = e2;'} \bclose$
  }{$\mem$} $\neq \errormem$.
~\\
\end{proof}


\subsection{Justification de correction de la Traduction des Annotations}
\label{sec:annotation-translation}


Nous allons maintenant prouver les propriétés~\ref{th:error} et
\ref{th:inclusion} pour chaque classe d'annotations : les assertions, les
contrats de boucle et les contrats de fonction.
Ces justifications s'appuient sur la correction de la traduction des termes et
des prédicats justifiée dans les parties précédentes.


\subsection{Justification de correction de la Traduction des Assertions}

La règle de traduction d'une annotation \lstinline'assert' est la suivante :

\begin{center}
{\myinference{$\alpha$-assert}
  {(l, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
  {(l, \mbox{\lstinline'assert p;'})
    \rulearrow I \concat (l, \mbox{\lstinline'fassert(e);'})}{}
}
\end{center}

Prouvons que pour tout environnement $\env${} :
\comp{\lstinline'/*@ assert p; */ ;'}{$\env$} = $\errormem$
si \comps{$A\semicolon~ \mbox{\lstinline'fassert(e);'}$}{$\env$} = $\errormem$
(propriété~\ref{th:error}),
où le fragment de programme $A$ est obtenu à partir de la séquence d'insertions
de code $I$ selon les règles d'insertion énoncées dans la
partie~\ref{sec:principles}.

Prouvons également que si l'\lstinline'assert' est valide :
$\env \subenv$ \comps{$A\semicolon~ \mbox{\lstinline'fassert(e);'}$}{$\env$}
(propriété~\ref{th:inclusion}).


\begin{proof}[Justification de la propriété~\ref{th:error}]~\\
  Par hypothèse, la traduction de \lstinline'p' est correcte, c'est-à-dire :

  \begin{tabular}{rclr}
    \eval{\lstinline'e'}{(\comps{$A$}{$\env$})} &=& \eval{\lstinline'p'}{$\env$}
    & \eqlabel{h1} \\
    \comps{$A$}{$\env$} & $\neq$ & $\errormem$ & \eqlabel{h2} \\
  \end{tabular}

  Supposons
  \comps{$A\semicolon~ \mbox{\lstinline'fassert(e);'}$}{$\env$} = $\errormem$
  (\eqlabel{h3}) et
  prouvons que \comp{\lstinline'/*@ assert p; */ ;'}{$\env$} = $\errormem$.

  (a) Cas où l'assertion est vraie, soit
  \eval{\lstinline'e'}{(\comps{$A$}{$\env$})} = true, c'est-à-dire par hypothèse
  \eqlabel{h1} : \eval{\lstinline'p'}{$\env$} = true.
  Développons \comps{$A\semicolon~ \mbox{\lstinline'fassert(e);'}$}{$\env$} :

  \begin{tabular}{rcl}
    \comps{$A\semicolon~ \mbox{\lstinline'fassert(e);'}$}{$\env$}
    &=& \comp{\lstinline'fassert(e);'}{(\comps{$A$}{$\env$})} \\
    &$\eq{\eqlabel{C-fassert}}$
    & \comps{$A$}{$\env$} {\scriptsize (car \eval{\lstinline'e'}{(\comps{$A$}{$\env$})} = true)} \\
  \end{tabular}

  D'autre part, l'hypothèse \eqlabel{h3} nous donne :
  \comps{$A\semicolon~ \mbox{\lstinline'fassert(e);'}$}{$\env$}
  = $\errormem$.

  On obtient par substitution :
  \comps{$A$}{$\env$} = $\errormem$, ce qui contredit l'hypothèse \eqlabel{h2} selon
  laquelle \comps{$A$}{$\env$} $\neq$ $\errormem$.

  (b) Cas où l'assertion est fausse, soit
  \eval{\lstinline'e'}{(\comps{$A$}{$\env$})} = false, c'est-à-dire par hypothèse
  \eqlabel{h1} : \eval{\lstinline'p'}{$\env$} = false.

  Développons \comp{\lstinline'/*@ assert p; */ ;'}{$\env$} :

  \begin{tabular}{rcl}
    \comp{\lstinline'/*@ assert p; */ ;'}{$\env$}
    &$\eq{\eqlabel{C-assert}}$
    & $\errormem${} {\scriptsize (car \eval{\lstinline'p'}{$\env$} = false)} \\
  \end{tabular}

  La propriété~\ref{th:error} est ainsi prouvée.
  ~\\
\end{proof}


\begin{proof}[Justification de la propriété~\ref{th:inclusion}]~\\
  Par hypothèse, la traduction de \lstinline'p' est correcte, c'est-à-dire :

  \begin{tabular}{rclr}
    $\env$ & $\subenv$ & \comps{$A$}{$\env$} & \eqlabel{h1} \\
  \end{tabular}

  Nous avons montré que si l'assertion est valide, alors
  \comps{$A\semicolon~ \mbox{\lstinline'fassert(e);'}$}{$\env$}
  = \comps{$A$}{$\env$}.
  Par substitution dans \eqlabel{h1}, on obtient :
  $\env \subenv$ \comps{$A\semicolon~ \mbox{\lstinline'fassert(e);'}$}{$\env$}.
  ~\\
\end{proof}


\subsection{Justification de correction de la Traduction des Contrats de
  Boucles}


Nous considérons une boucle complètement annotée avec
\lstinline'loop invariant', \lstinline'loop variant' et
\lstinline'loop assigns'.
La traduction utilise les trois règles suivantes :


{\scriptsize
  {\myinference{$\alpha$-check-loop-assigns}
    {}
    {
      \splitfrac {
        (l, \mbox{\lstinline'loop assigns X;'}) \rulearrow
      }{
        \splitfrac {
          I \concat
          \forall (\mbox{\lstinline'x'}:ctype) \in G-X:
          (BegIter_l, \mbox{\lstinline'ctype var_x = x;'})
        }{
          \concat (EndIter_l, \mbox{\lstinline'fassert(x == var_x);'})
        }
      }
    }{}
  }
}

{\scriptsize
  {\myinference{$\alpha$-check-invariant}
    {(l, \mbox{\lstinline'p'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
      (EndIter_l, \mbox{\lstinline'p'}) \rulearrow (I_2, \mbox{\lstinline'e2'})}
    {
      (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
      I_1 \concat (l, \mbox{\lstinline'fassert(e1);'})
      \concat I_2 \concat (EndIter_l, \mbox{\lstinline'fassert(e2);'})
    }{}
  }
}

{\scriptsize
  {\myinference{$\alpha$-variant}
    {
      (BegIter_l, \mbox{\lstinline't'}) \rulearrow (I_1, \mbox{\lstinline'e1'})
      \\
      (EndIter_l, \mbox{\lstinline't'}) \rulearrow (I_2, \mbox{\lstinline'e2'})
    }
    {
      \splitfrac{
        (l, \mbox{\lstinline'loop variant t;'}) \rulearrow
      }{
        I_1 \concat ((BegIter_l,
        \mbox{\lstinline'fassert('}
        \underline{\mbox{\lstinline'0 <= e1'}}
        \mbox{\lstinline');' })
        \concat I_2
        \concat(EndIter_l,
        \mbox{\lstinline'fassert('}
        \underline{\mbox{\lstinline'e2'}\Zclear
          \mbox{\lstinline'< e1'} \Zclear}
        \mbox{\lstinline');'})
      }
    }{}
  }
}


Donnons une intuition de la justification de correction de la traduction des
contrats de boucle à partir de ces règles.
La figure~\ref{fig:proof-loop-contract} illustre la démarche.
La partie gauche de la figure montre une boucle disposant d'un contrat de boucle
(\lstinline'loop invariant', \lstinline'loop assigns' et
\lstinline'loop variant') au label $l$, avec un corps quelconque $A$.
En partie droite est affiché le code résultant de la traduction de cette
boucle, où chaque ensemble d'instructions (regroupées avec une accolade) est
mis en relation avec l'annotation du programme original dont il est la
traduction.
$Spec2Code$\lstinline'('$I_1$\lstinline', e1)' est une notation signifiant que
\lstinline'p' se traduit en $(I_1, \mbox{\lstinline'e1'})$ en accord avec la
règle \textsc{$\alpha$-check-invariant}.

Si l'invariant (ligne 2) n'est pas établi avant la boucle, alors on obtient
l'environnement d'erreur (règle \eqlabel{C-while-1}), ce qui correspond aux
lignes 2--3 du code généré.
Si la condition de boucle (ligne 5) est fausse, l'environnement est inchangé
(règle \eqlabel{C-while-2}) car le code que nous générons n'impacte pas les
variables du programme original, donc la condition de boucle \lstinline'e' a la
même valeur en chaque point dans le programme original et le programme
instrumenté.
Si le variant de la boucle (ligne 4) est négatif au début de la boucle, on
obtient l'environnement d'erreur (règle \eqlabel{C-while-3}), ce qui correspond
aux lignes 9--10 du code généré.
Si l'invariant de boucle n'est pas préservé à la fin de l'itération de boucle,
l'environnement d'erreur est obtenu (règle \eqlabel{C-while-4}), ce qui
correspond aux lignes 13--14 du code généré.
Si le variant ne décroît pas strictement entre deux itérations de boucle, alors
l'environnement d'erreur est obtenu (règle \eqlabel{C-while-5}), ce qui
correspond aux lignes 18--19 (la comparaison est faite avec la valeur du variant
mémorisée à la ligne 9).
Si une left-value n'appartenant pas à la clause assigns (ligne 3) a été modifiée
par la boucle, alors l'environnement d'erreur est obtenu (règle
\eqlabel{C-while-6}), ce qui correspond aux lignes 6--8 (pour la sauvegarde des
valeurs) et 15--17 (pour les comparaisons) du code généré.


\input{figures/fig_proof_loop_contract}


\subsection{Justification de correction de la Traduction des Contrats de
  Fonctions}

Il nous faut distinguer deux cas : le
cas où la fonction est ``sous vérification'' -- c'est-à-dire où c'est la
fonction de plus haut niveau et sa précondition est supposée vraie -- et le cas
où la fonction est appelée -- et sa précondition doit être vérifiée au point
d'appel.
Nous traitons les deux cas de manière séparée dans les deux sous-parties
suivantes.


\subsubsection{Fonction sous vérification}


\input{figures/fig_proof_fct_contract_main}


Nous considérons une fonction \lstinline'f' sous vérification annotée avec
\lstinline'requires' (ou \lstinline'typically'), \lstinline'assigns' et
\lstinline'ensures'.
La traduction utilise les trois règles suivantes :

{\scriptsize
  {\myinference{$\alpha$-assume-pre\hspace{-2mm}}
    {(Beg_f, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
    {(Beg_f, \left \{\hspace{-2mm}
      \begin{array}{r}
        \mbox{\lstinline'typically'} \\
        \mbox{\lstinline'requires'}
      \end{array} \mbox{\lstinline'p;'} \right.
      )
      \rulearrow
      I \concat (Beg_f, \mbox{\lstinline'fassume(e);'})}{}
  }
}

{\scriptsize
  {\myinference{$\alpha$-check-assigns}
    {}
    {
      \splitfrac{
        (End_f, \mbox{\lstinline'assigns X;'}) \rulearrow
      } {
        I \concat
        \forall (\mbox{\lstinline'x'}:ctype) \in G-X:
        (Beg_f, \mbox{\lstinline'ctype var_x = x;'})
        \concat (End_f, \mbox{\lstinline'fassert(x == var_x);'})
      }
    }{}
  }
}

{\scriptsize
  {\myinference{$\alpha$-check-post}
    {(End_f, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
    {(End_f, \mbox{\lstinline'ensures p;'})
      \rulearrow
      I \concat (End_f, \mbox{\lstinline'fassert(e);'})}{}
  }
}


La figure~\ref{fig:proof-fct-contract-main}, illustre la justification de
correction
de la traduction des contrats pour la fonction sous vérification sur un schéma
générique normalisé de fonction.
La partie gauche de la figure montre une fonction \lstinline'f' disposant d'un
contrat, avec un corps quelconque $A$.
En partie droite est affichée le code résultant de la traduction de cette
fonction, où chaque ensemble d'instructions (regroupées avec une accolade) est
mis en relation avec l'annotation du programme original dont il est la
traduction.

Par hypothèse, la précondition de la fonction sous vérification est vraie, ce
qui correspond aux lignes 3--4 du code généré.
Si la fonction modifie une des left-values n'appartenant pas à la clause
assigns, alors l'environnement d'erreur est obtenu (règle \eqlabel{f-2}), ce qui
correspond aux lignes 5--7 et 10--12 du code généré.
Si la postcondition n'est pas vérifiée à la fin de la fonction, on obtient
l'environnement d'erreur (règle \eqlabel{f-3}), ce qui correspond aux lignes
13--14 du code généré.


\subsubsection{Fonctions appelées}

\input{figures/fig_proof_fct_contract_call}

Nous considérons une fonction \lstinline'f' appelée annotée avec
\lstinline'requires', \lstinline'assigns' et \lstinline'ensures'.
La traduction des contrats d'une fonction appelée réutilise les règles
\textsc{$\alpha$-check-assigns} et \textsc{$\alpha$-check-post} de la partie
précédente.
En revanche, afin de vérifier la précondition d'une fonction appelée et non la
supposer vraie, la règle \textsc{$\alpha$-assume-pre} est remplacée par la règle
suivante :

{\scriptsize
  {\myinference{$\alpha$-check-pre\hspace{-2mm}}
    {(Beg_f, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
    {(Beg_f, \mbox{\lstinline'requires p;'})
      \rulearrow
      I \concat (Beg_f, \mbox{\lstinline'fassert(e);'})}{}
  }
}

La figure~\ref{fig:proof-fct-contract-call}, illustre la justification de
correction
de la traduction des contrats pour la fonction sous vérification sur un exemple.
La partie gauche de la figure montre une fonction \lstinline'f' disposant d'un
contrat, avec un corps quelconque $A$.
En partie droite est affichée le code résultant de la traduction de cette
fonction, où chaque ensemble d'instructions (regroupées avec une accolade) est
mis en relation avec l'annotation du programme original dont il est la
traduction.

Si la précondition n'est pas vérifiée au début de la fonction, alors
l'environnement d'erreur est obtenu (règle \eqlabel{f-1}), ce qui correspond aux
lignes 3--4 du code généré.
Si la fonction modifie une des left-values n'appartenant pas à la clause
assigns, alors l'environnement d'erreur est obtenu (règle \eqlabel{f-2}), ce qui
correspond aux lignes 5--7 et 10--12 du code généré.
Si la postcondition n'est pas vérifiée à la fin de la fonction, on obtient
l'environnement d'erreur (règle \eqlabel{f-3}), ce qui correspond aux lignes
13--14 du code généré.


\section*{Conclusion du chapitre}

L'objectif de ce chapitre était de définir une traduction en C des annotations
\eacsl pour la génération de tests et de fournir une justification de la
correction de cette traduction.

Nous avons tout d'abord présenté le processus de la traduction dans sa
généralité.
Puis nous avons défini les règles permettant pour chaque terme et prédicat
\eacsl d'obtenir un code C calculant cette expression tout en préservant la
sémantique d'\eacsl.
Ces règles nous ont permis de définir différentes manières de traduire les
annotations \eacsl : \lstinline'assert', \lstinline'requires',
\lstinline'typically', \lstinline'assigns', \lstinline'ensures',
\lstinline'loop invariant', \lstinline'loop assigns' et
\lstinline'loop variant'.
Ces différentes instrumentations des annotations nous permettront par la suite
de détecter différentes erreurs dans le code et la spécification.

Grâce à notre justification de correction, nous pouvons assurer l'absence de
faux positifs lors de la génération de tests sur le programme instrumenté : si
une erreur est trouvée par la génération de tests alors il y a une erreur dans
le programme d'origine.
Cette propriété est énoncée comme une implication si l'on considère le langage
C et le langage \eacsl dans leur ensemble, mais si on se restreint au
sous-ensemble du langage décrit par la grammaire du chapitre précédent elle
s'énonce comme une équivalence, c'est-à-dire que toute erreur dans le programme
original est également trouvée par la génération de tests.

La justification de cette propriété est fournie de manière formelle pour les
assertions et de manière informelle mais intuitive pour les contrats de boucle
et les contrats de fonction.
