
\chapter{Traduction en C des Annotations pour le Test}
\label{sec:traduction}

\chapterintro

Ce chapitre présente une transformation d'un programme C annoté avec \eacsl en
un programme C, appelé programme instrumenté, dans lequel les annotations
\eacsl du programme initial ont été traduites en fragments de programme C
ajoutés au programme initial.
Ces fragments mettent en \oe{}uvre les annotations \eacsl afin de générer des
tests satisfaisant ou violant ces annotations.

Le programme instrumenté est analysé dynamiquement par un générateur de tests
structurels qui prend en entrée des programmes C.
L'instrumentation permet de l'utiliser pour détecter des erreurs dans les
programmes C annotés sans que cet outil n'ait à traiter les annotations dans
leur format d'origine.
Il détecte ces erreurs par analyse du code C produit par l'instrumentation.

Dans la partie~\ref{sec:process} nous présentons les principes de la traduction
des programmes annotés définis par la syntaxe présentée au chapitre précédent.
Ensuite nous détaillons les règles de traduction des annotations \eacsl en code
C.
Les règles de traduction pour les annotations sont décrites dans la
partie~\ref{sec:annot}.
Elles reposent sur les règles de traduction des termes et des prédicats, qui
sont détaillées dans les parties~\ref{sec:term} et~\ref{sec:pred}.
Nous discutons dans la partie~\ref{sec:rac} les différences et les
similitudes entre l'instrumentation pour la génération de tests et
l'instrumentation pour la validation à l'exécution.
Nous donnons une justification de correction des règles de traduction en
partie~\ref{sec:justif}.


\section{Processus de transformation de programmes}
\label{sec:process}


Cette partie présente le processus d'instrumentation des fonctions C annotées
avec le langage d'annotations \eacsl pour la génération de tests.
Elle l'illustre sur l'exemple donné dans le listing~\ref{lst:normalized} au
chapitre précédent.


\subsection{Principes généraux de la traduction}
\label{sec:principles}


Présentons maintenant les principes de la traduction d'une fonction annotée
respectant la grammaire de la figure~\ref{fig:gram-c} du
chapitre~\ref{sec:lang}.

Le programme instrumenté obtenu après traduction des annotations de la fonction
du listing~\ref{lst:normalized} est présenté dans le listing~\ref{lst:abbrv}.
Les principes de la traduction sont illustrés par des extraits de ce listing,
au fur et à mesure de leur présentation.

Pour simplifier la lecture des insertions de code générées par la traduction,
nous utilisons la notation abrégée ${}^{\square}$\lstinline'var' pour indiquer
que la variable \lstinline'var' doit être déclarée et allouée
au début de la portion de code insérée, et la notation
\lstinline'var'${}^{\boxtimes}$ pour indiquer que la variable \lstinline'var' doit
être désallouée à la fin du code inséré.
Nous soulignons les opérations (affectation, comparaison, \dots) qui utilisent
l'arithmétique non bornée (par opposition à l'arithmétique modulaire), et
doivent être traduites en utilisant une bibliothèque comme GMP afin de conserver
la sémantique de l'arithmétique entière non bornée d'\eacsl et de pouvoir
raisonner sur les débordements d'entiers.
La partie~\ref{sec:integers} illustre la détection de débordements d'entiers par
GMP.


\lstinputlisting[style=c,escapechar=§,caption={Version instrumentée du programme
    du listing~\ref{lst:normalized}},label=lst:abbrv]
                {listings/is_present_instrumented.c}


Durant le processus d'instrumentation, chaque fonction C est considérée
indépendamment des autres.
Les fonctions sont traduites dans l'ordre dans lequel elles apparaissent dans le
programme.
Pour chacune de ces fonctions, les annotations \eacsl sont également considérées
dans l'ordre dans lequel elles apparaissent.

Nous associons un label à chaque annotation -- qui caractérise sa position dans
le programme initial et l'endroit où elle doit être évaluée -- ce qui nous
donne une paire $(label, annotation)$.
Chacune de ces paires est traduite en une séquence
d'\emph{insertions de code} dénotée par :
$(l_1, c_1) \concat (l_2, c_2) \concat \ldots \concat (l_n, c_n)$.
Elle représente une liste de fragments de programmes C $c_1, c_2, \ldots, c_n$
où le fragment $c_i$ sera inséré dans le programme instrumenté au label $l_i$.
Si plusieurs fragments ont le même label (et doivent donc être insérés au
même endroit), ils sont insérés dans le programme instrumenté en respectant leur
ordre dans la séquence.

Les fragments de programmes -- ou insertions de code -- sont les instructions
nécessaires à l'évaluation d'une annotation, d'un prédicat ou d'un terme
\eacsl.
Ces insertions de code générées à partir des annotations sont placées
dans une séquence d'insertions de code globale.

\textbf{Sauvegarde des valeurs  au début de la fonction.}
Indépendamment de la traduction des annotations, un traitement particulier est
effectué pour chaque fonction, nous permettant d'obtenir la valeur
du terme \lstinline'\old(x)' si \lstinline'x' est une variable globale ou un
paramètre formel de la fonction.
En effet, chaque valeur d'entrée \lstinline'x' (un paramètre formel de la
fonction ou une variable globale) de type $T$ est mémorisée par
une instruction \lstinline'T old_x = x;' au début de la fonction
instrumentée, c'est-à-dire au label $Beg_f$.
Pour chaque tableau ou pointeur \lstinline'x', les valeurs pointées sont
mémorisées dans un tableau alloué dynamiquement \lstinline'old_val_x' dont la
taille est inférée à partir du prédicat \lstinline'\valid' dont on suppose la
présence en précondition de la fonction à traduire.
Dans l'exemple du listing~\ref{lst:abbrv}, les valeurs des paramètres formels
\lstinline't', \lstinline'n' et \lstinline'v' de la fonction
\lstinline'is_present' sont mémorisées lignes 3--4, un
nouveau tableau \lstinline'old_val_t' stocke les anciennes valeurs contenues
dans \lstinline't', il est alloué ligne 3, rempli ligne 5 et désalloué ligne 35.

\textbf{Traduction des annotations.}
Une fois ce pré-traitement effectué, toute annotation \eacsl de la forme
\lstinline'kwd w' (où \lstinline'kwd' $\in$ \bopen \lstinline'assert',
\lstinline'requires', \lstinline'typically', \lstinline'ensures',
\lstinline'loop variant', \lstinline'loop invariant', \lstinline'assigns',
\lstinline'loop assigns' \bclose et \lstinline'w' est un terme ou un prédicat)
est traduite.
%D'autres constructions \eacsl ne sont pas détaillées ici car elles peuvent être
%réduites au fragment \eacsl considéré.
%Par exemple, un \lstinline'behavior' est réécrit dans la forme normalisée des
%programmes comme une implication dans une clause \lstinline'ensures' et les
%contrats d'instruction peuvent être réécrits comme des implications dans des
%assertions.

\input{figures/fig_code_gen}

\input{figures/fig_code_ins}

Les figures~\ref{fig:code-gen} et~\ref{fig:code-ins} illustrent la traduction
d'un invariant de boucle \lstinline'loop invariant x<y' à un label de boucle
$l$.
La figure~\ref{fig:code-gen} montre quelles insertions de code sont générées
pour chaque composant de l'annotation.
Une séquence d'insertions vide est notée $\emptylist$.
Les insertions nécessaires à l'évaluation du prédicat \lstinline'x < y' au
label $l$ et au label $\mathit{EndIter_l}$ apparaissent en partie gauche de la
figure.
$(\mathbb{Z})\mbox{\lstinline'x'}$ explicite la conversion (qui est implicite
dans la suite) du terme \lstinline'x' (qui est une variable du programme et est
donc du type \lstinline'int' ou autre type C) vers le type logique
\lstinline'integer'.
Les séquences d'instructions numérotées
\insertball[fill=gray!40,xshift=-1mm,yshift=1mm]{n} désignent les fragments de
code et font le lien entre les deux parties de la figure.
La partie droite de la figure montre la séquence d'insertions, étiquetées par
des labels, obtenue après traduction complète de l'invariant de boucle.
La figure~\ref{fig:code-ins} illustre le principe d'insertion des fragments de
code de la figure~\ref{fig:code-gen}, qui produit le programme instrumenté en
appliquant les règles d'insertion décrites ci-dessus.

Maintenant que le principe général de la traduction a été présenté, revenons
sur celle de la fonction du listing~\ref{lst:normalized}.
Chaque annotation du listing~\ref{lst:normalized} est traduite en une séquence
d'insertions de code.
La première précondition à la ligne 1 (listing~\ref{lst:normalized}) est
traduite à la ligne 6 du listing~\ref{lst:abbrv}.
La seconde précondition à la ligne 2 (listing~\ref{lst:normalized}) est
traduite à la ligne 7 du listing~\ref{lst:abbrv}.
La clause \lstinline'typically' de la ligne 3 du listing~\ref{lst:normalized}
est traduite ligne 8 du listing~\ref{lst:abbrv}.
L'invariant de boucle de la ligne 9 du listing~\ref{lst:normalized} est traduit
aux lignes 10--12 du listing~\ref{lst:abbrv} pour vérifier que l'invariant est
vrai avant la première itération (établissement), et aux lignes 19--23 du
listing~\ref{lst:abbrv} pour vérifier la préservation de l'invariant après
chaque itération.
Le variant de boucle ligne 10 du listing~\ref{lst:normalized} est traduit aux
lignes 15--16 du listing~\ref{lst:abbrv} pour vérifier que le variant est
positif ou nul avant chaque itération de la boucle et aux lignes 24--25 du
listing~\ref{lst:abbrv} pour vérifier que le
variant décroît strictement après chaque itération, assurant ainsi la
terminaison de la boucle.
La postcondition des lignes 4--5 du listing~\ref{lst:normalized} est traduite
aux lignes 29--34 du listing~\ref{lst:abbrv}.


\subsection{Arithmétique non bornée}
\label{sec:integers}


\lstinputlisting[style=c,escapechar=§,caption={Propriétés des entiers : faux
    négatif dû à une traduction naïve},label=lst:Z:1]
                {listings/naive_false_negative.c}

\lstinputlisting[style=c,caption={Propriétés des entiers : faux positif dû à
    une traduction naïve},label=lst:Z:2]
                {listings/naive_false_positive.c}


Les listings~\ref{lst:Z:1} et~\ref{lst:Z:2} montrent deux exemples où
une traduction naïve des annotations contenant des entiers mathématiques mène
à un résultat incorrect.
Soit \lstinline'x' de type \lstinline'int'.
L'assertion ligne 1 du listing~\ref{lst:Z:1} est fausse lorsque
\lstinline'x = INT_MAX'.
La traduction naïve de cette assertion (ligne 3) utilise les entiers machine
avec arithmétique modulaire (supposons une architecture 32 bits), donc
\lstinline'x+1' reste inférieur ou égal à \lstinline'INT_MAX' pour toute valeur
de \lstinline'x', rendant tout échec de l'assertion impossible.
La traduction correcte pour cette annotation (lignes 6--9) conserve la
sémantique de l'arithmétique entière non bornée en utilisant une bibliothèque
externe (nous avons choisi GMP, la bibliothèque GNU Multi-Precision) pour
représenter les valeurs pouvant provoquer un débordement d'entier (ici
\lstinline'INT_MAX+1').
Les variables nécessaires pour la gestion des entiers non bornés sont créées et
initialisées, puis le résultat est calculé et les comparaisons sont faites en
tant qu'entier non borné.
Le second exemple (listing~\ref{lst:Z:2}) définit une assertion \eacsl (ligne 2)
qui est toujours correcte : pour tout entier positif \lstinline'x', son
successeur est aussi positif.
Une traduction naïve de cette annotation (ligne 3) génèrera une erreur à
l'exécution pour \lstinline'x = INT_MAX' : en arithmétique modulaire
\lstinline'x+1' déborde et devient négatif, violant l'assertion ligne 2.
Une traduction correcte utilisant les entiers non bornés (non présentée ici)
conserve le comportement attendu : l'assertion est vraie pour tout entier
positif \lstinline'x'.
D'une traduction naïve des annotations dans ces deux exemples résulterait un
faux négatif dans le premier cas et un faux positif dans le deuxième cas, ce
qui porterait atteinte à la correction et à la précision de notre méthode.
Les règles de traduction pour les constructions \eacsl que nous présentons
respectent la sémantique des entiers non bornés d'\eacsl et suppose
l'utilisation d'une bibliothèque externe telle GMP, comme illustré dans les
listings~\ref{lst:abbrv} et~\ref{lst:Z:1}.


\section{Traduction des annotations \eacsl}
\label{sec:annot}


La traduction des annotations est définie par les règles dans cette partie.
Cela requiert de traduire les termes et les prédicats \eacsl.
Ces transformations sont décrites par les règles des parties~\ref{sec:term}
et~\ref{sec:pred}.
Dans ces règles, les notations suivantes s'ajoutent aux notations utilisées au
chapitre précédent :
\begin{itemize}
\item $c_1$, $c_2$, $c_i$ et $c_n$ sont des fragments de programmes C;
\item $l$, $l_1$, $l_2$, $l_i$, $l_n$, $\mathit{Beg_f}$, $\mathit{End_f}$,
  $\mathit{BegIter_l}$ et $\mathit{EndIter_l}$ sont des labels du programme;
\item $j$ et $k$ sont des identificateurs de variables liées
  dans un prédicat \eacsl et un compteur d'itérations dans un programme C;
\item $x$ est un identificateur de variable C (donc une left-value);
\item $I$, $I_1$, $I_2$ et $I_3$ sont des listes d'insertions de code
  $(l_i, c_i)^*$;
\item $y$ et $z$ sont des left-values quelconques;
\item $i$, $i_1$, $i_2$ sont des instructions C;
\item $P$ est un programme C annoté et $P'$ est le programme instrumenté
  obtenu après traduction du programme $P$.
\end{itemize}

Les variables \lstinline'res'$_f$, \lstinline'var_'$n$,
\lstinline'i_'$n$, \lstinline'old_'$x$ et \lstinline'old_val_'$x$ sont
``fraîches'', c'est-à-dire que ces identificateurs sont supposés
différents de tous les autres identifiants de variables du programme instrumenté
: quand on utilise plusieurs fois une règle introduisant une variable fraîche,
toutes les occurrences de la variable créée doivent être différentes.
Ceci peut être implémenté en incrémentant le compteur $n$ à chaque
occurrence dans \lstinline'var_'$n$ et \lstinline'j_'$n$, et en utilisant le nom
de la variable d'origine à la place de $x$ dans \lstinline'old_'$x$ et
\lstinline'old_val_'$x$.

Pour des raisons de commodité, nous supposons que toutes les variables logiques
liées dans les annotations et toutes les variables du programme sont
différentes, ceci nous permet en particulier de traduire les variables logiques
en C sans les renommer.

La fonction de traduction des termes, notée $\alpha$, est définie comme une
fonction partielle qui, à un label $l$ et une annotation $a$,
associe une séquence d'insertions de code $(l_i, c_i)^*$ :

\[
(l, a) \arule
\underbracket{(l_1, c_1) \concat (l_2, c_2) \concat \ldots
  \concat (l_n, c_n)}_{I : \text{ liste d'insertions de code}}
\]

Les instances de cette fonction sont définies par les figures~\ref{fig:annot}
et~\ref{fig:loop-annot}, ces figures présentent les règles permettant de
traduire les annotations du langage \eacsl considéré.

Définissons maintenant les règles de traduction des
annotations, qui permettent de mettre en évidence les échecs d'annotation.
Pour chaque annotation, un fragment de programme C se terminant par le test
d'une expression par la fonction \lstinline'fassert' est inséré dans le
programme.
Le générateur de tests essaiera de couvrir tous les chemins d'exécution
faisables, donc s'il existe des entrées permettant de rendre fausse
l'expression de \lstinline'fassert', une erreur sera trouvée et un cas de test
la produisant sera donné.

\input{figures/fig_rules_annot}

La figure~\ref{fig:annot} décrit les règles de traduction pour les assertions
(\textsc{$\alpha$-assert}), les préconditions (\textsc{$\alpha$-check-pre} et
\textsc{$\alpha$-assume-pre}), les clauses \lstinline'assigns'
(\textsc{$\alpha$-check-assigns}) et les postconditions
(\textsc{$\alpha$-check-post}).
La règle \textsc{$\alpha$-assert} vérifie simplement avec la fonction
\lstinline'fassert' la valeur $e$ de la traduction du prédicat $p$ au label $l$.
La règle \textsc{$\alpha$-check-pre} vérifie avec la fonction
\lstinline'fassert' la valeur $e$ de la traduction du prédicat $p$ au début de
la fonction instrumentée.
La règle \textsc{$\alpha$-assume-pre} traite la précondition de la fonction sous
test, qui est supposée vraie par définition.
Cette même règle permet de traduire les clauses \lstinline'typically'
(précondition pour le test qui permet de limiter l'explosion combinatoire du
nombre de chemins du programme) et les clauses \lstinline'requires', elle
suppose avec la fonction \lstinline'fassume' que la valeur $e$ de la
traduction du prédicat $p$ au début de la fonction est vraie.
La règle \textsc{$\alpha$-check-assigns} vérifie que les left-values qui ne sont
pas dans une clause \lstinline'assigns' ne sont pas modifiées par la fonction.
L'ensemble des left-values considérées est la différence $G-X$, où $G$ est
l'ensemble des left-values dans le contexte courant et $X$ est l'ensemble des
left-values de la clause \lstinline'assigns'.
Dans cette règle, l'expression suivante :
\[
\forall (x:\mathit{ctype}) \in G-X :
((Beg_f, \mathit{ctype}~\mbox{\lstinline'var_'}n = e_1\semicolon)
\concat (End_f, \mbox{\lstinline'fassert('}e_2~\mbox{\lstinline'== var_'}n\mbox{\lstinline');'}) )
\]
dénote la liste d'insertions de fragments de code contenant ces deux fragments
de code $\mathit{ctype}~\mbox{\lstinline'var_'}n = e_1\semicolon$ et
$\mbox{\lstinline'fassert('}e_2~\mbox{\lstinline'== var_'}n\mbox{\lstinline');'}$
pour chaque left-value $x$ de $G-X$., où $e_1$ est la valeur de $x$ au début de
la fonction et $e_2$ est la valeur de $x$ à la fin de la fonction.
Le premier fragment sauvegarde la valeur de $x$ dans \lstinline'var_'$n$ au
début de la fonction, le second fragment vérifie que la valeur de $x$ n'a pas
été modifiée en fin de fonction.
La règle \textsc{$\alpha$-check-post} vérifie la validité de la postcondition
à la fin de la fonction instrumentée.

\input{figures/fig_rules_loop_annot}

La figure~\ref{fig:loop-annot} présente les règles de traduction pour les
invariants de boucle (\textsc{$\alpha$-check-invariant}), les variants de boucle
(\textsc{$\alpha$-variant}) et les loop assigns
(\textsc{$\alpha$-check-loop-assigns}) pour une boucle au label $l$.
La règle \textsc{$\alpha$-check-loop-assigns} vérifie que les left-values qui ne
sont pas dans la clause \lstinline'loop assigns' ne sont pas modifiées par la
boucle.
Pour chacune de ces left-values, une sauvegarde de leur valeur courante est
faite au début de chaque itération, puis on vérifie que leur valeur n'a pas été
modifiée en fin de boucle.
La règle \textsc{$\alpha$-check-invariant} vérifie le prédicat de l'invariant
avant la boucle et après chaque itération de la boucle.
La règle \textsc{$\alpha$-variant} vérifie que le terme variant est non-négatif
au début de chaque itération.
Enfin, on vérifie à la fin de chaque itération que le variant décroît
strictement par rapport à sa valeur au début de l'itération.


\section{Traduction des termes \eacsl}
\label{sec:term}


La fonction de traduction des termes, notée $\tau$, est définie comme une
fonction partielle qui, à un label $l$ et un terme $t$, associe une séquence
d'insertions de code $(l_i, c_i)^*$ et une expression C dénotée $e$ :

\[
(l, t) \trule
(\underbracket{(l_1, c_1) \concat (l_2, c_2) \concat \ldots
  \concat (l_n, c_n)}_{I : \text{ liste d'insertions de code}}, e)
\]

Cette fonction est définie dans les
figures~\ref{fig:const-id}, \ref{fig:coerce}, \ref{fig:op} et~\ref{fig:builtin}.
Ces figures présentent les règles permettant de traduire les termes du langage
\eacsl considéré.
Le type du terme peut être $\mathbb{Z}$ (\lstinline'integer'), un type pointeur
quelconque (\lstinline'int*', \lstinline'char*', etc.) noté $ptr$ ou un type
scalaire du C (\lstinline'char', \lstinline'int', \lstinline'long', etc.) noté
$ctype$.
$ctype$ correspond à l'entité syntaxique \textit{basic-type} et $ptr$
correspond à l'entité syntaxique \textit{basic-type}\lstinline'*'
de la figure~\ref{fig:gram-c} du chapitre précédent.
Les insertions de code sont les instructions C nécessaires à l'évaluation du
terme.
Elles permettent notamment d'évaluer les sous-termes dont est composé le terme
\lstinline't'.
L'expression \lstinline'e' est pure (elle ne provoque pas d'effet de bord) et
correspond à l'évaluation du terme \lstinline't' au point de programme $l$.
L'évaluation de \lstinline'e' requiert le plus souvent plusieurs opérations,
qui sont effectuées par les fragments de programme qui résultent de la
traduction du terme et seront insérés aux endroits adéquats dans le programme
instrumenté.
Par exemple, un terme quantifié (comme une somme : \lstinline'\sum') a besoin de
plusieurs instructions pour être évalué, et notamment d'une boucle (voir la
figure~\ref{fig:builtin}).
Dans ce cas, le second élément \lstinline'e' de la paire retournée est la
variable calculée par la boucle.
Quand un terme $t$ peut être traduit directement sans nécessiter de code C
supplémentaire, la séquence d'insertions de code est vide et notée $\emptylist$.
Pour un terme $t:\mathbb{Z}$, le résultat de traduction $e$ est toujours une
variable de type entier GMP (noté \lstinline'Z_t' dans le
listing~\ref{lst:Z:1}).

\input{figures/fig_rules_const_id}

La figure~\ref{fig:const-id} présente les règles de traduction pour les
left-values (\textsc{$\tau$-lv-simple} pour les identificateurs de variable et
\textsc{$\tau$-lv-array} pour les tableaux), pour le terme
\lstinline'\result' (\textsc{$\tau$-res}) et pour les constantes
(\textsc{$\tau$-const}).
Deux règles sont nécessaires pour traduire la construction \eacsl
\lstinline'\old'.
Appliquée à un identificateur $x$ (règle \textsc{$\tau$-old-simple}), le terme
est traduit en variable fraîche \lstinline'old_'$x$ qui contient la valeur de
$x$ au début de la fonction.
Appliquée à un accès mémoire (règle \textsc{$\tau$-old-array}), on utilise le
tableau alloué dynamiquement \lstinline'old_val_'$x$ qui contient les valeurs du
tableau ou pointeur $x$ au début de la fonction (se référer à la
partie~\ref{sec:principles}).
Le terme \lstinline'\result' est traduit par la règle \textsc{$\tau$-res}, il
fait référence à la valeur de retour de la fonction en \eacsl qui, par la
normalisation, est désignée par la variable \lstinline[escapechar=§]'res'$_f$ où
$f$ est le nom de la fonction courante.
Cette variable est unique dans chaque fonction après normalisation de l'arbre de
syntaxe abstraite par \framac.
La règle \textsc{$\tau$-const} établit qu'une variable entière GMP est définie
pour prendre la valeur d'une contante entière non bornée.
Les constantes d'un autre type sont implicitement converties en entier non
borné.

\input{figures/fig_rules_coerce}

La figure~\ref{fig:coerce} détaille les règles de conversions implicites, de
\lstinline'integer' vers le type C \lstinline'int' et du type C \lstinline'int'
vers \lstinline'integer'.
Ces règles peuvent être adaptées pour les autres types entiers du C
(\lstinline'char', \lstinline'long', etc.).
Ces conversions étant implicites, nous n'avons jamais à construire un terme
de la forme $(\mathbb{Z})t$ ou $(\mbox{\lstinline'int'})t$ et ces constructions
n'apparaissent donc pas dans la syntaxe des termes définie au chapitre
précédent.
Nous nous limitons aux conversions entre entiers et nous supposons que ces
conversions ne provoquent pas de débordement d'entiers, ainsi l'application
d'une conversion de type ne change pas la sémantique du terme.

\input{figures/fig_rules_op}

La figure~\ref{fig:op} détaille les règles pour les opérations unaires
(\textsc{$\tau$-unop}), les opérations binaires
(\textsc{$\tau$-binop$_{\{1,2\}}$}), la valeur absolue (\textsc{$\tau$-abs}) et la
condition ternaire sur les termes (\textsc{$\tau$-if}).
\textsc{$\tau$-unop} traite le cas du moins unaire et du complément
bit-à-bit ($\sim$) pour lesquels on suppose que ces opérations prennent un
\lstinline'integer' en entrée et en sortie.

\textsc{$\tau$-binop$_1$} traite l'arithmétique de pointeur, l'opérande gauche
est un pointeur, $binop$ doit être \lstinline'+' ou \lstinline'-', et l'opérande
droit est de type \lstinline'int'.
\textsc{$\tau$-binop$_2$} traite les opérations arithmétiques entières (les
opérandes et le résultat sont des entiers), $binop$ est un des opérateurs
arithmétiques suivants : \lstinline'+', \lstinline'-', \lstinline'*',
\lstinline'/', \lstinline'%'.
Dans la règle \textsc{$\tau$-if}, les évaluations de $t_2$ et $t_3$ sont dans
des branches conditionnelles : on calcule paresseusement l'un des deux, en
fonction de l'évaluation de $t_1$.
La notation suivante :
\[
(l,
\mbox{\lstinline'if('}
\underline{e_1\Zclear \mbox{\lstinline' \!= 0'}}
\mbox{\lstinline')'} \bopen
I_2
\concat
(l, \underline{\Zinit \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2 \Zclear}
\semicolon )
\bclose
\mbox{\lstinline'else'} \bopen
I_3
\concat
(l, \underline{\Zinit \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_3 \Zclear}
\semicolon )
\bclose )
\]
signifie que les blocs du \lstinline'if' et du \lstinline'else' contiendront,
après l'étape d'insertion (voir partie~\ref{sec:principles}), les instructions à
insérer au label $l$ obtenues à partir des fragments de code de $I_2$ et $I_3$
respectivement.
Dans la suite cette notation sera utilisée pour chaque conditionnelle
\lstinline'if' et chaque boucle \lstinline'while' ou \lstinline'for' générée par
les règles de traduction.

\input{figures/fig_rules_builtin}

La figure~\ref{fig:builtin} présente les règles de traduction pour les fonctions
logiques \lstinline'\sum' (\textsc{$\tau$-sum}) et \lstinline'\numof'
(\textsc{$\tau$-numof}).
Le terme \lstinline'\sum('$t_1, t_2,$ \lstinline'\lambda integer' $k$\semicolon
$t_3$\lstinline')' calcule la somme généralisée $\sum_{k = t_1}^{t_2}t_3$.
La règle \textsc{$\tau$-sum} permet de calculer cette somme.
Elle initialise une variable entière fraîche \lstinline'var_'$n$ à $0$ et
l'incrémente avec la valeur du \lstinline'\lambda'-terme $t_3$ à chaque
itération.
Le terme \lstinline'\product('$t_1, t_2,$ \lstinline'\lambda integer' $k$
\semicolon $t_3$\lstinline')' calcule le produit généralisé
$\Pi_{k = t_1}^{t_2}t_3$.
La règle permettant de calculer ce produit n'est pas donnée mais est similaire à
la règle \textsc{$\tau$-sum} et peut être facilement dérivée à partir de
celle-ci.
Le terme \lstinline'\numof('$t_1, t_2,$ \lstinline'\lambda integer' $k$
\semicolon $t_3$\lstinline')' désigne le nombre de $k$ tel que
$t_1 \le k \le t_2$ et $t_3 \neq 0$.
La règle \textsc{$\tau$-numof} permet de traduire ce terme.
Elle initialise une variable entière fraîche \lstinline'var_'$n$ à $0$ et
incrémente sa valeur quand le \lstinline'\lambda'-terme $t_3$
s'évalue en une expression non nulle.


\section{Traduction des prédicats \eacsl}
\label{sec:pred}


De manière similaire à la fonction de traduction $\tau$ pour les termes
(partie~\ref{sec:term}), la fonction de traduction des prédicats, notée $\pi$,
est définie comme une fonction partielle qui, à un label et un prédicat \eacsl
$p$, associe une séquence d'insertions de code $(l_i, c_i)^*$ et une
expression $e \in \{0, 1\}$ du langage C (que nous encoderons
dans un \lstinline'int') :

\[
(l, p) \prule
(\underbracket{(l_1, c_1) \concat (l_2, c_2) \concat \ldots
  \concat (l_n, c_n)}_{I : \text{ liste d'insertions de code}}, e)
\]

Les insertions de code sont les instructions C nécessaires à l'évaluation du
prédicat.
Elles permettent notamment d'évaluer les termes et prédicats
auxiliaires dont est composé le prédicat $p$.
Quand un prédicat $p$ peut être traduit directement et ne nécessite
pas la création d'instructions C, la séquence d'insertions est vide et notée
$\emptylist$.

Nous définissons dans les figures~\ref{fig:pred-logic}, \ref{fig:valid}
et~\ref{fig:quantif} les règles de traduction pour les principaux
prédicats \eacsl que nous traitons.
Pour chacune de ces règles, une variable fraîche \lstinline'var_'$n$ est générée
(même quand la traduction du prédicat est triviale) afin de standardiser les
règles et ainsi de faciliter la justification de leur correction.

\input{figures/fig_rules_pred}

La figure~\ref{fig:pred-logic} détaille les règles de traduction pour les
prédicats les plus simples du langage \eacsl.
Les règles \textsc{$\pi$-true} et \textsc{$\pi$-false} indiquent que
\lstinline'\true' (respectivement \lstinline'\false') se traduit en $1$
(respectivement $0$).
Les autres règles sont compositionnelles :
les prédicats fils sont traduits récursivement, puis le résultat de la
traduction est construit à partir des valeurs des prédicats fils.
La règle \textsc{$\pi$-equiv} utilise l'équivalence
$p_1 \Leftrightarrow p_2 \equiv p_1 \Rightarrow p_2 \land p_2 \Rightarrow p_1$
sous la forme $(\lnot p_1 \lor p_2) \land (\lnot p_2 \lor p_1)$.
Les règles \textsc{$\pi$-and}, \textsc{$\pi$-or} et \textsc{$\pi$-impl}
reflètent l'évaluation paresseuse de ces opérateurs selon la sémantique d'\eacsl
: le premier opérande est toujours évalué (en $I_1$) mais le deuxième n'est
évalué (en $I_2$) que si nécessaire.
La règle \textsc{$\pi$-if} est similaire à \textsc{$\tau$-if} (voir
partie~\ref{sec:term}).
Dans l'exemple du listing~\ref{lst:normalized}, la traduction de la
postcondition
\lstinline{\result != 0 <==> \exists integer j; 0<=j<n && t[j]==v} requiert
la traduction des prédicats \lstinline'\result != 0' et
\lstinline{\exists(...)} qui sont respectivement traduits en \lstinline'var_32'
et \lstinline'var_35'.
Ces deux prédicats sont assemblés pour construire la traduction du prédicat
composé, d'après la règle \textsc{$\pi$-equiv},:
\lstinline'(!var_32 || var_35) && (!var_35 || var_32)' (line 33 du
listing~\ref{lst:abbrv}).

\input{figures/fig_rules_valid}

La figure~\ref{fig:valid} montre les règles de traduction pour le prédicat
\lstinline'\valid', qui est vrai si le pointeur en argument pointe vers une
case mémoire valide et peut être déréférencé.
\lstinline'\valid(t)' exprime la validité d'un seul pointeur et
\lstinline'\valid(t1+(t2..t3))' exprime la validité du pointeur \lstinline't1'
dans l'intervalle d'offsets \lstinline't2..t3', ce qui veut dire que
\lstinline'(t1+t2)', \lstinline'(t1+t2+1)' \dots, \lstinline'(t1+t3)' sont
valides.
Les règles \textsc{$\pi$-valid} et \textsc{$\pi$-valid-range} couvrent les deux
cas.
Le support de ces prédicats nécessite une représentation précise de la mémoire
du programme, la réalisation de telles fonctions est abordée dans le
chapitre~\ref{sec:runtime}.
Dans notre exemple du listing~\ref{lst:normalized}, le prédicat
\lstinline'\valid(t+(0..n-1))' de la clause \lstinline'requires' de la ligne 2
est traduit en \lstinline[style=c]'fvalidr(t,0,(n-1))' (ligne 7 du
listing~\ref{lst:abbrv}).

\input{figures/fig_rules_quantif}

Dans la figure~\ref{fig:quantif}, la règle \textsc{$\pi$-forall} traite de la
traduction du prédicat universel \lstinline'\forall', quantifié sur les entiers.
Le code généré met à jour une variable \lstinline'var_'$n$ (initialisée à
$true$) à chaque itération de boucle, jusqu'à ce que toutes les valeurs de $k$
soient considérées ou que \lstinline'var_'$n$ soit évaluée à $false$.
La règle \textsc{$\pi$-exists} (figure~\ref{fig:quantif}) aborde la traduction
du prédicat existentiel \lstinline'\exists', quantifié sur les entiers.
Le code généré met à jour une variable \lstinline'var_'$n$ (initialement
$false$) à chaque itération de la boucle, jusqu'à ce que toutes les valeurs de
$k$ soient considérées ou que \lstinline'var_'$n$ soit évaluée à $true$.
Dans le listing~\ref{lst:normalized}, le prédicat
\lstinline{\exists integer i; 0<=i<n && t[i]==v} de la ligne 4 est traduit
aux lignes 29--33 du listing~\ref{lst:abbrv} et la variable fraîche contenant la
valeur du prédicat après évaluation est \lstinline'var_35' (déclarée à la
ligne 31).


\section[Test vs. validation à l'exécution]{Similarités et différences selon
  l'objectif, test vs. validation à l'exécution}
\label{sec:rac}


La traduction d'annotations \eacsl en code C a été implémentée dans deux
greffons \framac : \eacsltoc \cite{Delahaye/SAC13,Kosmatov/RV13} et \stady
\cite{Petiot/TAP14,Petiot/SCAM14}.
Le premier génère un programme instrumenté pour la validation d'assertions à
l'exécution, le second génère un programme instrumenté pour la génération de
tests avec \pathcrawler \cite{\citepathcrawler}.
Cette partie discute les similarités et les différences entre ces deux façons
d'instrumenter.

La traduction pour la validation à l'exécution et la traduction pour la
génération de tests ont toutes deux besoin de générer du code exécutable, c'est
pourquoi un sous-ensemble exécutable du langage de spécification est considéré
dans les deux cas.
La plupart des règles définies dans les parties~\ref{sec:annot},
\ref{sec:term} et \ref{sec:pred} sont autant valables pour la validation à
l'exécution que pour le test, le code généré devant être correct vis-à-vis de la
sémantique des annotations.
Cependant, il y a plusieurs différences liées à la différence d'objectif.
Les trois différences sont :
\begin{itemize}
\item la manière de considérer la précondition de la fonction sous test;
\item la manière de traiter les annotations liées au modèle mémoire;
\item et la manière de traiter les fonctions sur les entiers mathématiques.
%\item et la manière de traiter les potentielles erreurs à l'exécution
%  introduites par les fragments de code résultant de la traduction.
\end{itemize}


\textbf{Précondition de la fonction sous test.}
Une première différence est le traitement de la précondition de la fonction sous
test.
En vérification à l'exécution, elle est vérifiée comme n'importe quelle autre
annotation.
En génération de tests, la précondition est utilisée pour éviter de tester le
programme avec des valeurs d'entrées incorrectes, pour lesquelles le bon
fonctionnement du programme n'est pas garanti.
La précondition de la fonction sous test est donc supposée vraie pour la
génération de tests, afin de s'assurer que toutes les entrées générées par le
test satisfont cette précondition.

\textbf{Annotations liées au modèle mémoire.}
La validation à l'exécution nécessite une instrumentation complexe pour traiter
les constructions \eacsl liées au modèle mémoire comme \lstinline'\valid',
\lstinline'\block_length', \lstinline'\base_addr', etc.
Chaque opération affectant la mémoire doit être instrumentée et les informations
de chaque case mémoire doivent être enregistrées afin de pouvoir évaluer ces
annotations \cite{Kosmatov/RV13}.
Nous aborderons les spécificités d'une telle instrumentation dans le
chapitre~\ref{sec:runtime}.
Certaines de ces constructions peuvent être traitées symboliquement par le test
concolique et ne nécessitent donc pas de traduction spécifique en C.
C'est le cas avec \lstinline'\valid' : nous supposons la définition de fonctions
C \lstinline'fvalid' et \lstinline'fvalidr', supportées par le générateur de
tests, qui retournent la valeur de validité du pointeur en argument si celui-ci
est une variable globale ou un paramètre formel de la fonction sous test
\cite{Chebaro/ICSSEA12}.

\textbf{Arithmétique non bornée.}
Tandis que l'utilisation d'une bibliothèque externe d'arithmétique non bornée
(comme GMP) pour traduire les entiers d'\eacsl est appropriée pour la validation
à l'exécution, il n'en est pas de même pour la génération de tests :
si le code des fonctions de la bibliothèque est analysé par le
générateur de tests, alors cette solution se révèlera inefficace.
En effet, la génération de tests à partir du programme instrumenté aura à
traiter un code beaucoup plus compliqué, avec de nombreux appels de fonctions, 
des allocations/désallocations dynamiques, etc.
Ceci peut être évité en exécutant symboliquement les fonctions de la
bibliothèque : \pathcrawler offre un support dédié aux fonctions de la
bibliothèque GMP, dont les opérations sont traduites efficacement en contraintes
sur les entiers non bornés, que le solveur de contraintes sous-jacent peut
traiter.

%% \textbf{Erreurs à l'exécution.}
%% La traduction d'annotations en C peut introduire des erreurs à l'exécution dues
%% aux termes dont la sémantique est indéfinie dans les annotations, comme
%% \lstinline'1/0'.
%% Ce problème peut être évité pour la génération de tests (comme proposé dans
%% \cite{Delahaye/SAC13} pour la validation à l'exécution), en utilisant le greffon
%% \rte \cite{\citeframac} sur le code résultant de l'instrumentation.
%% Celui-ci ajoute des gardes supplémentaires et il suffit ensuite de
%% ré-instrumenter le programme en tenant compte de ces nouvelles annotations.
%% Les erreurs à l'exécution liées aux entiers non bornés (division d'un entier
%% GMP par $0$, débordement pendant une conversion
%% \lstinline[mathescape=true]{(int)(t:$\mathbb{Z}$)}, etc.) ne sont pas traités
%% par \rte mais ces erreurs peuvent être évitées en ajoutant les gardes
%% nécessaires aux règles de traduction.
%% Par exemple, le cast d'un terme $t$ d'\lstinline'integer' vers \lstinline'int'
%% (voir la règle \textsc{$\tau$-coerce$_1$} de la figure~\ref{fig:coerce}) peut
%% être gardé en ajoutant
%% \lstinline{fassert(}\underline{\lstinline{INT\_MIN <= e}}\lstinline{ && }
%% \underline{\lstinline{e <= INT\_MAX}}\lstinline{)} avant l'affectation
%% \underline{\lstinline'var_n = e'}.


\section{Justification de correction de la traduction}
\label{sec:justif}


Nous donnons une justification de correction des règles de traduction.
Nous voulons notamment nous assurer que si une erreur est trouvée par le
générateur de tests alors y a une inconsistance entre le code et sa
spécification.
Pour atteindre cet objectif, nous montrons que l'exécution du code inséré par
la traduction d'un terme, d'un prédicat ou d'une annotation a pour effet de
calculer la même valeur que la valeur de ce terme, ce prédicat ou cette
annotation évalués à leur place dans le programme initial.
Pour cela, nous nous basons sur la sémantique dénotationnelle des instructions
définie au chapitre précédent.

Nous ne détaillons pas les justifications de toutes les constructions.
Nous avons choisi un échantillon représentatif du langage composé des constantes
pour les termes, des conjonctions pour les prédicats, des assertions, des
contrats de boucle et des contrats de fonction.
Les propriétés que nous vérifions sont définies en partie~\ref{sec:properties}.
Les parties~\ref{sec:term-translation}, \ref{sec:predicate-translation} et
\ref{sec:annotation-translation} justifient la correction de ces propriétés
respectivement sur les termes, sur les prédicats et sur les annotations.


\subsection{Propriétés de l'instrumentation}
\label{sec:properties}


Définissons maintenant les propriétés exprimant la correction de la traduction,
c'est-à-dire que le code instrumenté a la même sémantique que le code annoté
dont il est issu.

Ces propriétés se décomposent en trois parties qui sont la préservation des
erreurs, l'inclusion des mémoires et l'absence d'erreur à l'exécution due à
l'instrumentation.

\begin{myproperty}[Préservation des erreurs]
  \label{th:error}
  À partir de toute mémoire, si l'exécution des instructions obtenues
  par traduction d'une annotation $a$
  du programme $P$ provoque une erreur dans le programme instrumenté $P'$ par
  cette traduction de $a$, alors l'annotation $a$ est invalide.
\end{myproperty}

La préservation des erreurs (propriété~\ref{th:error}) assure l'absence de faux
positifs lors de la génération de tests sur le programme instrumenté,
c'est-à-dire que toute erreur détectée par la génération de tests correspond à
une erreur du programme annoté.


\begin{myproperty}[Inclusion des mémoires]
  \label{th:inclusion}
  Soit $A$ la séquence d'instructions obtenue à partir d'une liste d'insertions
  de code $I$ selon les règles d'insertion énoncées dans la
  partie~\ref{sec:principles}.
  Soit $(\env, \store)$ une mémoire quelconque.
  Pour tout préfixe $B$ de $A$, si
  $(\env', \store')$ = \comps{$B$}{$(\env, \store)$}, alors
  $\env \subenv \env'$ et $\store \subenv \store'$.
\end{myproperty}

%% \begin{definition}[Point d'exécution associé]
%%   \label{def:exec-point}
%%   Soit un compteur de programme $c_P$ du programme source $P$, incrémenté de 1 à
%%   chaque exécution d'instruction.
%%   Soit un compteur de programme $c_{P'}$ du programme instrumenté $P'$,
%%   incrémenté de 1 à chaque instruction de $P'$ qui est une instruction de $P$.
%%   Un point d'exécution du programme source est associé à un point d'exécution du
%%   programme instrumenté si et seulement si $c_P = c_{P'}$.
%% \end{definition}

L'inclusion des mémoires (propriété~\ref{th:inclusion}) est un lemme
nécessaire à la justification de la propriété~\ref{th:error}.
Il énonce que les seules variables modifiées dans les instructions ajoutées dans
le programme instrumenté sont les variables fraîchement créées par la
traduction.
Les variables existantes dans le programme d'origine ne sont pas modifiées par
la traduction.
%% Il affirme que si toutes les annotations d'un programme $P$ sont valides, à
%% chaque point d'exécution de $P$ la mémoire $(\env, \store)$ produite par
%% l'exécution du programme $P$ est incluse dans la mémoire $(\env', \store')$
%% produite par l'exécution du programme instrumenté $P'$ au point d'exécution
%% associé (voir définition~\ref{def:exec-point}) :
%% $\env \subenv \env'$ et $\store \subenv \store'$.

\begin{myproperty}[Absence d'erreur]
  \label{lem:noerror}
  Soit $A$ la séquence d'instructions obtenue à partir d'une liste d'insertions
  de code $I$ issue de la traduction d'un terme ou d'un prédicat.
  Soit $\mem$ une mémoire quelconque.
  Pour tout préfixe $B$ de $A$, \comps{$B$}{$\mem$} $\neq \errormem$.
\end{myproperty}

L'absence d'erreur (propriété~\ref{lem:noerror}) est un lemme nécessaire à la
justification des propriétés~\ref{th:error} et~\ref{th:inclusion}.
Il énonce que la traduction d'un terme ou d'un prédicat \eacsl quelconque ne
provoque pas d'erreur.

Dans les parties~\ref{sec:term-translation} et~\ref{sec:predicate-translation}
nous déclinons ces propriétés sur les termes et sur les prédicats.
Dans la partie~\ref{sec:annotation-translation} nous justifions les
propriétés~\ref{th:error} et~\ref{th:inclusion} à partir des propriétés prouvées
dans les parties~\ref{sec:term-translation} et~\ref{sec:predicate-translation}.


\subsection{Justification de la correction de la traduction des termes}
\label{sec:term-translation}


Afin de prouver la correction de la traduction des prédicats et des annotations,
nous devons prouver la correction de la traduction des termes.

\begin{myproperty}[Préservation de la sémantique des termes]
  \label{lem:term-correct}
  Soit $t$ : $T$ un terme de type $T$ au label $l$ qui est traduit par le couple
  $(I, e)$ où $I$ est une liste d'insertions de code et $e$ est la variable
  donnant la valeur du terme $t$.
  La sémantique des termes est préservée si le fragment de programme $A$ obtenu
  à partir de $I$ et exécuté à partir d'une mémoire quelconque $\mem$ donne une
  mémoire \comps{$A$}{$\mem$} telle que
  \eval{$t$}{$\mem$} = \eval{$e$}{(\comps{$A$}{$\mem$})}.
\end{myproperty}

La propriété~\ref{lem:term-correct} est la déclinaison sur les termes de la
propriété~\ref{th:error}.
La propriété~\ref{lem:term-correct} énonce que l'évaluation des insertions de
code $I$ générées lors de la traduction d'un terme $t$ ajoute une
nouvelle variable $e$ (fraîche) à la mémoire courante, dont la valeur
correspond à l'évaluation de $t$ dans la mémoire $\mem$.
Il est facile de vérifier que les variables qui sont déjà dans la mémoire
initiale ne sont pas impactées dans la mémoire résultante
(propriété~\ref{th:inclusion}), et la mémoire résultant de la traduction du
terme n'est pas la mémoire d'erreur $\errormem$ (propriété~\ref{lem:noerror}).
Ces propriétés sont vérifiées par la traduction de chaque terme.
Elles nous permettent de prouver la propriété~\ref{lem:term-correct}.
Pour ne pas alourdir ce chapitre, la preuve n'est fournie que pour la règle
\textsc{$\tau$-const} de traduction des constantes.


\subsubsection{Justification de correction de la traduction des constantes}


Rappelons la règle de traduction des constantes :

{\myinference{$\tau$-const}
  {}
  { (l, cst : \mathbb{Z}) \trule
    ((l, \Zinit\underline{\mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~cst}
    \semicolon),
    \mbox{\lstinline'var_'}n) }{}
}

Les propriétés~\ref{th:inclusion}, \ref{lem:noerror} et~\ref{lem:term-correct}
sont déclinées ainsi sur le cas de la constante :

Propriété~\ref{lem:term-correct}. \eval{$cst$}{$\mem$} =
\eval{\lstinline'var_'$n$}{
  (\comps{
    $\Zinit$\underline{\lstinline'var_'$n$ \lstinline'=' $cst$}\semicolon
  }{$\mem$})}.


Propriété~\ref{th:inclusion}.
$\env \subenv \env'$ et $\store \subenv \store'$ où
 $(\env', \store') =$
\comps{
  $\Zinit$\underline{\lstinline'var_'$n$ \lstinline'=' $cst$}\semicolon
}{$(\env, \store)$}.


Propriété~\ref{lem:noerror}.
\comps{
  $\Zinit$\underline{\lstinline'var_'$n$ \lstinline'=' $cst$}\semicolon
}{$\mem$}
$\neq \errormem$.

Nous les justifions une à une :

\begin{proof}[Justification de la propriété~\ref{lem:term-correct}.]~\\
  Nous transformons le membre droit en une expression identique au membre gauche
  en appliquant les règles de sémantique dénotationnelle et de définition des
  mémoires :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \eval{\lstinline'var_'$n$}{
        (\comps{$\Zinit$\underline{\lstinline'var_'$n$ \lstinline'=' $cst$}
          \semicolon
        }{$(\env, \store)$})}
    }\\ 
    &$\eq{\eqlabel{C-Z-set}}$&
    \eval{\lstinline'var_'$n$}{
      ($\env$[\lstinline'var_'$n$ $\mapsto \loc]$,
      $\store$[$\loc \mapsto$
        \eval{$cst$}{$(\env, \store)$}])} \\
    && où $\loc$ est une adresse fraîche \\
    &$\eq{\eqlabel{E-lval}}$&
    $\store$[$\loc \mapsto$
      \eval{$cst$}{$(\env, \store)$}]
    (
    $\env$[\lstinline'var_'$n$ $\mapsto \loc]$
    (\lstinline'var_'$n$)
    )\\
    &$\eq{\eqlabel{env-get-1}}$&
    $\store$[$\loc \mapsto$
      \eval{$cst$}{$(\env, \store)$}]
    ($\loc$)\\
    &$\eq{\eqlabel{store-get-1}}$&
    \eval{$cst$}{$(\env, \store)$} \\
  \end{tabular}
  ~\\
\end{proof}


\begin{proof}[Justification de la propriété~\ref{th:inclusion}.]~\\
  L'instruction générée
  $\Zinit$\underline{\lstinline'var_'$n$ \lstinline'=' $cst$}\semicolon ne
  modifie que la variable fraîche \lstinline'var_'$n$.
  Le nouvel environnement est
  $\env' = \env[$\lstinline'var_'$n$ $\mapsto \loc]$
  et le nouveau store est
  $\store' = \store[\loc \mapsto$ \eval{$cst$}{$(\env, \store)$}$]$.
  On peut donc en conclure $\env \subenv \env'$ et $\store \subenv \store'$.
  ~\\
\end{proof}


\begin{proof}[Justification de la propriété~\ref{lem:noerror}.]~\\
  La nouvelle mémoire est
  $(\env[$\lstinline'var_'$n$ $\mapsto \loc],$
  $\store[\loc \mapsto$ \eval{$cst$}{$(\env, \store)$}$])$.
  Ce n'est pas une mémoire d'erreur car l'évaluation d'une constante ne produit
  pas d'erreur.
  On a donc bien
  \comps{
    $\Zinit$\underline{\lstinline'var_'$n$ \lstinline'=' $cst$}\semicolon
  }{$\mem$} $\neq \errormem$.
  ~\\
\end{proof}


\subsection{Justification de correction de la traduction des prédicats}
\label{sec:predicate-translation}


Afin de prouver la correction de la traduction des annotations,
nous devons prouver la correction de la traduction des prédicats.

\begin{myproperty}[Préservation de la sémantique des prédicats]
  \label{lem:pred-correct}
  Soit $p$ un prédicat au label $l$ qui est traduit par le couple $(I, e)$ où
  $I$ est une liste d'insertions de code et $e$ est la variable donnant la
  valeur du prédicat $p$.
  La sémantique des prédiats est préservée si le fragment de programme $A$
  obtenu à partir de $I$ et exécuté à partir d'une mémoire quelconque $\mem$
  donne une mémoire \comps{$A$}{$\mem$} telle que
  \eval{$p$}{$\mem$} = \eval{$e$}{(\comps{$A$}{$\mem$})}.
\end{myproperty}

La propriété~\ref{lem:pred-correct} est la déclinaison sur les prédicats de la
propriété~\ref{th:error}.
La propriété~\ref{lem:pred-correct} énonce que l'évaluation des insertions de
code $I$ générées lors de la traduction d'un prédicat $p$ ajoute une
nouvelle variable $e$ (fraîche) à la mémoire courante, dont la valeur
correspond à l'évaluation de $p$ dans la mémoire $\mem$.
Il est facile de vérifier que les variables qui sont déjà dans la mémoire
initiale ne sont pas impactées dans la mémoire résultante
(propriété~\ref{th:inclusion}), et la mémoire résultant de la traduction du
prédicat n'est pas la mémoire d'erreur $\errormem$
(propriété~\ref{lem:noerror}).
Ces propriétés sont vérifiées par la traduction de chaque prédicat.
Elles nous permettent de prouver la propriété~\ref{lem:pred-correct}.
Pour ne pas alourdir ce chapitre, la preuve n'est fournie que pour la règle
\textsc{$\pi$-and} de traduction des conjonctions.


\subsubsection{Justification de correction de la traduction des conjonctions}


La règle de traduction du prédicat de conjonction \textsc{$\pi$-and} est
définie ainsi :

{\myinference{$\pi$-and}
  { (l, p_1) \prule (I_1, e_1) \\
    (l, p_2) \prule (I_2, e_2) }
  { (l, p_1\mbox{\lstinline'&&'}~p_2) \prule
    (I_1 \cdot
    (l,\mbox{\lstinline'int var_'}n~\mbox{\lstinline'='}~e_1\semicolon)\cdot
    (l, \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen I_2 \cdot
    (l, \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon)
    \bclose ),
    \mbox{\lstinline'var_'}n)
  }{}
}~\\

Les propriétés~\ref{th:inclusion}, \ref{lem:noerror} et~\ref{lem:pred-correct}
sont déclinées ainsi sur le cas de la conjonction :

Propriété~\ref{lem:pred-correct}.\\
\eval{\lstinline'p1 && p2'}{$\mem$} =
\eval{\lstinline'var_n'}{(
  \comps{$A_1\semicolon~ \mbox{\lstinline'int var_'}n~\mbox{\lstinline'='}~
    e_1\semicolon~
    \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
    \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
  }{$\mem$}
  )}
en admettant que les fragments de programme $A_1$ et $A_2$ sont obtenus à partir
des listes d'insertions $I_1$ et $I_2$ selon les règles d'insertion énoncées
dans la partie~\ref{sec:principles}.

Propriété~\ref{th:inclusion}.\\
$\env \subenv \env'$ et $\store \subenv \store'$ où
$(\env', \store')$ =
\comps{$A_1\semicolon~ \mbox{\lstinline'int var_'}n~\mbox{\lstinline'='}~e_1
  \semicolon~
  \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
  \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
}{$(\env, \store)$}.

Propriété~\ref{lem:noerror}.\\
\comps{$A_1\semicolon~ \mbox{\lstinline'int var_'}n~\mbox{\lstinline'='}~e_1
  \semicolon~
  \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
  \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
}{$\mem$} $\neq \errormem$.

Nous les justifions une à une :

\begin{proof}[Justification de la propriété~\ref{lem:pred-correct}.]~\\
  Par hypothèse, les traductions de $p_1$ et $p_2$ sont
  correctes, c'est-à-dire :

  \begin{center}
    \begin{tabular}{rclr}
      \eval{$p_1$}{$\mem$}
      &=& \eval{$e_1$}{(\comps{$A_1$}{$\mem$})} & \eqlabel{h1} \\
      \eval{$p_2$}{$\mem$}
      &=& \eval{$e_2$}{(\comps{$A_2$}{$\mem$})} & \eqlabel{h2} \\
    \end{tabular}
  \end{center}

  Nous transformons le membre droit en une expression identique au membre gauche
  en appliquant les règles de sémantique dénotationnelle et de définition des
  mémoires :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \eval{\lstinline'var_'$n$}{(
        \comps{$A_1\semicolon~ \mbox{\lstinline'int var_'}n\semicolon~
          \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_1\semicolon~
          \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
          \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
        }{$\mem$}
        )}
    } \\
    &$\eq{\eqlabel{C-seq-1}}$
    & \eval{\lstinline'var_'$n$}{
      (\comps{$\mbox{\lstinline'int var_'}n\semicolon~
        \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_1\semicolon~
        \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
        \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
      }{(\comps{$A_1$}{$\mem$})})} \\
    &=
    & \eval{\lstinline'var_'$n$}{
      (\comps{$\mbox{\lstinline'int var_'}n\semicolon~
        \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_1\semicolon~
        \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
        \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
      }{$\mem'$})} \\
    &$\eq{\eqlabel{C-seq-2}}$
    & \eval{\lstinline'var_'$n$}{
      (\comps{$\mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_1\semicolon~
        \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
        \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
      }{(\comp{$\mbox{\lstinline'int var_'}n\semicolon$}{$\mem'$})}
      )
    } \\
    &$\eq{\eqlabel{C-decl}}$
    & \eval{\lstinline'var_'$n$}{
      (\comps{$\mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_1\semicolon~
        \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
        \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
      }{$(\env'[\mbox{\lstinline'var_'}n \mapsto \loc], \store'[\loc \mapsto \bot])$}
      )
    } \\
    &=
    & \eval{\lstinline'var_'$n$}{
      (\comps{$\mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_1\semicolon~
        \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
        \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
      }{$\mem''$}
      )
    } \\
    &$\eq{\eqlabel{C-seq-2}}$
    & \eval{\lstinline'var_'$n$}{
      (\comps{
        $\mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
        \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
      }{\comp{$\mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_1\semicolon$
        }{$\mem''$}}
      )
    } \\
    &$\eq{\eqlabel{C-set}}$
    & \eval{\lstinline'var_'$n$}{
      (\comps{
        $\mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
        \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
      }{
        $(\env'', \store''[\loc \mapsto$ \eval{$e_1$}{$\mem''$}$])$
      }
      )
    } \\
    && où $(\env', \store') = \mem' = $ \comps{$A_1$}{$\mem$}, \\
    && $(\env'', \store'') = \mem'' = (\env'[\mbox{\lstinline'var_'}n \mapsto \loc], \store'[\loc \mapsto \bot])$ \\
    && et $\loc$ est une adresse fraîche. \\
  \end{tabular}

  (a) Cas où la valeur de l'expression conditionnelle \lstinline'var_'$n$ est
  vraie, soit \eval{$e_1$}{(\comps{$A_1$}{$\mem$})} = true,
  c'est-à-dire par hypothèse \eqlabel{h1} : \eval{$p_1$}{$\mem$} =
  true.
  Dans ce cas, par définition de \eqlabel{C-if} on exécute le bloc
  $A_2\semicolon~ \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon$ :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \comps{
        \lstinline'if(var_'$n$\lstinline')' $\bopen A_2\semicolon~
        \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
      }{
        $(\env'', \store''[\loc \mapsto$ \eval{$e_1$}{$\mem''$}$])$
      }
    } \\
    &$\eq{\eqlabel{C-if}}$
    & \comps{
      $A_2\semicolon~\mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon$
    }{
      $(\env'', \store''[\loc \mapsto$ \eval{$e_1$}{$\mem''$}$])$
    } \\
    &$\eq{\eqlabel{C-seq-1}}$
    & \comp{\lstinline'var_'$n$~\lstinline'='~$e_2$\semicolon}{
      (\comps{$A_2$}{
        $(\env'', \store''[\loc \mapsto$ \eval{$e_1$}{$\mem''$}$])$
      })
    } \\
    &=
    & \comp{\lstinline'var_'$n$~\lstinline'='~$e_2$\semicolon}{$\mem'''$} \\
    &$\eq{\eqlabel{C-set}}$
    & $(\env''', \store'''[\env'''($\lstinline'var_'$n) \mapsto$
      \eval{$e_2$}{$\mem'''$}$])$ \\
    &$\eq{\eqlabel{env-get-1}}$
    & $(\env''', \store'''[\loc \mapsto$ \eval{$e_2$}{$\mem'''$}$])$
    car $\env'''($\lstinline'var_'$n) = \loc$, \\
    && où $(\env''', \store''') = \mem''' = $
    (\comps{$A_2$}{
      $(\env'', \store''[\loc \mapsto$ \eval{$e_1$}{$\mem''$}$])$
    }). \\
  \end{tabular}

  Donc :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \eval{\lstinline'var_'$n$}{
        $(\env''', \store'''[\loc \mapsto$ \eval{$e_2$}{$\mem'''$}$])$
      }
    } \\
    &$\eq{\eqlabel{E-lval}}$
    &$\store'''[\loc \mapsto$ \eval{$e_2$}{
        $\mem'''$}$](\env'''($\lstinline'var_'$n))$ \\
    &$\eq{\eqlabel{env-get-1}}$
    &$\store'''[\loc \mapsto$ \eval{$e_2$}{$\mem'''$}$](\loc)$ \\
    &$\eq{\eqlabel{store-get-1}}$
    &\eval{$e_2$}{$\mem'''$}\\
    &=
    &\eval{$e_2$}{
      (\comps{$A_2$}{
        $(\env'', \store''[\loc \mapsto$ \eval{$e_1$}{$\mem''$}$])$
      })
    } par définition de $\mem'''$ \\
    
    &=
    & \eval{$e_2$}{
      (\comps{$A_2$}{
        $(\env'[\mbox{\lstinline'var_'n} \mapsto \loc], \store'[\loc \mapsto \mbox{\eval{$e_1$}{$\mem''$}}])$
      })
    } par définition de $\env''$ et $\store''$ \\

    && or \lstinline'var_'$n$ est une variable fraîche introduite par la traduction qui n'intervient \\
    && pas dans $p_2$, on peut donc remplacer $\env'[\mbox{\lstinline'var_'}n \mapsto \loc]$ et $\store'[\loc \mapsto \mbox{\eval{$e_1$}{$\mem''$}}]$ \\
    && par $\env'$ et $\store'$. \\

    &=
    & \eval{$e_2$}{(\comps{$A_2$}{$(\env', \store')$})} \\

    && comme la propriété~\ref{th:inclusion} est satisfaite
    ($\env \subseteq \env'$ et $\store \subseteq \store'$) et comme
    $p_2$ n'utilise \\
    && aucune des variables ajoutée à $\env$ pour
    constituer $\env'$, on peut remplacer $(\env', \store')$ \\
    && par $(\env, \store)$. \\

    &=
    & \eval{$e_2$}{(\comps{$A_2$}{$(\env, \store)$})} \\

    &=
    & \eval{$e_2$}{(\comps{$A_2$}{$\mem$})} par définition de $\mem$ \\

    &$\eq{\eqlabel{h2}}$
    & \eval{$p_2$}{$\mem$} \\
    &=& \eval{$p_1$}{$\mem$} $\land$ \eval{$p_2$}{$\mem$}
         {\scriptsize
           (car on est dans le cas \eval{$p_1$}{$\mem$} = true)} \\
         &$\eq{\eqlabel{P-and}}$& \eval{$p_1$~\lstinline'\&\&'~$p_2$}{$\mem$} \\
  \end{tabular}

  (b) Cas où la valeur de l'expression conditionnelle \lstinline'var_'$n$ est
  fausse, soit \eval{$e_1$}{(\comps{$A_1$}{$\mem$})} = false,
  c'est-à-dire par hypothèse \eqlabel{h1} : \eval{$p_1$}{$\mem$} =
  false.
  Dans ce cas, par définition de \eqlabel{C-if} on exécute le bloc du
  \lstinline'else' (qui ici est vide et n'apparaît pas car facultatif) :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \comps{
        \lstinline'if(var_'$n$\lstinline')' $\bopen A_2\semicolon~
        \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
      }{
        $(\env'', \store''[\loc \mapsto$ \eval{$e_1$}{$\mem''$}$])$
      }
    } \\
    &$\eq{\eqlabel{C-if}}$
    & $(\env'', \store''[\loc \mapsto$ \eval{$e_1$}{$\mem''$}$])$ \\
  \end{tabular}

  Donc :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \eval{\lstinline'var_'$n$}{
        $(\env'', \store''[\loc \mapsto$ \eval{$e_1$}{$\mem''$}$])$
      }
    } \\

    &$\eq{\eqlabel{E-lval}}$
    &$\store''[\loc \mapsto$ \eval{$e_1$}{$\mem''$} $]$
    $(\env''($\lstinline'var_'$n))$ \\

    &$\eq{\eqlabel{env-get-1}}$
    &$\store''[\loc \mapsto$ \eval{$e_1$}{$\mem''$} $](\loc)$ \\

    &$\eq{\eqlabel{store-get-1}}$
    &\eval{$e_1$}{$\mem''$} \\

    &=
    & \eval{$e_1$}{$(\env'[\mbox{\lstinline'var_'}n \mapsto \loc], \store'[\loc \mapsto \bot])$} par définition de $\mem''$ \\

    && or \lstinline'var_'$n$ est une variable fraîche introduite par la traduction qui n'intervient \\
    && pas dans $p_1$, on peut donc remplacer $\env'[\mbox{\lstinline'var_'}n \mapsto \loc]$ et $\store'[\loc \mapsto \bot]$ \\
    && par $\env'$ et $\store'$. \\

    &=
    & \eval{$e_1$}{$(\env', \store')$} \\

    &=
    & \eval{$e_1$}{(\comps{$A_1$}{$\mem$})} par définition de $\mem'$\\

    &$\eq{\eqlabel{h1}}$& \eval{$p_1$}{$\mem$} \\
    &=& \eval{$p_1$}{$\mem$} $\land$ \eval{$p_2$}{$\mem$} {
      \scriptsize
      (car on est dans le cas \eval{$p_1$}{$\mem$} = false)} \\

    &$\eq{\eqlabel{P-and}}$& \eval{$p_1$~\lstinline'\&\&'~$p_2$}{$\mem$} \\
  \end{tabular}
  
  On a donc bien :

  \eval{$p_1$~\lstinline'&&'~$p_2$}{$\mem$} =
  \eval{\lstinline'var_'$n$}{(
    \comps{
      $A_1\semicolon~ \mbox{\lstinline'int var_'}n~\mbox{\lstinline'='}~e_1
      \semicolon~
      \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
      \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
    }{$\mem$}
    )}.
  ~\\
\end{proof}


\begin{proof}[Justification de la propriété~\ref{th:inclusion}.]~\\
  Par hypothèse, les traductions de $p_1$ et $p_2$ sont
  correctes, c'est-à-dire :

  \begin{center}
    \begin{tabular}{lr}
      $\env \subenv \env_1$ & \eqlabel{h3} \\
      $\store \subenv \store_1$
      où $(\env_1, \store_1) = $ \comps{$A_1$}{$(\env, \store)$}
      & \eqlabel{h4} \\
      $\env \subenv \env_2$ & \eqlabel{h5} \\
      $\store \subenv \store_2$
      où $(\env_2, \store_2) = $ \comps{$A_2$}{$(\env'_1, \store'_1)$}
      & \eqlabel{h6} \\
      où $\env'_1 = \env_1[\mbox{\lstinline'var_'}n \mapsto \loc]$
      et $\store'_1 = \store_1[\loc \mapsto \mbox{\eval{$e_1$}{$\mem$}}]$ &\\
    \end{tabular}
  \end{center}

  De manière informelle, les instructions générées
  \lstinline'int var_'$n$~\lstinline'='~$e_1$\semicolon
  et \lstinline'var_'$n$~\lstinline'='~$e_2$\semicolon ne modifient que la
  variable fraîche \lstinline'var_'$n$ et les hypothèses \eqlabel{h3} à
  \eqlabel{h6} nous assurent que les blocs $A_1$ et $A_2$ ne modifient pas les
  variables de la mémoire $\mem = (\env, \store)$.
  On en conclut donc que le fragment de programme instrumenté
  $A_1\semicolon~ \mbox{\lstinline'int var_'}n~\mbox{\lstinline'='}~e_1
  \semicolon~
  \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
  \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
  ne modifie pas la mémoire $\mem$.
  On a donc bien :

  $\env \subenv \env'$ et $\store \subenv \store'$ où
  $(\env', \store')$ =
  \comps{
    $A_1\semicolon~ \mbox{\lstinline'int var_'}n~\mbox{\lstinline'='}~e_1
    \semicolon~
    \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
    \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
  }{$(\env, \store)$}.
~\\
\end{proof}


\begin{proof}[Justification de la propriété~\ref{lem:noerror}.]~\\
  Par hypothèse, les traductions de $p_1$ et $p_2$ sont
  correctes, c'est-à-dire :

  \begin{center}
    \begin{tabular}{rclr}
      \comps{$A_1$}{$\mem$} & $\neq$ & $\errormem$ & \eqlabel{h7} \\
      \comps{$A_2$}{$\mem'_1$} & $\neq$ & $\errormem$ & \eqlabel{h8} \\
      && où $\mem_1 = (\env_1, \store_1) = \mbox{\comps{$A_1$}{$\mem$}}$ & \\
      && et $\mem'_1 = (\env_1[\mbox{\lstinline'var_'}n \mapsto \loc], \store_1[\loc \mapsto \mbox{\eval{$e_1$}{$\mem$}}])$ & \\
    \end{tabular}
  \end{center}

  Les hypothèses \eqlabel{h7} et \eqlabel{h8} et le fait que les fragments de
  code générés ne produisent pas d'erreur (seule la variable fraîche
  \lstinline'var_'$n$ est affectée) nous assurent que si $\mem$ n'est pas une
  mémoire d'erreur ($\mem$ ne peut pas être $\errormem$ puisque la
  traduction se serait arrêtée dès l'obtention de l'erreur).
  On a donc bien :

  \comps{
    $A_1\semicolon~ \mbox{\lstinline'int var_'}n~\mbox{\lstinline'='}~e_1
    \semicolon~
    \mbox{\lstinline'if(var_'}n\mbox{\lstinline')'} \bopen A_2\semicolon~
    \mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_2\semicolon \bclose$
  }{$\mem$} $\neq \errormem$.
~\\
\end{proof}


\subsection{Justification de correction de la traduction des annotations}
\label{sec:annotation-translation}


Nous allons maintenant prouver les propriétés~\ref{th:error} et
\ref{th:inclusion} pour chaque classe d'annotations : les assertions, les
contrats de boucle et les contrats de fonction.
Ces justifications s'appuient sur la correction de la traduction des termes et
des prédicats justifiée dans les parties précédentes.


\subsection{Justification de correction de la traduction des assertions}

La règle de traduction d'une annotation \lstinline'assert' est la suivante :

\begin{center}
{\myinference{$\alpha$-assert}
  {(l, p) \prule (I, e)}
  {(l, \mbox{\lstinline'assert'}~p\semicolon)
    \arule I \concat (l, \mbox{\lstinline'fassert('}e\mbox{\lstinline');'})}{}
}
\end{center}

Les propriétés~\ref{th:error} et~\ref{th:inclusion} sont déclinées sur le cas
de l'assertion :

Propriété~\ref{th:error}.\\
Prouvons que pour toute mémoire $\mem$ :
\comp{
  \lstinline'/*@ assert'~$p$\semicolon\lstinline'*/ ;'
}{$\mem$} = $\errormem$
si \comps{
  $A\semicolon~ \mbox{\lstinline'fassert('}e\mbox{\lstinline');'}$
}{$\mem$} = $\errormem$,
où le fragment de programme $A$ est obtenu à partir de la séquence d'insertions
de code $I$ selon les règles d'insertion énoncées dans la
partie~\ref{sec:principles}.

Propriété~\ref{th:inclusion}.\\
Prouvons que si l'\lstinline'assert' est valide, alors
$\env \subenv \env'$ et $\store \subenv \store'$, où $(\env', \store') =$
\comps{
  $A\semicolon~ \mbox{\lstinline'fassert('}e\mbox{\lstinline');'}$
}{$(\env, \store)$}.

Nous les justifions une à une :

\begin{proof}[Justification de la propriété~\ref{th:error}]~\\
  Par hypothèse, la traduction de $p$ est correcte, c'est-à-dire :

  \begin{center}
    \begin{tabular}{rclr}
      \eval{$e$}{(\comps{$A$}{$\mem$})}
      &=& \eval{$p$}{$\mem$} & \eqlabel{h1} \\
      \comps{$A$}{$\mem$} & $\neq$ & $\errormem$ & \eqlabel{h2} \\
    \end{tabular}
  \end{center}

  Supposons que le code généré à partir de l'\lstinline'assert' produit une
  erreur :

  \begin{center}
    \begin{tabular}{rclr}
      \comps{
        $A\semicolon~ \mbox{\lstinline'fassert('}e\mbox{\lstinline');'}$
      }{$\mem$}
      & = & $\errormem$ & \eqlabel{h3} \\
    \end{tabular}
  \end{center}

  et prouvons que l'\lstinline'assert' est invalide :
  \comp{
    \lstinline'/*@ assert'~$p$\semicolon\lstinline' */ ;'
  }{$\mem$} = $\errormem$.

  Nous distinguons deux cas quant à la valeur de $e$.

  (a) Cas où \eval{$e$}{(\comps{$A$}{$\mem$})} $\neq 0$, c'est-à-dire
  par hypothèse \eqlabel{h1} : \eval{$p$}{$\mem$} = true ($\neq 0$).
  Prouvons que l'exécution du code généré ne produit pas $\errormem$.
  Développons \comps{
    $A\semicolon~ \mbox{\lstinline'fassert('}e\mbox{\lstinline');'}$
  }{$\mem$} :

  \begin{tabular}{rcl}
    \comps{
      $A\semicolon~ \mbox{\lstinline'fassert('}e\mbox{\lstinline');'}$
    }{$\mem$}
    &$\eq{\eqlabel{C-seq-1}}$
    & \comp{\lstinline'fassert('$e$\lstinline');'}{(\comps{$A$}{$\mem$})} \\
    &$\eq{\eqlabel{C-fassert}}$
    & \comps{$A$}{$\mem$}{
      \scriptsize (car \eval{$e$}{(\comps{$A$}{$\mem$})} $\neq 0$)} \\
  \end{tabular}

  D'autre part, l'hypothèse \eqlabel{h3} nous donne :
  \comps{
    $A\semicolon~ \mbox{\lstinline'fassert('}e\mbox{\lstinline');'}$
  }{$\mem$} = $\errormem$.
  On obtient par transitivité de l'égalité : \comps{$A$}{$\mem$} = $\errormem$,
  ce qui contredit l'hypothèse \eqlabel{h2} selon laquelle
  \comps{$A$}{$\mem$} $\neq \errormem$.
  Ce cas aboutit donc à une contradiction.

  (b) Cas où \eval{$e$}{(\comps{$A$}{$\mem$})} = 0, c'est-à-dire
  par hypothèse \eqlabel{h1} : \eval{$p$}{$\mem$} = false (= 0).
  Développons
  \comp{\lstinline'/*@ assert'~$p$\semicolon\lstinline' */ ;'}{$\mem$} :

  \begin{tabular}{rcl}
    \comp{\lstinline'/*@ assert'~$p$\semicolon\lstinline' */ ;'}{$\mem$}
    &$\eq{\eqlabel{C-assert}}$
    & $\errormem${} {\scriptsize (car \eval{$p$}{$\mem$} = 0)} \\
  \end{tabular}

  Nous avons ainsi prouvé que si le code traduisant une assertion provoque une
  erreur alors l'assertion en question est invalide :
  
  \comps{
    $A\semicolon~ \mbox{\lstinline'fassert('}e\mbox{\lstinline');'}$
  }{$\mem$} = $\errormem$
  $\Rightarrow$
  \comp{
    \lstinline'/*@ assert'~$p$\semicolon\lstinline' */ ;'
  }{$\mem$} = $\errormem$.
  ~\\
\end{proof}


\begin{proof}[Justification de la propriété~\ref{th:inclusion}]~\\
  Par hypothèse, la traduction de $p$ est correcte, c'est-à-dire :

  \begin{center}
    \begin{tabular}{lr}
      $\env \subenv \env''$ & \eqlabel{h4} \\
      $\store \subenv \store''$  & \eqlabel{h5} \\
      où $(\env'', \store'') = $ \comps{$A$}{$(\env, \store)$} & \\
    \end{tabular}
  \end{center}

  On doit prouver $\env \subenv \env'$ et $\store \subenv \store'$,
  avec $(\env', \store') =$
  \comps{
    $A\semicolon~ \mbox{\lstinline'fassert('}e\mbox{\lstinline');'}$
  }{$(\env, \store)$}.

  Or, nous avons montré (voir justification de la propriété~\ref{th:error}) que
  si l'assertion est valide, alors
  \comps{
    $A\semicolon~ \mbox{\lstinline'fassert('}e\mbox{\lstinline');'}$
  }{$\mem$} = \comps{$A$}{$\mem$}.
  Cette égalité nous donne également $(\env', \store') = (\env'', \store'')$.
  En remplaçant $\env'$ par $\env''$, $\store'$ par $\store''$ et
  \comps{
    $A\semicolon~ \mbox{\lstinline'fassert('}e\mbox{\lstinline');'}$
  }{$(\env, \store)$} par \comps{$A$}{$(\env, \store)$}, la propriété à prouver
  est rendue triviale grâce aux hypothèses \eqlabel{h4} et \eqlabel{h5}.
  ~\\
\end{proof}


\subsection{Justification de correction de la traduction des contrats de
  boucles}


Donnons une intuition de la preuve des propriétés~\ref{th:error}
et~\ref{th:inclusion} dans le cas des contrats de boucles.
Nous considérons une boucle \lstinline'while' annotée dont le contrat est
composé d'un \lstinline'loop invariant', d'un \lstinline'loop variant' et
d'une clause \lstinline'loop assigns'.
La traduction utilise les trois règles suivantes :


{\scriptsize
  {\myinference{$\alpha$-check-loop-assigns}
    {
      \forall (x:ctype) \in G-X :
      (
      (BegIter_l, x) \trule (I_1, e_1) \\
      (EndIter_l, x) \trule (I_2, e_2)
      )
    }
    {
      \splitfrac{
        (l, \mbox{\lstinline'loop assigns'}~X\semicolon) \arule
      } {
        \splitfrac{
          \forall (x:ctype) \in G-X :
        }{
          (I_1 \concat I_2 \concat (BegIter_l,
          ctype~\mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_1\semicolon)
          \concat (EndIter_l,
          \mbox{\lstinline'fassert('}e_2~\mbox{\lstinline'== var_'}n\mbox{\lstinline');'}) )
        }
      }
    }{}
  }
}

{\scriptsize
  {\myinference{$\alpha$-check-invariant}
    {(l, p) \prule (I_1, e_1) \\
      (EndIter_l, p) \prule (I_2, e_2)}
    {
      (l, \mbox{\lstinline'loop invariant'}~p\semicolon) \arule
      I_1 \concat (l, \mbox{\lstinline'fassert('}e_1\mbox{\lstinline');'})
      \concat I_2 \concat
      (EndIter_l, \mbox{\lstinline'fassert('}e_2\mbox{\lstinline');'})
    }{}
  }
}

{\scriptsize
  {\myinference{$\alpha$-variant}
    {
      (BegIter_l, t) \trule (I_1, e_1) \\
      (EndIter_l, t) \trule (I_2, e_2)
    }
    {
      \splitfrac{
        (l, \mbox{\lstinline'loop variant'}~t\semicolon) \arule
      }{
        I_1 \concat (BegIter_l,
        \mbox{\lstinline'fassert('}
        \underline{\mbox{\lstinline'0 <='}~e_1}
        \mbox{\lstinline');'})
        \concat I_2
        \concat(EndIter_l,
        \mbox{\lstinline'fassert('}
        \underline{e_2\Zclear \mbox{\lstinline'<'}~e_1 \Zclear}
        \mbox{\lstinline');'})
      }
    }{}
  }
}


La figure~\ref{fig:proof-loop-contract} illustre la démarche à partir de ces
règles.
La partie gauche de la figure montre une boucle disposant d'un contrat de boucle
(\lstinline'loop invariant', \lstinline'loop assigns' et
\lstinline'loop variant') au label $l$, avec un corps quelconque $A$.
En partie droite est affiché le code résultant de la traduction de cette
boucle, où chaque ensemble d'instructions (regroupées avec une accolade) est
mis en relation avec l'annotation du programme original dont il est la
traduction.
$\mathit{Spec2Code}(p, e_1)$ est une notation signifiant que $p$ se traduit en
$e_1$, en accord avec la règle \textsc{$\alpha$-check-invariant}.

Si l'invariant (ligne 2) n'est pas établi avant la boucle, alors on obtient
la mémoire d'erreur (cas \eqlabel{C-while-1}), ce qui correspond au cas où le
\lstinline'fassert' des lignes 2--3 du code généré renvoie faux.
Si la condition de boucle (ligne 5) est fausse, la mémoire est inchangée
(cas \eqlabel{C-while-2}) car le code que nous générons n'impacte pas les
variables du programme original, donc la condition de boucle $e$ a la
même valeur en chaque point dans le programme original et le programme
instrumenté.
Si le variant de la boucle (ligne 4) est négatif au début de la boucle, on
obtient la mémoire d'erreur (cas \eqlabel{C-while-3}), ce qui correspond au cas
où le \lstinline'fassert' des lignes 9--10 du code généré renvoie faux.
Si l'invariant de boucle n'est pas préservé à la fin de l'itération de boucle,
la mémoire d'erreur est obtenue (cas \eqlabel{C-while-4}), ce qui
correspond au cas où le \lstinline'fassert' des lignes 13--14 du code généré
renvoie faux.
Si le variant ne décroît pas strictement entre deux itérations de boucle, alors
la mémoire d'erreur est obtenue (cas \eqlabel{C-while-5}), ce qui
correspond au cas où le \lstinline'fassert' des lignes 18--19 du code généré
renvoie faux (la comparaison est faite avec la valeur du variant mémorisée à la
ligne 9).
Si une left-value n'appartenant pas à la clause assigns (ligne 3) a été modifiée
par la boucle, alors la mémoire d'erreur est obtenue (cas \eqlabel{C-while-6}),
ce qui correspond au cas où l'un des \lstinline'fassert' des lignes 15--17 du
code généré renvoie faux.
Ces comparaisons de valeurs sont faites avec les valeurs mémorisées aux lignes
6--8 du code généré.

\input{figures/fig_proof_loop_contract}


\subsection{Justification de correction de la traduction des contrats de
  fonctions}


Donnons maintenant une intuition de la preuve des propriétés~\ref{th:error}
et~\ref{th:inclusion} dans le cas des contrats de fonctions.
Il nous faut distinguer deux cas : le
cas où la fonction est ``sous vérification'' -- c'est-à-dire où c'est la
fonction de plus haut niveau et sa précondition est supposée vraie -- et le cas
où la fonction est appelée -- et sa précondition doit être vérifiée au point
d'appel.
Nous traitons les deux cas de manière séparée dans les deux sous-parties
suivantes.


\subsubsection{Fonction sous vérification}


\input{figures/fig_proof_fct_contract_main}


Nous considérons une fonction $f$ sous vérification annotée, dont le
contrat est composé d'une clause \lstinline'requires', d'une clause
\lstinline'assigns' et d'une clause \lstinline'ensures'.
La traduction utilise les trois règles suivantes :

{\scriptsize
  {\myinference{$\alpha$-assume-pre\hspace{-2mm}}
    {(Beg_f, p) \prule (I, e)}
    {(Beg_f, \left \{\hspace{-2mm}
      \begin{array}{r}
        \mbox{\lstinline'typically'} \\
        \mbox{\lstinline'requires'}
      \end{array} p\semicolon \right.
      )
      \arule
      I \concat
      (Beg_f, \mbox{\lstinline'fassume('}e\mbox{\lstinline');'})
    }{}
  }
}

{\scriptsize
  {\myinference{$\alpha$-check-assigns}
    {
      \forall (x:ctype) \in G-X :
      (
      (Beg_f, x) \trule (I_1, e_1) \\
      (End_f, x) \trule (I_2, e_2)
      )
    }
    {
      \splitfrac{
        (End_f, \mbox{\lstinline'assigns'}~X\semicolon) \arule
      } {
        \splitfrac{
          \forall (x:ctype) \in G-X :
        }{
          (I_1 \concat I_2 \concat (Beg_f,
          ctype~\mbox{\lstinline'var_'}n~\mbox{\lstinline'='}~e_1\semicolon)
          \concat (End_f,
          \mbox{\lstinline'fassert('}e_2~\mbox{\lstinline'== var_'}n\mbox{\lstinline');'}) )
        }
      }
    }{}
  }
}

{\scriptsize
  {\myinference{$\alpha$-check-post}
    {(End_f, p) \prule (I, e)}
    {(End_f, \mbox{\lstinline'ensures'}~p\semicolon)
      \arule
      I \concat (End_f, \mbox{\lstinline'fassert('}e\mbox{\lstinline');'})}{}
  }
}


La figure~\ref{fig:proof-fct-contract-main} illustre la justification de
correction de la traduction des contrats pour la fonction sous vérification sur
un schéma générique normalisé de fonction.
La partie gauche de la figure montre une fonction $f$ disposant d'un
contrat, avec un corps quelconque $A$.
En partie droite est affiché le code résultant de la traduction de cette
fonction, où chaque ensemble d'instructions (regroupées avec une accolade) est
mis en relation avec l'annotation du programme original dont il est la
traduction.

Par hypothèse, la précondition de la fonction sous vérification est vraie, ce
qui correspond aux lignes 3--4 du code généré.
Si la fonction modifie une des left-values n'appartenant pas à la clause
assigns, alors la mémoire d'erreur est obtenue (cas \eqlabel{f-2}), ce qui
correspond au cas où l'un des \lstinline'fassert' des lignes 10--12 du code
généré renvoie faux.
Si la postcondition n'est pas vérifiée à la fin de la fonction, on obtient
la mémoire d'erreur (cas \eqlabel{f-3}), ce qui correspond au cas où le
\lstinline'fassert' des lignes 13--14 du code généré renvoie faux.


\subsubsection{Fonctions appelées}

\input{figures/fig_proof_fct_contract_call}

Considérons enfin une fonction $f$ appelée, dont le contrat est
composé d'une clause \lstinline'requires', d'une clause \lstinline'assigns' et
d'une clause \lstinline'ensures'.
La traduction des contrats d'une fonction appelée réutilise les règles
\textsc{$\alpha$-check-assigns} et \textsc{$\alpha$-check-post} de la partie
précédente.
En revanche, afin de vérifier la précondition d'une fonction appelée et non la
supposer vraie, la règle \textsc{$\alpha$-assume-pre} est remplacée par la règle
\textsc{$\alpha$-check-pre} :

{\scriptsize
  {\myinference{$\alpha$-check-pre\hspace{-2mm}}
    {(Beg_f, p) \prule (I, e)}
    {(Beg_f, \mbox{\lstinline'requires'}~p\semicolon)
      \arule
      I \concat (Beg_f, \mbox{\lstinline'fassert('}e\mbox{\lstinline');'})
    }{}
  }
}

La figure~\ref{fig:proof-fct-contract-call} illustre la justification de
correction de la traduction des contrats pour les fonctions appelées.
La partie gauche de la figure montre une fonction $f$ disposant d'un
contrat, avec un corps quelconque $A$.
En partie droite est affiché le code résultant de la traduction de cette
fonction, où chaque ensemble d'instructions (regroupées avec une accolade) est
mis en relation avec l'annotation du programme original dont il est la
traduction.

Si la précondition n'est pas vérifiée au début de la fonction, alors
la mémoire d'erreur est obtenue (cas \eqlabel{f-1}), ce qui correspond aux
lignes 3--4 du code généré.
Si la fonction modifie une des left-values n'appartenant pas à la clause
assigns, alors la mémoire d'erreur est obtenue (cas \eqlabel{f-2}), ce qui
correspond au cas où l'un des \lstinline'fassert' des lignes 10--12 du code
généré renvoie faux.
Si la postcondition n'est pas vérifiée à la fin de la fonction, on obtient
la mémoire d'erreur (cas \eqlabel{f-3}), ce qui correspond au cas où le
\lstinline'fassert' des lignes 13--14 du code généré renvoie faux.


\section*{Conclusion du chapitre}

L'objectif de ce chapitre était de définir une traduction en C des annotations
\eacsl pour la génération de tests et de fournir une justification de la
correction de cette traduction.

Nous avons tout d'abord présenté le processus de la traduction dans sa
généralité.
Puis nous avons défini les règles permettant pour chaque terme et prédicat
\eacsl d'obtenir un code C calculant cette expression tout en préservant la
sémantique d'\eacsl.
Ces règles nous ont permis de définir différentes manières de traduire les
annotations \eacsl : \lstinline'assert', \lstinline'requires',
\lstinline'typically', \lstinline'assigns', \lstinline'ensures',
\lstinline'loop invariant', \lstinline'loop assigns' et
\lstinline'loop variant'.
Ces différentes instrumentations des annotations nous permettront par la suite
de détecter différentes erreurs dans le code et la spécification.

Grâce à notre justification de correction, nous pouvons assurer l'absence de
faux positifs lors de la génération de tests sur le programme instrumenté : si
une erreur est trouvée par la génération de tests alors il y a une erreur dans
le programme d'origine.
Cette propriété est énoncée comme une implication si l'on considère le langage
C et le langage \eacsl dans leur ensemble, mais si on se restreint au
sous-ensemble du langage décrit par la grammaire du chapitre précédent elle
s'énonce comme une équivalence, c'est-à-dire que toute erreur dans le programme
original est également trouvée par la génération de tests.

La justification de cette propriété est fournie de manière formelle pour les
assertions et de manière informelle mais intuitive et rigoureuse pour les
contrats de boucle et les contrats de fonction.
