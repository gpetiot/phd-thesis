
\chapter{Programmes C annotés avec E-acsl}
\label{sec:lang}

\chapterintro


Ce chapitre présente le sous-ensemble du langage C et du langage \eacsl que nous
traitons.
Dans la partie~\ref{sec:lang-syntax} nous présentons la syntaxe du langage
illustrée par un exemple.
C'est la syntaxe normalisée de programmes C annotés par des clauses E-ACSL.
Dans la partie~\ref{sec:lang-semantics} nous définissons la notion de mémoire
ainsi que les fonctions permettant de décrire la sémantique dénotationnelle de
chaque élément du langage.


\section{Syntaxe des programmes annotés}
\label{sec:lang-syntax}


Le langage de spécification \eacsl est un sous-langage exécutable d'\acsl, qui
est un langage de spécification comportementale implémenté dans \framac.
Premièrement, étant un sous-ensemble d'\acsl, \eacsl préserve la sémantique
d'\acsl, ce qui implique que les greffons de \framac existants supportant \acsl
peuvent être utilisés avec \eacsl sans modification.
Deuxièmement, le langage \eacsl est \textit{exécutable}, ce qui veut dire que
toutes les annotations peuvent être traduites en C et leur traduction peut être
exécutée pour l'analyse dynamique et le \textit{monitoring} (surveillance
d'exécution).


\subsection{Exemple de fonction C normalisée}
\label{sec:translation-example}


\lstinputlisting[style=c,escapechar=§,caption={Fonction C annotée décidant si
    \lstinline{v} est présent dans le tableau \lstinline{t} de taille
    \lstinline{n}},
  label=lst:normalized]{listings/is_present_normalized.c}

Nous présentons dans le listing~\ref{lst:normalized} un exemple de fonction sous
test normalisée en suivant la grammaire de la figure~\ref{fig:gram-c}.
La clause \lstinline'ensures' aux lignes 4--5 indique qu'elle retourne $1$ quand
la valeur \lstinline'v' en paramètre est présente dans le tableau \lstinline't'
de longueur \lstinline'n' en paramètre, et $0$ sinon.

La clause \lstinline'requires' de la ligne 1 indique que la taille du tableau
\lstinline'n' est positive ou nulle.
La clause \lstinline'requires' de la ligne 2 indique que \lstinline'(t+0)',
\ldots, \lstinline'(t+(n-1))' sont des pointeurs valides.
La clause \lstinline'typically' de la ligne 3 est une extension de la syntaxe
d'\eacsl définissant une précondition pour le test.
Elle renforce la précondition pour limiter l'explosion combinatoire du nombre de
chemins à explorer par la génération de tests, elle permet d'obtenir une
couverture partielle des chemins : seuls les chemins satisfaisant cette clause
sont considérés.
Ici elle limite l'espace des états de \lstinline'n' (et donc la taille de
\lstinline't') à $[0, 6]$ (cela peut être vu comme une ``finitization''
\cite{\citekorat}).
L'invariant de boucle de la ligne 9 spécifie des bornes pour \lstinline'i'
sur l'ensemble des itérations de la boucle.
Le variant de boucle ligne 10 permet de vérifier la terminaison de la boucle.
La postcondition des lignes 4--5 définit que \lstinline'\result' est non nul si
et seulement s'il existe un élément de \lstinline't' égal à \lstinline'v'.
Notons que pour prouver formellement la postcondition, l'invariant de boucle
suivant est nécessaire, mais n'est pas inclus dans cet exemple simplifié :
\lstinline'\forall integer k; 0<=k<=i-1 ==> \old(*(t+k))!=v;'.


\subsection{Syntaxe des instructions et fonctions}

\input{figures/fig_grammar}

Nous supposons que les fonctions respectent la forme normale définie par
l'entité syntaxique \textit{function} de la grammaire définie dans la
figure~\ref{fig:gram-c}.
Pour des raisons de commodité, nous considérons qu'un label précède chaque
annotation à l'intérieur d'une fonction.
Nous considérons aussi qu'un label est présent au début et à la fin de chaque
corps de boucle.
Dans la figure~\ref{fig:gram-c}, la notation ``${\textit{as}\;X}$'' en exposant
signifie que chaque occurrence de $X$ dans la règle courante doit être remplacée
par la chaîne à laquelle on fait référence en exposant.
Par exemple, si \texttt{foo} est le nom (\textit{id}) de la fonction sous test,
la règle \textit{function} indique que les labels $\texttt{Beg}_f$ et
$\texttt{End}_f$ dans le corps de cette fonction doivent être
$\texttt{Beg}_{\texttt{foo}}$ et $\texttt{End}_{\texttt{foo}}$, ce qui assure des
labels uniques au début et à la fin du corps de la fonction.
Nous supposons qu'il existe une unique instruction \lstinline'return' à la fin
de chaque fonction, qu'elle retourne une variable appelée \lstinline'res' et que
cette variable n'entre pas en conflit avec une autre variable du programme.
Les accès aux pointeurs et aux tableaux sont notés \lstinline|*(p+i)|.
Les symboles terminaux sont \underline{soulignés}.
Les symboles non-terminaux sont en \textit{italique}.
\textit{left-value} est toute expression pouvant se trouver en
partie gauche d'une affectation (variable simple ou déréférencée).
Pour simplifier, \textit{basic-type} se limite aux types C \lstinline'int',
\lstinline'char' et \lstinline'long', et \textit{type} se limite aux types
simples (non pointeur) et aux pointeurs sur types simples.
\textit{label} respecte les mêmes contraintes que \textit{id} mais fait
référence aux labels d'un programme C.
\textit{id} fait référence aux identificateurs de variable (et de fonctions)
autorisés dans le langage C : suite de caractères alphanumériques pouvant
contenir des ``\lstinline'_''' mais dont le premier caractère ne peut pas être
numérique.
Un contrat de fonction à la \eiffel~\cite{\citeeiffel} peut être associé à
chaque fonction pour spécifier les préconditions et postconditions.
La clause \lstinline'requires' d'un contrat de fonction désigne la précondition.
La clause \lstinline'typically' désigne la précondition pour le test, comme son
nom l'indique elle est spécifique au test et permet de limiter l'explosion
combinatoire du nombre de chemins.
La clause \lstinline'assigns' liste les termes pouvant être modifiés par la
fonction (c'est une sur-approximation).
La clause \lstinline'ensures' désigne la postcondition de la fonction.
Les assertions peuvent être associées à des instructions quelconques.
Un invariant de boucle, un variant (qui garantit la terminaison)
et une clause \lstinline'loop assigns' doivent être associés aux boucles.


\subsection{Syntaxe des termes \eacsl et des expressions C}

\input{figures/fig_grammar_exp_term}

La figure~\ref{fig:gram-exp-term} définit la grammaire des termes \eacsl et des
expressions C du langage.
\textit{cst} est toute constante du langage C : constante entière, chaîne de
caractère littérale, constante flottante, etc.
Les termes \eacsl peuvent être vus comme une extension des expressions C.
Ils peuvent être d'un type C (comme une expression C) ou d'un type logique (nous
nous limitons à \lstinline'integer' dans nos travaux).
Les termes sont ``purs'', c'est-à-dire qu'ils sont sans effet de bord.
De même, nous nous limitons aux expressions C ``pures''.
Pour cette raison, nous ne considérons pas les expressions comme \lstinline'x++'
ou \lstinline'++x'.
Pour cette même raison, les appels de fonction -- pouvant produire des effets 
de bord -- sont considérés non pas comme des expressions (qui ne peuvent pas
générer d'effets de bord) mais comme des instructions.
Les instructions de la forme \textit{id} \underline{\lstinline'('}
\textit{exp}$^{*}$ \underline{\lstinline');'} (respectivement
\textit{left-value} \underline{\lstinline'='} \textit{id}
\underline{\lstinline'('} \textit{exp}$^{*}$ \underline{\lstinline');'}) de la
figure~\ref{fig:gram-c} correspondent respectivement aux appels de fonction sans
(resp. avec) affectation de la valeur de retour.
Le terme \lstinline'\abs' fait référence à la valeur absolue d'un terme.
\lstinline'\sum(t1, t2, \lambda integer k; t3)' est la somme généralisée
$\sum_{\mbox{\lstinline'k = t1'}}^{\mbox{\lstinline't2'}}\mbox{\lstinline't3'}$.
\lstinline'\product(t1, t2, \lambda integer k; t3)' est le produit
généralisé $\Pi_{\mbox{\lstinline'k = t1'}}^{\mbox{\lstinline't2'}}\mbox{\lstinline't3'}$.
\lstinline'\numof(t1, t2, \lambda integer k; t3)' fait référence au nombre de
\lstinline'k' tel que
$\mbox{\lstinline't1'} \le \mbox{\lstinline'k'} \le \mbox{\lstinline't2'}$ et
$\mbox{\lstinline't3'} \neq 0$.
Le terme \lstinline'\old' fait référence à la valeur du terme au début de la
fonction courante.
\lstinline'\null' est le terme correspondant au pointeur \lstinline'NULL'.
\lstinline{\result} fait référence au résultat d'une fonction.


\subsubsection{Entiers mathématiques}
\label{sec:eacsl-integers}


En plus des entiers machine, les termes \eacsl peuvent être des entiers
mathématiques de type \lstinline{integer} qui sont définis sur l'ensemble
$\mathbb{Z}$ : les constantes entières, les
opérations sur les entiers, ainsi que les variables logiques sont de type
\lstinline{integer}.
L'arithmétique entière est non bornée et donc les débordements d'entier
(\textit{overflows}) sont impossibles.
\eacsl dispose d'un système de sous-typage pour convertir automatiquement les
types entiers du C vers les entiers mathématiques.
Par exemple, si \lstinline{x} est une variable C de type \lstinline{int},
\lstinline{1} et \lstinline{x+1} sont de type \lstinline{integer} et une
conversion implicite d'\lstinline{int} vers \lstinline{integer} est introduite
dans ce contexte quand la variable \lstinline{x} est typée.
Ce choix a été fait pour plusieurs raisons.
Premièrement, un des buts principaux de \framac est la preuve de programmes par
appel à des prouveurs externes.
Or, la plupart de ces prouveurs fonctionnent mieux
avec l'arithmétique entière qu'avec l'arithmétique bornée (ou modulaire).
Deuxièmement, les spécifications sont habituellement écrites sans se préoccuper
des détails d'implémentation, et les débordements d'entiers sont des détails
d'implémentation.
Troisièmement, il reste possible d'utiliser l'arithmétique bornée, si besoin
est, en utilisant des conversions explicites (\textit{casts}).
Par exemple, \lstinline{(int)(INT_MAX + 1)} est égal à \lstinline{INT_MIN}, la
plus petite valeur représentable de type \lstinline{int}.
Quatrièmement, ce choix facilite l'expression des débordements potentiels dans
les spécifications : par exemple, grâce à l'arithmétique entière,
\lstinline{/*@ assert INT_MIN <= x+y <= INT_MAX;*/} est le moyen le plus simple
de spécifier que \lstinline{x+y} ne déborde pas.
Dans la suite, sauf mention contraire, ``entier'' fait référence à
``entier non borné''.


\subsection{Syntaxe des prédicats \eacsl}

\input{figures/fig_grammar_pred}

La figure~\ref{fig:gram-pred} définit la grammaire des prédicats du langage
\eacsl.
Un prédicat a une valeur de vérité vraie ou fausse.
Le prédicat \lstinline'\valid' renvoie vrai si son argument est un pointeur
valide : c'est-à-dire \lstinline'\valid(ptr)' est vrai si et seulement si
on peut déréférencer \lstinline'ptr' et donc écrire \lstinline'*ptr'.
Dans le cas où son argument est de la forme \lstinline'ptr+(x..y)', le prédicat
est valide si et seulement si \lstinline'ptr+x', \lstinline'ptr+(x+1)', \ldots,
\lstinline'ptr+y' sont valides.
Les quantifications existentielles (\lstinline'\exists') et universelles
(\lstinline'\forall') doivent porter sur des domaines finis d'entiers.
Le symbole \lstinline'==>' encode l'implication logique et le symbole
\lstinline'<==>' encode l'équivalence logique de deux prédicats.


\section{Sémantique des programmes annotés}
\label{sec:lang-semantics}


Nous définissons maintenant la notion de mémoire d'un programme, comme un couple
environnement, $store$, définis respectivement ci-dessous en sections
?? et ??.
Cette notion de mémoire nous permet de définir la sémantique dénotationnelle des
instructions et fonctions d'un programme annoté par rapport à un environnement.
Dans la suite du document, nous utilisons les notations suivantes :
\begin{itemize}
\item $\mem$, $\mem'$, $\errormem$ sont des mémoires;
\item $\mathit{lv}$, $\mathit{lv_1}$ et $\mathit{lv_2}$ sont des left-values;
\item $\mathit{id}$, $\mathit{id_1}$ et $\mathit{id_N}$ sont des identificateurs
  de variable;
\item $f$ est un identificateur de fonction;
\item $v$ est une valeur;
\item $\mathit{cst}$ est une constante;
\item $G$ et $X$ sont des listes de termes \eacsl;
\item $i$, $i_1$, $i_2$ sont des instructions C;
\item $A$ et $B$ sont des blocs d'instructions C;
\item $e$, $e_1$, $e_2$, $e_N$ sont des expressions C;
\item $t$, $t_1$, $t_2$ et $t_3$ sont des termes \eacsl;
\item $p$, $p_1$, $p_2$ sont des prédicats \eacsl;
\item $T$ est un type C;
\item $\mathit{unop}$ est un opérateur unaire;
\item $\mathit{binop}$ est un opérateur binaire;
\item $\mathit{rel}$ est un opérateur binaire relationnel.
\end{itemize}


\subsection{Environnements}


Le domaine $LV$ correspond à l'entité syntaxique \textit{left-value}.
$LOC$ est le domaine des adresses (locations en mémoire), incluant l'adresse
nulle, notée \lstinline'NULL'.

Un environnement $\env$ est une fonction totale
$\env \in LV \rightarrow LOC \cup \{\bot\}$
qui associe une adresse à une left-value.

$\bot$ dénote une adresse indéfinie et donc invalide.
Nous notons $ENV \subseteq LV \rightarrow LOC \cup \{\bot\}$ le domaine des
environnements.
La notation $\env$[$\mathit{lv} \mapsto \loc$] désigne un nouvel environnement,
correspondant à l'environnement $\env$ dans lequel la left-value $\mathit{lv}$
a l'adresse $\loc$.
L'accès à l'adresse d'une left-value $\mathit{lv}$ dans un environnement $\env$
est noté $\env(\mathit{lv})$.
Il est défini par :

\begin{center}
\begin{tabular}{rclr}
  ($\env$[$\mathit{lv} \mapsto \loc$])($\mathit{lv}$) &=& $\loc$
  & \eqlabel{env-get-1}\\
  ($\env$[$\mathit{lv_1} \mapsto \loc$])($\mathit{lv_2}$) & =
  & $\env$($\mathit{lv_2}$) si $\mathit{lv_1} \neq \mathit{lv_2}$
  & \eqlabel{env-get-2}\\
  $\env$($\mathit{lv}$) & = & $\bot$ (par défaut) & \eqlabel{env-get-3} \\
\end{tabular}
\end{center}

Dans la suite, nous utiliserons la notation
$\env$[$\mathit{lv_1} \mapsto \loc_1, \mathit{lv_2} \mapsto \loc_2$]
(en supposant que $\mathit{lv_1} \neq \mathit{lv_2}$)
comme un raccourci pour
$\env$[$\mathit{lv_1} \mapsto \loc_1$][$\mathit{lv_2} \mapsto \loc_2$].
La notation $\env - \{\mathit{lv}\}$ signifie que la left-value
$\mathit{lv}$ et son adresse sont enlevées de l'environnement $\env$ :

\begin{center}
\begin{tabular}{rclr}
  ($\env$[$\mathit{lv} \mapsto \loc$])$-~\{lv\}$ &=& $\env$
  & \eqlabel{env-del-1} \\
  ($\env$[$\mathit{lv_1} \mapsto \loc$])$-~\{\mathit{lv_2}\}$
  &=& ($\env - \{\mathit{lv_2}\}$)[$\mathit{lv_1} \mapsto \loc$] si
  $\mathit{lv_1} \neq \mathit{lv_2}$ & \eqlabel{env-del-2} \\
  $\env - \{\mathit{lv}\}$ &=& $\env$  si $\env(\mathit{lv})$ = $\bot$
  & \eqlabel{env-del-3} \\
\end{tabular}
\end{center}

Nous définissons également une relation d'inclusion sur les environnements,
c'est-à-dire $\env_1$ est inclus dans $\env_2$ si et seulement si pour chaque
paire $(\mathit{lv}, \loc)$ telle que : si $\loc$ est l'adresse de $\mathit{lv}$
dans $\env_1$, alors $\loc$ est aussi l'adresse de $\mathit{lv}$ dans $\env_2$.

\[
\env_1~\subenv~\env_2~\equiv~
\forall \mathit{lv}.~\forall \loc.
~(\env_1(\mathit{lv})=\loc) \Rightarrow (\env_2(\mathit{lv})=\loc)
\]


\subsection{Stores}


Le domaine des valeurs $VAL$ est défini comme l'union des types que
peuvent prendre les termes et prédicats \eacsl et les expressions C :
$VAL = \mathbb{B}~\cup~\mathbb{Z}~\cup~LOC~\cup~\{\bot\}$, où le symbole
$\bot$ dénote une valeur non initialisée.
$LOC \subset VAL$ car nous formalisons les pointeurs et la valeur d'un pointeur
est une adresse.
Un store est une fonction totale $\store \in LOC \rightarrow VAL$ qui
associe une valeur à une adresse.
Nous notons $STORE : LOC \rightarrow VAL$ le domaine des stores.
La notation $\store$[$\loc \mapsto v$] désigne un nouveau store, correspondant
au store $\store$ dans lequel la valeur $v$ est à l'adresse mémoire $\loc$.
L'accès à la valeur d'une adresse $\loc$ dans un store $\store$ est noté
$\store(\loc)$.
Il est défini par :

\begin{center}
\begin{tabular}{rclr}
  ($\store$[$\loc \mapsto v$])($\loc$) &=& $v$ & \eqlabel{store-get-1}\\
  ($\store$[$\loc_1 \mapsto v$])($\loc_2$) & =
  & $\store$($\loc_2$) si $\loc_1 \neq \loc_2$
  & \eqlabel{store-get-2}\\
  $\store$($\loc$) & = & $\bot$ (par défaut) & \eqlabel{store-get-3} \\
\end{tabular}
\end{center}

Dans la suite, nous utiliserons la notation
$\store$[$\loc_1 \mapsto v_1, \loc_2 \mapsto v_2$] (en supposant
que $\loc_1 \neq \loc_2$)
comme un raccourci pour
$\store$[$\loc_1 \mapsto v_1$][$\loc_2 \mapsto v_2$].
La notation $\store - \{\loc\}$ signifie que l'adresse
$\loc$ et la valeur associée sont enlevées du store $\store$ :

\begin{center}
\begin{tabular}{rclr}
  ($\store$[$\loc \mapsto v$])$-~\{\loc\}$ &=& $\store$
  & \eqlabel{store-del-1} \\
  ($\store$[$\loc_1 \mapsto v$])$-~\{\loc_2\}$
  &=& ($\store - \{\loc_2\}$)[$\loc_1 \mapsto v$] si
  $\loc_1 \neq \loc_2$ & \eqlabel{store-del-2} \\
  $\store - \{\loc\}$ &=& $\store$  si $\store(\loc)$ = $\bot$
  & \eqlabel{store-del-3} \\
\end{tabular}
\end{center}

Nous définissons également une relation d'inclusion sur les stores, c'est-à-dire
$\store_1$ est inclus dans $\store_2$ si et seulement si pour chaque
paire $(\loc, v)$ telle que : si $v$ est la valeur à l'adresse $\loc$
dans $\store_1$, alors $v$ est également à l'adresse $\loc$ dans $\store_2$.

\[
\store_1~\subenv~\store_2~\equiv~
\forall \loc.~\forall v.
~(\store_1(\loc)=v) \Rightarrow (\store_2(\loc)=v)
\]

\subsection{Sémantique Dénotationnelle des Termes, Prédicats et Expressions}

\input{figures/fig_semantics_exp_term}

La sémantique dénotationnelle des expressions C, des termes et des prédicats
\eacsl est exprimée avec la fonction
$\mathcal{E} : (EXP \cup TERM \cup PRED) \rightarrow (ENV \times STORE) \rightarrow VAL$.
Le domaines $EXP$, $TERM$ et $PRED$ correspondent respectivement aux entités
syntaxiques \textit{exp}, \textit{term} et \textit{pred} définies dans les
figures~\ref{fig:gram-exp-term} et~\ref{fig:gram-pred}.
Cette fonction associe une valeur à une expression C (ou un terme ou prédicat
\eacsl) en fonction d'une mémoire, à condition que cette expression ne
génère pas d'effet de bord, hypothèse satisfaite par le langage considéré après
normalisation du code par \framac.

La figure~\ref{fig:sem-exp-term} donne la sémantique des expressions et des
termes.
Ces deux éléments du langage se retrouvent sur la même figure car les termes
peuvent être vus comme une extension des expressions C.
Les cinq premières règles de la figure~\ref{fig:sem-exp-term} sont communes aux
termes et aux expressions, les autres sont spécifiques aux termes.
\commentGP{TODO: empiler contexte d'appel}
Dans la règle \eqlabel{E-old}, $\env_{Old}$ est l'environnement au début de la
fonction.

La figure~\ref{fig:sem-pred} donne la sémantique des prédicats.
La sémantique des prédicats est encodée par les entiers 0 et 1 comme en C.
La sémantique du prédicat \lstinline'\valid' est expliquée en
partie~\ref{sec:ptr-valid}.

\input{figures/fig_semantics_pred}


\subsection{Sémantique Dénotationnelle des Instructions}

Nous définissons une mémoire d'erreur, notée $\errormem$, de type
$ENV \times STORE$.
Une telle mémoire est le résultat de l'évaluation d'une instruction
provoquant une erreur (par exemple un appel à \lstinline'fassert' sur une
expression fausse) ou d'une annotation invalide (par exemple,
\lstinline'assert' ou \lstinline'loop invariant' faux).
L'évaluation des instructions s'arrête dès qu'un état d'erreur est produit.

La sémantique dénotationnelle des instructions C est exprimée avec la fonction
$\mathcal{C} : INSTR \rightarrow (ENV \times STORE) \rightarrow (ENV \times STORE)$.
Cette fonction associe à une instruction $i$, dans un contexte mémoire $\mem$,
une nouvelle mémoire $\mem'$ qui tient compte des effets de bord effectués par
$i$ dans $\mem$.
La sémantique d'une séquence d'instructions est exprimée avec la fonction
$\mathcal{C}^{*} : INSTR^{*} \rightarrow (ENV \times STORE) \rightarrow (ENV \times STORE)$.
Cette fonction revient à appeler successivement $\mathcal{C}$ sur chaque
instruction dans l'ordre de la séquence.

\begin{figure}
\begin{center}
\begin{tabular}{rcl}
  \comps{\lstinline'i;' $A$}{$\mem$}
  &=& \comps{$A$}{(\comp{\lstinline'i'}{$\mem$})} \\
  \comps{$\semicolon$}{$\mem$} &=& $\mem$ \\
\end{tabular}
\caption{Sémantique dénotationnelle des séquences d'instructions}
\end{center}
\end{figure}


\input{figures/fig_semantics}

La sémantique des instructions C est donnée en figure~\ref{fig:sem-instr}.
La règle \eqlabel{C-decl} ajoute une variable non initialisée (notée par le
symbole $\bot$) à l'environnement $\env$.
Dans la règle \eqlabel{C-Z-set}, la variable entière (GMP) $\mathit{lv}$ est
allouée et on lui affecte la valeur de $e$.
Dans la règle \eqlabel{C-Z-unset}, la variable entière (GMP) $\mathit{lv}$
est désallouée et enlevée de l'environnement $\env$.
Une instruction \underline{soulignée} manipule des entiers non bornés.

Nous définissons une fonction \lstinline'fassert' permettant de tester la valeur
d'une expression.
Cette fonction correspond à un \lstinline'if' dont la branche
\lstinline'else' génère une erreur et la rapporte.
Nous définissons également une fonction \lstinline'fassume' permettant de poser
une hypothèse de validité sur la valeur d'une expression.
Cette fonction correspond à un \lstinline'if' dont
la branche \textit{true} est toujours vraie, les exécutions pour lesquelles
la branche \textit{false} est activée sont ignorées.
Nous supposons enfin disposer d'une fonction \lstinline'fvalid' permettant
d'évaluer la validité d'un pointeur et d'une fonction \lstinline'fvalidr'
permettant d'évaluer la validité d'un pointeur sur un intervalle d'offsets.

La sémantique de la fonction \lstinline'fassert' donnée par la règle
\eqlabel{C-fassert} énonce que si l'expression $e$ s'évalue en une
expression non nulle, alors l'environnement $\env$ est inchangé, sinon on obtient
l'environnement d'erreur $\errormem$.
La sémantique de la fonction \lstinline'fassume' donnée par la règle
\eqlabel{C-fassume} énonce que l'expression $e$ est supposée vraie et
doit donc s'évaluer en une expression non nulle.
L'environnement est inchangé après cet appel de fonction.
$e$ ne peut pas s'évaluer en $0$ par définition de la fonction, si c'est
le cas on aboutit à une contradiction.

La sémantique des fonctions \lstinline'fvalid' et \lstinline'fvalidr' est donnée
par les règles \eqlabel{C-valid} et \eqlabel{C-validr}.
Elles énoncent que dans le nouvel environnement, la left-value $\mathit{lv}$ a
la valeur $1$ si les pointeurs en argument de la fonction sont valides, et $0$
sinon.
Plus de détails sur la sémantique de ces fonctions sont donnés en
partie~\ref{sec:ptr-valid}.

La sémantique des appels de fonction est donnée par les règles \eqlabel{C-fct1}
et \eqlabel{C-fct2}.
Dans ces règles, la sémantique de la fonction $f$ est calculée à
l'aide de la fonction $\mathcal{F}$ donnée en figure~\ref{fig:sem-fct}.
$\env[\mathit{id_1} \mapsto$ \eval{$e_1$}{$\env$}, ...,
  $\mathit{id_N} \mapsto$ \eval{$e_N$}{$\env$}] est l'environnement
dans lequel les paramètres effectifs (les expressions $e_1$, ..., $e_N$) sont
affectés aux paramètres formels (les identificateurs
$\mathit{id_1}$, ..., $\mathit{id_N}$).

La sémantique des assertions \eacsl donnée par la règle \eqlabel{C-assert} est
similaire à la sémantique de la fonction \lstinline'fassert'.
Si le prédicat $p$ s'évalue en une expression non nulle,
l'environnement $\env$ est inchangé, sinon l'environnement $\errormem$ est
obtenu.

La sémantique des boucles annotées par un contrat contenant un invariant
$p$, une liste de termes $X$ et un variant $t$ est
donnée par les règles \eqlabel{C-while-1} à \eqlabel{C-while-7}.
La règle \eqlabel{C-while-1} énonce que $\errormem$ est obtenu si l'invariant de
boucle n'est pas établi avant l'exécution du corps de la boucle.
La règle \eqlabel{C-while-2} énonce que l'environnement $\env$ est inchangé si
la condition de boucle $e$ s'évalue à $0$ et donc la boucle n'est pas
exécutée.
La règle \eqlabel{C-while-3} énonce que $\errormem$ est obtenu si le variant de
boucle n'est pas positif avant l'exécution de la boucle.
La règle \eqlabel{C-while-4} énonce que $\errormem$ est obtenu si l'invariant de
boucle n'est pas maintenu après l'exécution du corps de boucle.
L'environnement \comps{$A$}{$\env$} est obtenu après exécution du
corps de la boucle dans $\env$.
La règle \eqlabel{C-while-5} énonce que $\errormem$ est obtenu si le variant de
boucle ne décroît pas strictement entre le début et la fin de l'exécution du
corps de boucle.
La règle \eqlabel{C-while-6} énonce que $\errormem$ est obtenu si l'évaluation
d'un élément appartenant à $G-X$ (ensemble des left-values n'appartenant pas à
la clause \lstinline'loop assigns' de la boucle) est différente entre le début
et la fin de l'exécution du corps de la boucle.
La règle \eqlabel{C-while-7} énonce que si aucun des six cas précédents ne s'est
produit, il faut ré-évaluer la sémantique de la boucle dans l'environnement
obtenu après exécution du corps de la boucle dans $\env$.


\input{figures/fig_semantics_fct}


La sémantique dénotationnelle des fonctions est exprimée avec la fonction
$\mathcal{F} : FCT \rightarrow (ENV \times STORE) \rightarrow (ENV \times STORE)$ où $FCT$ correspond à
l'entité syntaxique \textit{function} définie par la figure~\ref{fig:gram-c}.
Cette fonction calcule un nouvel environnement et un nouveau store à partir
d'une fonction annotée, d'un environnement $\env$ et d'un store $\store$, ce qui
permet de traiter les appels de fonction (règles \eqlabel{C-fct1} et
\eqlabel{C-fct2} de la figure~\ref{fig:sem-instr}) et la fonction sous
vérification (qui n'est pas appelée).

La sémantique des fonctions est donnée en figure~\ref{fig:sem-fct}.
Si $f$ est la fonction sous vérification, alors sa
précondition $p_1$ est supposée vraie par définition.
Si la fonction considérée n'est pas la fonction sous vérification, alors la
règle \eqlabel{F-1} énonce que $\errormem$ est obtenu si le prédicat
$p_1$ s'évalue en faux.
Si $f$ est la fonction sous vérification, alors le prédicat
$p_1$ est vrai par hypothèse.
La règle \eqlabel{F-2} énonce que $\errormem$ est obtenu si l'évaluation
d'un élément appartenant à $G-X$ (ensemble des left-values n'appartenant pas à
la clause \lstinline'assigns' de la fonction) est différente entre le début
et la fin de l'exécution du corps de la fonction.
La règle \eqlabel{F-3} énonce que $\errormem$ est obtenu si le prédicat de la
postcondition $p_2$ est faux à la fin de la fonction.
Enfin, si aucun des trois cas précédents ne s'est produit, il faut calculer la
sémantique des instructions du corps de la fonction.


\subsection{Validité des pointeurs}
\label{sec:ptr-valid}
\commentGP{TODO: supprimer}
Un pointeur est valide en mémoire si on peut le déréférencer afin de pouvoir
accéder ou modifier l'emplacement mémoire qu'il référence (c'est-à-dire vers
lequel il pointe).
Un pointeur alloué dynamiquement (à l'aide de la fonction \lstinline'malloc' par
exemple) est valide tant qu'il n'est pas libéré (par la fonction
\lstinline'free').
Le pointeur égal à l'adresse d'une variable globale est toujours valide, et le
pointeur égal à l'adresse d'une variable locale est valide dans la portée de
cette variable.

Ainsi, le prédicat \lstinline'\valid(t)' est vrai si \lstinline't'
peut être déréférencé et est accessible en écriture, c'est-à-dire n'est pas une
constante.
De la même manière, \lstinline'\valid(t+(t1..t2))' est valide si les pointeurs
\lstinline'(t+t1)', ..., \lstinline'(t+t2)' peuvent être déréférencés et sont
accessibles en écriture.
L'expression de la sémantique dénotationnelle de ces prédicats requiert une
fonction $\mathcal{E}$ plus complexe et n'est pas donnée ici.

Afin de refléter le fonctionnement de ces prédicats, nous avons défini les
fonctions \lstinline'fvalid' et \lstinline'fvalidr'.
Grossièrement, \lstinline'fvalid(t)' a la même sémantique que
\lstinline'\valid(t)' et \lstinline'fvalidr(t,t1,t2)' a la même sémantique que
\lstinline'\valid(t+(t1..t2))'.
De la même manière, la sémantique dénotationnelle de ces fonctions requiert une
fonction $\mathcal{C}$ plus complexe et n'est pas donnée ici.

Ces fonctions seront utilisées au chapitre~\ref{sec:traduction}, Traduction en
C des annotations pour le Test, afin de générer du code C préservant la
sémantique du prédicat \lstinline'\valid'.
Le chapitre~\ref{sec:runtime}, Vérification à l'exécution des annotations liées
au modèle mémoire, présente la conception de telles fonctions permettant de
refléter la sémantique de \lstinline'\valid' et d'autres prédicats \eacsl liés
au modèle mémoire.


\section*{Conclusion du chapitre}

Dans ce chapitre nous avons présenté un sous-ensemble du langage C et du
langage \eacsl normalisé que nous traitons.
Nous avons défini la sémantique dénotationnelle de chaque élément du langage
pour pouvoir justifier de la correction de la traduction des annotations en C
dans le but de générer des tests.
Le chapitre~\ref{sec:traduction} présentera la traduction de ces annotations
\eacsl en code C sémantiquement équivalent.
