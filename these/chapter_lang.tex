
\chapter{Programmes C annotés avec E-acsl}
\label{sec:lang}

\chapterintro


Ce chapitre présente le sous-ensemble du langage C et du langage \eacsl que nous
traitons.
Dans la partie~\ref{sec:lang-syntax} nous présentons la syntaxe du langage
illustrée par un exemple.
C'est la syntaxe normalisée de programmes C annotés par des clauses E-ACSL.
Dans la partie~\ref{sec:lang-semantics} nous définissons la notion de mémoire
ainsi que les fonctions permettant de décrire la sémantique dénotationnelle de
chaque élément du langage.


\section{Syntaxe des programmes annotés}
\label{sec:lang-syntax}


Le langage de spécification \eacsl est un sous-langage exécutable d'\acsl, qui
est un langage de spécification comportementale implémenté dans \framac.
Premièrement, étant un sous-ensemble d'\acsl, \eacsl préserve la sémantique
d'\acsl, ce qui implique que les greffons de \framac existants supportant \acsl
peuvent être utilisés avec \eacsl sans modification.
Deuxièmement, le langage \eacsl est \textit{exécutable}, ce qui veut dire que
toutes les annotations peuvent être traduites en C et leur traduction peut être
exécutée pour l'analyse dynamique et le \textit{monitoring} (surveillance
d'exécution).


\subsection{Exemple de fonction C normalisée}
\label{sec:translation-example}


\lstinputlisting[style=c,escapechar=§,caption={Fonction C annotée décidant si
    \lstinline{v} est présent dans le tableau \lstinline{t} de taille
    \lstinline{n}},
  label=lst:normalized]{listings/is_present_normalized.c}

Nous présentons dans le listing~\ref{lst:normalized} un exemple de fonction sous
test normalisée en suivant la grammaire de la figure~\ref{fig:gram-c}.
La clause \lstinline'ensures' aux lignes 4--5 indique qu'elle retourne $1$ quand
la valeur \lstinline'v' en paramètre est présente dans le tableau \lstinline't'
de longueur \lstinline'n' en paramètre, et $0$ sinon.

La clause \lstinline'requires' de la ligne 1 indique que la taille du tableau
\lstinline'n' est positive ou nulle.
La clause \lstinline'requires' de la ligne 2 indique que \lstinline'(t+0)',
\ldots, \lstinline'(t+(n-1))' sont des pointeurs valides.
La clause \lstinline'typically' de la ligne 3 est une extension de la syntaxe
d'\eacsl définissant une précondition pour le test.
Elle renforce la précondition pour limiter l'explosion combinatoire du nombre de
chemins à explorer par la génération de tests, elle permet d'obtenir une
couverture partielle des chemins : seuls les chemins satisfaisant cette clause
sont considérés.
Ici elle limite l'espace des états de \lstinline'n' (et donc la taille de
\lstinline't') à $[0, 6]$ (cela peut être vu comme une ``finitization''
\cite{\citekorat}).
L'invariant de boucle de la ligne 9 spécifie des bornes pour \lstinline'i'
sur l'ensemble des itérations de la boucle.
Le variant de boucle ligne 10 permet de vérifier la terminaison de la boucle.
La postcondition des lignes 4--5 définit que \lstinline'\result' est non nul si
et seulement s'il existe un élément de \lstinline't' égal à \lstinline'v'.
Notons que pour prouver formellement la postcondition, l'invariant de boucle
suivant est nécessaire, mais n'est pas inclus dans cet exemple simplifié :
\lstinline'\forall integer k; 0<=k<=i-1 ==> \old(*(t+k))!=v;'.


\subsection{Syntaxe des instructions et fonctions}

\input{figures/fig_grammar}

Nous supposons que les fonctions respectent la forme normale définie par
l'entité syntaxique \textit{function} de la grammaire définie dans la
figure~\ref{fig:gram-c}.
Pour des raisons de commodité, nous considérons qu'un label précède chaque
annotation à l'intérieur d'une fonction.
Nous considérons aussi qu'un label est présent au début et à la fin de chaque
corps de boucle.
Dans la figure~\ref{fig:gram-c}, la notation ``${\textit{as}\;X}$'' en exposant
signifie que chaque occurrence de $X$ dans la règle courante doit être remplacée
par la chaîne à laquelle on fait référence en exposant.
Par exemple, si \texttt{foo} est le nom (\textit{id}) de la fonction sous test,
la règle \textit{function} indique que les labels $\texttt{Beg}_f$ et
$\texttt{End}_f$ dans le corps de cette fonction doivent être
$\texttt{Beg}_{\texttt{foo}}$ et $\texttt{End}_{\texttt{foo}}$, ce qui assure des
labels uniques au début et à la fin du corps de la fonction.
Nous supposons qu'il existe une unique instruction \lstinline'return' à la fin
de chaque fonction, qu'elle retourne une variable appelée \lstinline'res'$_f$ et
que cette variable n'entre pas en conflit avec une autre variable du programme.
Les accès aux pointeurs et aux tableaux sont notés \lstinline|*(p+i)|.
Les symboles terminaux sont \underline{soulignés}.
Les symboles non-terminaux sont en \textit{italique}.
\textit{left-value} est toute expression pouvant se trouver en
partie gauche d'une affectation (variable simple ou déréférencée).
Pour simplifier, \textit{basic-type} se limite aux types C \lstinline'int',
\lstinline'char' et \lstinline'long', et \textit{type} se limite aux types
simples (non pointeur) et aux pointeurs sur types simples.
\textit{label} respecte les mêmes contraintes que \textit{id} mais fait
référence aux labels d'un programme C.
\textit{id} fait référence aux identificateurs de variable (et de fonctions)
autorisés dans le langage C : suite de caractères alphanumériques pouvant
contenir des ``\lstinline'_''' mais dont le premier caractère ne peut pas être
numérique.
Un contrat de fonction à la \eiffel~\cite{\citeeiffel} peut être associé à
chaque fonction pour spécifier les préconditions et postconditions.
La clause \lstinline'requires' d'un contrat de fonction désigne la précondition.
La clause \lstinline'typically' désigne la précondition pour le test, comme son
nom l'indique elle est spécifique au test et permet de limiter l'explosion
combinatoire du nombre de chemins.
La clause \lstinline'assigns' liste les termes pouvant être modifiés par la
fonction (c'est une sur-approximation).
La clause \lstinline'ensures' désigne la postcondition de la fonction.
Les assertions peuvent être associées à des instructions quelconques.
Un invariant de boucle, un variant (qui garantit la terminaison)
et une clause \lstinline'loop assigns' doivent être associés aux boucles.


\subsection{Syntaxe des termes \eacsl et des expressions C}

\input{figures/fig_grammar_exp_term}

La figure~\ref{fig:gram-exp-term} définit la grammaire des termes \eacsl et des
expressions C du langage.
\textit{cst} est toute constante du langage C : constante entière, chaîne de
caractère littérale, constante flottante, etc.
Les termes \eacsl peuvent être vus comme une extension des expressions C.
Ils peuvent être d'un type C (comme une expression C) ou d'un type logique (nous
nous limitons à \lstinline'integer' dans nos travaux).
Les termes sont ``purs'', c'est-à-dire qu'ils sont sans effet de bord.
De même, nous nous limitons aux expressions C ``pures''.
Pour cette raison, nous ne considérons pas les expressions comme \lstinline'x++'
ou \lstinline'++x'.
Pour cette même raison, les appels de fonction -- pouvant produire des effets 
de bord -- sont considérés non pas comme des expressions (qui ne peuvent pas
générer d'effets de bord) mais comme des instructions.
Les instructions de la forme \textit{id} \underline{\lstinline'('}
\textit{exp}$^{*}$ \underline{\lstinline');'} (respectivement
\textit{left-value} \underline{\lstinline'='} \textit{id}
\underline{\lstinline'('} \textit{exp}$^{*}$ \underline{\lstinline');'}) de la
figure~\ref{fig:gram-c} correspondent respectivement aux appels de fonction sans
(resp. avec) affectation de la valeur de retour.
Le terme \lstinline'\abs' fait référence à la valeur absolue d'un terme.
\lstinline'\sum(t1, t2, \lambda integer k; t3)' est la somme généralisée
$\sum_{\mbox{\lstinline'k = t1'}}^{\mbox{\lstinline't2'}}\mbox{\lstinline't3'}$.
\lstinline'\product(t1, t2, \lambda integer k; t3)' est le produit
généralisé $\Pi_{\mbox{\lstinline'k = t1'}}^{\mbox{\lstinline't2'}}\mbox{\lstinline't3'}$.
\lstinline'\numof(t1, t2, \lambda integer k; t3)' fait référence au nombre de
\lstinline'k' tel que
$\mbox{\lstinline't1'} \le \mbox{\lstinline'k'} \le \mbox{\lstinline't2'}$ et
$\mbox{\lstinline't3'} \neq 0$.
Le terme \lstinline'\old' fait référence à la valeur du terme au début de la
fonction courante.
\lstinline'\null' est le terme correspondant au pointeur \lstinline'NULL'.
\lstinline{\result} fait référence au résultat d'une fonction.


\subsubsection{Entiers mathématiques}
\label{sec:eacsl-integers}


En plus des entiers machine, les termes \eacsl peuvent être des entiers
mathématiques de type \lstinline{integer} qui sont définis sur l'ensemble
$\mathbb{Z}$ : les constantes entières, les
opérations sur les entiers, ainsi que les variables logiques sont de type
\lstinline{integer}.
L'arithmétique entière est non bornée et donc les débordements d'entier
(\textit{overflows}) sont impossibles.
\eacsl dispose d'un système de sous-typage pour convertir automatiquement les
types entiers du C vers les entiers mathématiques.
Par exemple, si \lstinline{x} est une variable C de type \lstinline{int},
\lstinline{1} et \lstinline{x+1} sont de type \lstinline{integer} et une
conversion implicite d'\lstinline{int} vers \lstinline{integer} est introduite
dans ce contexte quand la variable \lstinline{x} est typée.
Ce choix a été fait pour plusieurs raisons.
Premièrement, un des buts principaux de \framac est la preuve de programmes par
appel à des prouveurs externes.
Or, la plupart de ces prouveurs fonctionnent mieux
avec l'arithmétique entière qu'avec l'arithmétique bornée (ou modulaire).
Deuxièmement, les spécifications sont habituellement écrites sans se préoccuper
des détails d'implémentation, et les débordements d'entiers sont des détails
d'implémentation.
Troisièmement, il reste possible d'utiliser l'arithmétique bornée, si besoin
est, en utilisant des conversions explicites (\textit{casts}).
Par exemple, \lstinline{(int)(INT_MAX + 1)} est égal à \lstinline{INT_MIN}, la
plus petite valeur représentable de type \lstinline{int}.
Quatrièmement, ce choix facilite l'expression des débordements potentiels dans
les spécifications : par exemple, grâce à l'arithmétique entière,
\lstinline{/*@ assert INT_MIN <= x+y <= INT_MAX;*/} est le moyen le plus simple
de spécifier que \lstinline{x+y} ne déborde pas.
Dans la suite, sauf mention contraire, ``entier'' fait référence à
``entier non borné''.


\subsection{Syntaxe des prédicats \eacsl}

\input{figures/fig_grammar_pred}

La figure~\ref{fig:gram-pred} définit la grammaire des prédicats du langage
\eacsl.
Un prédicat a une valeur de vérité vraie ou fausse.
Le prédicat \lstinline'\valid' renvoie vrai si son argument est un pointeur
valide : c'est-à-dire \lstinline'\valid(ptr)' est vrai si et seulement si
on peut déréférencer \lstinline'ptr' et donc écrire \lstinline'*ptr'.
Dans le cas où son argument est de la forme \lstinline'ptr+(x..y)', le prédicat
est valide si et seulement si \lstinline'ptr+x', \lstinline'ptr+(x+1)', \ldots,
\lstinline'ptr+y' sont valides.
Les quantifications existentielles (\lstinline'\exists') et universelles
(\lstinline'\forall') doivent porter sur des domaines finis d'entiers.
Le symbole \lstinline'==>' encode l'implication logique et le symbole
\lstinline'<==>' encode l'équivalence logique de deux prédicats.


\section{Sémantique des programmes annotés}
\label{sec:lang-semantics}


Nous définissons en sections~\ref{sec:env} et~\ref{sec:store} les notions
d'environnement et $store$, qui nous permettent de définir la notion de mémoire
en section~\ref{sec:mem}.
Cette notion de mémoire nous permet de définir la sémantique dénotationnelle des
instructions et fonctions d'un programme annoté par rapport à une mémoire.
Dans la suite du document, nous utilisons les notations suivantes :
\begin{itemize}
\item $\mathit{lv}$, $\mathit{lv_1}$ et $\mathit{lv_2}$ sont des left-values;
\item $\mathit{id}$, $\mathit{id_1}$ et $\mathit{id_N}$ sont des identificateurs
  de variable;
\item $f$ est un identificateur de fonction;
\item $v$ est une valeur;
\item $\mathit{cst}$ est une constante;
\item $G$ et $X$ sont des listes de termes \eacsl;
\item $i$, $i_1$, $i_2$ sont des instructions C;
\item $A$ et $B$ sont des blocs d'instructions C;
\item $e$, $e_1$, $e_2$, $e_N$ sont des expressions C;
\item $t$, $t_1$, $t_2$ et $t_3$ sont des termes \eacsl;
\item $p$, $p_1$, $p_2$ sont des prédicats \eacsl;
\item $T$ est un type C;
\item $\mathit{unop}$ est un opérateur unaire;
\item $\mathit{binop}$ est un opérateur binaire;
\item $\mathit{rel}$ est un opérateur binaire relationnel.
\end{itemize}


\subsection{Environnements}
\label{sec:env}

Le domaine $LV$ correspond à l'entité syntaxique \textit{left-value}.
$LOC$ est le domaine des adresses (locations en mémoire), incluant l'adresse
nulle, notée \lstinline'NULL'.
$\bot$ dénote une adresse indéfinie et donc invalide.
Un environnement $\env$ est une fonction partielle
$\env \in LV \rightarrow LOC \cup \{\bot\}$
qui associe une adresse à une left-value.
Nous notons $ENV \subseteq LV \rightarrow LOC \cup \{\bot\}$ le domaine des
environnements.
La notation $\env$[$\mathit{lv} \mapsto \loc$] désigne un nouvel environnement,
correspondant à l'environnement $\env$ dans lequel l'adresse $\loc$ est associée
à la left-value $\mathit{lv}$.
L'accès à l'adresse d'une left-value $\mathit{lv}$ dans un environnement $\env$
est noté $\env(\mathit{lv})$ et est défini par :

\begin{center}
\begin{tabular}{rclr}
  ($\env$[$\mathit{lv} \mapsto \loc$])($\mathit{lv}$) &=& $\loc$
  & \eqlabel{env-get-1}\\
  ($\env$[$\mathit{lv_1} \mapsto \loc$])($\mathit{lv_2}$) & =
  & $\env$($\mathit{lv_2}$) si $\mathit{lv_1} \neq \mathit{lv_2}$
  & \eqlabel{env-get-2}\\
  $\env$($\mathit{lv}$) & = & $\bot$ si $\env$ est l'environnement vide
  & \eqlabel{env-get-3} \\
\end{tabular}
\end{center}

Dans la suite, nous utiliserons la notation
$\env$[$\mathit{lv_1} \mapsto \loc_1, \mathit{lv_2} \mapsto \loc_2$]
(en supposant que $\mathit{lv_1} \neq \mathit{lv_2}$)
comme un raccourci pour
$\env$[$\mathit{lv_1} \mapsto \loc_1$][$\mathit{lv_2} \mapsto \loc_2$].
La notation $\env - \{\mathit{lv}\}$ signifie que la left-value
$\mathit{lv}$ et l'adresse associée sont enlevées de l'environnement $\env$ :

\begin{center}
\begin{tabular}{rclr}
  ($\env$[$\mathit{lv} \mapsto \loc$])$-~\{lv\}$ &=& $\env$
  & \eqlabel{env-del-1} \\
  ($\env$[$\mathit{lv_1} \mapsto \loc$])$-~\{\mathit{lv_2}\}$
  &=& ($\env - \{\mathit{lv_2}\}$)[$\mathit{lv_1} \mapsto \loc$] si
  $\mathit{lv_1} \neq \mathit{lv_2}$ & \eqlabel{env-del-2} \\
  $\env - \{\mathit{lv}\}$ &=& $\env$  si $\env(\mathit{lv})$ = $\bot$
  & \eqlabel{env-del-3} \\
\end{tabular}
\end{center}

Nous définissons également une relation d'inclusion sur les environnements,
c'est-à-dire $\env_1$ est inclus dans $\env_2$ si et seulement si pour chaque
paire $(\mathit{lv}, \loc)$ telle que : si $\loc$ est l'adresse de $\mathit{lv}$
dans $\env_1$, alors $\loc$ est aussi l'adresse de $\mathit{lv}$ dans $\env_2$.

\[
\env_1~\subenv~\env_2~\equiv~
\forall \mathit{lv}.~\forall \loc.
~(\env_1(\mathit{lv})=\loc) \Rightarrow (\env_2(\mathit{lv})=\loc)
\]


\subsection{Stores}
\label{sec:store}

Le domaine des valeurs $VAL$ est défini comme l'union des types que
peuvent prendre les termes et prédicats \eacsl et les expressions C :
$VAL = \mathbb{B}~\cup~\mathbb{Z}~\cup~LOC~\cup~\{\bot\}$, où le symbole
$\bot$ dénote une valeur non initialisée.
$LOC \subset VAL$ car nous formalisons les pointeurs et la valeur d'un pointeur
est une adresse.
Un store est une fonction partielle $\store \in LOC \rightarrow VAL$ qui
associe une valeur à une adresse.
Nous notons $STORE : LOC \rightarrow VAL$ le domaine des stores.
La notation $\store$[$\loc \mapsto v$] désigne un nouveau store, correspondant
au store $\store$ dans lequel la valeur $v$ est stockée à l'adresse $\loc$.
L'accès à la valeur d'une adresse $\loc$ dans un store $\store$ est noté
$\store(\loc)$ et est défini par :

\begin{center}
\begin{tabular}{rclr}
  ($\store$[$\loc \mapsto v$])($\loc$) &=& $v$ & \eqlabel{store-get-1}\\
  ($\store$[$\loc_1 \mapsto v$])($\loc_2$) & =
  & $\store$($\loc_2$) si $\loc_1 \neq \loc_2$
  & \eqlabel{store-get-2}\\
  $\store$($\loc$) & = & $\bot$ sinon & \eqlabel{store-get-3} \\
\end{tabular}
\end{center}

Dans la suite, nous utiliserons la notation
$\store$[$\loc_1 \mapsto v_1, \loc_2 \mapsto v_2$] (en supposant
que $\loc_1 \neq \loc_2$)
comme un raccourci pour
$\store$[$\loc_1 \mapsto v_1$][$\loc_2 \mapsto v_2$].
La notation $\store - \{\loc\}$ signifie que l'adresse
$\loc$ et la valeur associée sont enlevées du store $\store$ :

\begin{center}
\begin{tabular}{rclr}
  ($\store$[$\loc \mapsto v$])$-~\{\loc\}$ &=& $\store$
  & \eqlabel{store-del-1} \\
  ($\store$[$\loc_1 \mapsto v$])$-~\{\loc_2\}$
  &=& ($\store - \{\loc_2\}$)[$\loc_1 \mapsto v$] si
  $\loc_1 \neq \loc_2$ & \eqlabel{store-del-2} \\
  $\store - \{\loc\}$ &=& $\store$  si $\store(\loc)$ = $\bot$
  & \eqlabel{store-del-3} \\
\end{tabular}
\end{center}

Nous définissons également une relation d'inclusion sur les stores, c'est-à-dire
$\store_1$ est inclus dans $\store_2$ si et seulement si pour chaque
paire $(\loc, v)$ telle que : si $v$ est la valeur à l'adresse $\loc$
dans $\store_1$, alors $v$ est également à l'adresse $\loc$ dans $\store_2$.

\[
\store_1~\subenv~\store_2~\equiv~
\forall \loc.~\forall v.
~(\store_1(\loc)=v) \Rightarrow (\store_2(\loc)=v)
\]


\subsection{Mémoires}
\label{sec:mem}

Nous définissons la notion de mémoire, correspondant à un couple environnement,
store : $\mem \in ENV \times STORE$.
Une mémoire $\mem$ est un paramètre (et parfois le résultat) des fonctions
sémantiques définies dans la suite du chapitre.
En admettant $\mem = (\env, \store)$, la mémoire sera notée :
\begin{itemize}
\item $(\env, \store)$ si nous devons accéder à l'environnement $\env$ ou au
  store $\store$;
\item $\mem$ sinon.
\end{itemize}

Nous définissons une mémoire d'erreur, notée $\errormem \in ENV \times STORE$.
Une telle mémoire est le résultat de l'évaluation d'une instruction
provoquant une erreur ou d'une annotation invalide (par exemple,
\lstinline'assert' ou \lstinline'loop invariant' faux).
L'évaluation des instructions s'arrête dès qu'un état d'erreur est produit.


\subsection{Sémantique Dénotationnelle des Termes, Prédicats et Expressions}

\input{figures/fig_semantics_exp_term}

La sémantique dénotationnelle des expressions C, des termes et des prédicats
\eacsl est exprimée avec la fonction
$\mathcal{E} : (EXP \cup TERM \cup PRED) \rightarrow (ENV \times STORE) \rightarrow VAL$.
Le domaines $EXP$, $TERM$ et $PRED$ correspondent respectivement aux entités
syntaxiques \textit{exp}, \textit{term} et \textit{pred} définies dans les
figures~\ref{fig:gram-exp-term} et~\ref{fig:gram-pred}.
Cette fonction associe une valeur à une expression C (ou un terme ou prédicat
\eacsl) en fonction d'une mémoire $\mem = (\env, \store)$, à condition que cette
expression ne génère pas d'effet de bord, hypothèse satisfaite par le langage
considéré après normalisation du code par \framac.
L'absence d'effet de bord permet à la fonction $\mathcal{E}$ de ne pas devoir
retourner une nouvelle mémoire.

La figure~\ref{fig:sem-exp-term} donne la sémantique des expressions et des
termes.
Ces deux éléments du langage se retrouvent sur la même figure car les termes
peuvent être vus comme une extension des expressions C.
Les cinq premières règles de la figure~\ref{fig:sem-exp-term} sont communes aux
termes et aux expressions, les autres sont spécifiques aux termes.
La règle \eqlabel{E-lval} traite le cas où une left-value est un identificateur
de variable $x$.
$\env(x)$ est l'adresse de $x$, la valeur à cette adresse est $\store(\env(x))$.
La règle \eqlabel{E-deref} traite le cas où une left-value est un identificateur
de variable $x$, accédé à l'offset $e$.
Rappelons que \lstinline'x[e]' $=$ \lstinline'*(x+e)'.
L'unique différence avec la règle \eqlabel{E-lval} est l'évaluation de $e$, qui
doit retourner une constante entière.
Dans la règle \eqlabel{E-old}, $\mem_{Beg_{\mathtt{f}}}$ correspond à la mémoire au
début de l'exécution de la fonction courante \lstinline'f', nous supposons
qu'une telle mémoire est conservée à chaque appel.

La figure~\ref{fig:sem-pred} donne la sémantique des prédicats.
La sémantique des prédicats est encodée par les entiers 0 et 1 comme en C.
La règle \eqlabel{P-valid} énonce qu'une left-value $\mathit{lv}$ est valide,
si après évaluation, la valeur associée dans le store est de type $LOC$.
$\mathit{lv}$ doit être de type pointeur, donc son évaluation est de type
$LOC$, et la valeur associée dans le store est soit de type $LOC$ (car c'est
un pointeur) soit $\bot$.

Un pointeur est valide en mémoire si on peut le déréférencer afin de pouvoir
accéder ou modifier l'emplacement mémoire qu'il référence (c'est-à-dire vers
lequel il pointe).
Un pointeur alloué dynamiquement (à l'aide de la fonction \lstinline'malloc' par
exemple) est valide tant qu'il n'est pas libéré (par la fonction
\lstinline'free').
Le pointeur égal à l'adresse d'une variable globale est toujours valide, et le
pointeur égal à l'adresse d'une variable locale est valide dans la portée de
cette variable.
Ainsi, le prédicat \lstinline'\valid(t)' est vrai si \lstinline't'
peut être déréférencé et est accessible en écriture, c'est-à-dire n'est pas une
constante.
De la même manière, \lstinline'\valid(t+(t1..t2))' est valide si les pointeurs
\lstinline'(t+t1)', ..., \lstinline'(t+t2)' peuvent être déréférencés et sont
accessibles en écriture.

\input{figures/fig_semantics_pred}


\subsection{Sémantique Dénotationnelle des Instructions}

La sémantique dénotationnelle des instructions C est exprimée avec la fonction
$\mathcal{C} : INSTR \rightarrow (ENV \times STORE) \rightarrow (ENV \times STORE)$.
Cette fonction associe à une instruction $i$, dans un contexte mémoire $\mem$,
une nouvelle mémoire $\mem'$ qui tient compte des effets de bord effectués par
$i$ dans $\mem$.
La sémantique d'une séquence d'instructions est exprimée avec la fonction
$\mathcal{C}^{*} : INSTR^{*} \rightarrow (ENV \times STORE) \rightarrow (ENV \times STORE)$.
Cette fonction définie en figure~\ref{fig:c*} revient à appeler successivement
$\mathcal{C}$ sur chaque instruction dans l'ordre de la séquence.

\begin{figure}
\begin{center}
\begin{tabular}{rcl}
  \comps{\lstinline'i;' $A$}{$\mem$}
  &=& \comps{$A$}{(\comp{\lstinline'i'}{$\mem$})} \\
  \comps{$\semicolon$}{$\mem$} &=& $\mem$ \\
\end{tabular}
\caption{Sémantique dénotationnelle des séquences d'instructions\label{fig:c*}}
\end{center}
\end{figure}


\input{figures/fig_semantics}

La sémantique des instructions C est donnée en figure~\ref{fig:sem-instr}.
La règle \eqlabel{C-decl} alloue l'adresse $\loc$ à la variable $\mathit{id}$
dans l'environnement $\env$, où $\loc$ est fraîche (non utilisée).
Les règles \eqlabel{C-set} et \eqlabel{C-set-2} associent la valeur de $e$
à l'adresse de la left-value correspondante dans le store.
Dans la règle \eqlabel{C-Z-set}, la variable entière (non bornée) $x$ est
allouée et on lui affecte la valeur de $e$ dans $\store$.
Dans la règle \eqlabel{C-Z-unset}, la variable entière (non bornée) $x$
est désallouée et enlevée de la mémoire.
Une instruction soulignée manipule des entiers non bornés.
Les règles \eqlabel{C-Z-set} et \eqlabel{C-Z-unset} traitent uniquement le cas
où une left-value est un identificateur et pas un accès à un tableau car le
langage \eacsl ne supporte pas les tableaux d'entiers non bornés.

%% Nous définissons une fonction \lstinline'fassert' permettant de tester la valeur
%% d'une expression.
%% Cette fonction correspond à un \lstinline'if' dont la branche
%% \lstinline'else' génère une erreur et la rapporte.
%% Nous définissons également une fonction \lstinline'fassume' permettant de poser
%% une hypothèse de validité sur la valeur d'une expression.
%% Cette fonction correspond à un \lstinline'if' dont
%% la branche \textit{true} est toujours vraie, les exécutions pour lesquelles
%% la branche \textit{false} est activée sont ignorées.
%% Nous supposons enfin disposer d'une fonction \lstinline'fvalid' permettant
%% d'évaluer la validité d'un pointeur et d'une fonction \lstinline'fvalidr'
%% permettant d'évaluer la validité d'un pointeur sur un intervalle d'offsets.

La sémantique de la fonction \lstinline'fassert' donnée par la règle
\eqlabel{C-fassert} énonce que si l'expression $e$ s'évalue en une expression
non nulle, alors la mémoire $\mem$ est inchangée, sinon on obtient
la mémoire d'erreur $\errormem$.
La sémantique de la fonction \lstinline'fassume' donnée par la règle
\eqlabel{C-fassume} énonce que l'expression $e$ est supposée vraie et
doit donc s'évaluer en une expression non nulle.
La mémoire est inchangée après cet appel de fonction.
$e$ ne peut pas s'évaluer en $0$ par définition de la fonction, si c'est
le cas on aboutit à une contradiction.

La sémantique des fonctions \lstinline'fvalid' et \lstinline'fvalidr' est donnée
par les règles \eqlabel{C-fvalid} et \eqlabel{C-fvalidr}.
Elles énoncent que dans la nouvelle mémoire, la left-value $\mathit{lv}$ a
la valeur $1$ si les pointeurs en argument de la fonction sont valides, et $0$
sinon.

La sémantique de la fonction \lstinline'malloc' donnée par la règle
\eqlabel{C-malloc} énonce que de nouvelles adresses (fraîches) sont associées
aux left-values allouées pour la variable $\textit{id}$, et que la valeur
associée à l'adresse de $\textit{id}$ dans le store est l'adresse du premier
élémént alloué ($\env(\mathit{id}$\lstinline'[0]'$)$).
La sémantique de la fonction \lstinline'free' donnée par la règle
\eqlabel{C-free} est l'inverse de la sémantique de \lstinline'malloc' : la
valeur indéfinie $\bot$ est associée aux left-values désallouées et à l'adresse
de la variable $\textit{id}$.
Dans ces deux règles, $\textit{id}$ est une variable de type pointeur, la
valeur associée à son adresse dans la règle \eqlabel{C-malloc} est donc une
adresse.

La sémantique des appels de fonction est donnée par les règles \eqlabel{C-fct1}
et \eqlabel{C-fct2}.
Dans ces règles, la sémantique de la fonction $f$ est calculée à
l'aide de la fonction $\mathcal{F}$ donnée en figure~\ref{fig:sem-fct}.
$(\env[\mathit{id_1} \mapsto \loc_1$, ...,
  $\mathit{id_N} \mapsto \loc_N], \store[\loc_1 \mapsto$
  \eval{$e_1$}{$(\env, \store)$}, ...,
  $\loc_N \mapsto$ \eval{$e_N$}{$(\env, \store)$} $])$
est la mémoire dans laquelle les paramètres effectifs (les expressions
$e_1$, ..., $e_N$) sont affectés aux paramètres formels (les identificateurs
$\mathit{id_1}$, ..., $\mathit{id_N}$).

Les règles \eqlabel{C-fassert}, \eqlabel{C-fassume} et \eqlabel{C-free} sont
des instances particulières de la règle \eqlabel{C-fct1}.
Les règles \eqlabel{C-fvalid}, \eqlabel{C-fvalidr} et \eqlabel{C-malloc} sont
des instances particulières de la règle \eqlabel{C-fct2}.

La règle \eqlabel{C-return} énonce qu'une instruction \lstinline'return' ne
modifie pas la mémoire.
En effet, le programme est dans une forme normalisée où la valeur de retour
d'une fonction est stockée dans une variable \lstinline'res'$_f$, où
$f$ est le nom de la fonction courante.
Cette variable est lue après l'appel de la fonction comme l'énonce la règle
\eqlabel{C-fct2}.

La sémantique des assertions \eacsl donnée par la règle \eqlabel{C-assert} est
similaire à la sémantique de la fonction \lstinline'fassert'.
Si le prédicat $p$ s'évalue en une expression non nulle,
la mémoire $\mem$ est inchangée, sinon la mémoire d'ereur $\errormem$ est
obtenue.

La sémantique des boucles annotées par un contrat contenant un invariant
$p$, une liste de termes $X$ et un variant $t$ est
donnée par la règle \eqlabel{C-while}.
Les différents cas possibles sont notés \eqlabel{C-while-1} à
\eqlabel{C-while-7} et sont ordonnés.
Tout d'abord, si l'invariant de boucle n'est pas établi avant l'exécution du
corps de la boucle, alors la mémoire d'erreur $\errormem$ est obtenue
(\eqlabel{C-while-1}).
Si la condition de boucle $e$ s'évalue à $0$ (la boucle n'est pas exécutée),
alors la mémoire reste inchangée (\eqlabel{C-while-2}).
Si le variant de boucle n'est pas positif avant l'exécution de la boucle, alors
$\errormem$ est obtenue (\eqlabel{C-while-3}).
Si l'invariant de boucle n'est pas maintenu après l'exécution du corps de
boucle, alors $\errormem$ est obtenue (\eqlabel{C-while-4}).
Si le variant de boucle ne décroît pas strictement entre le début et la fin de
l'exécution du corps de boucle, alors $\errormem$ est obtenue
(\eqlabel{C-while-5}).
Si l'évaluation d'un élément appartenant à $G-X$ (ensemble des left-values
n'appartenant pas à la clause \lstinline'loop assigns' de la boucle) est
différente entre le début et la fin de l'exécution du corps de la boucle, alors
$\errormem$ est obtenue (\eqlabel{C-while-6}).
Si aucun des six cas précédents ne s'applique, alors il faut ré-évaluer la
sémantique de la boucle dans la mémoire obtenue après exécution du corps de la
boucle dans $\mem$ (\eqlabel{C-while-7}).


\input{figures/fig_semantics_fct}


La sémantique dénotationnelle des fonctions est exprimée avec la fonction
$\mathcal{F} : FCT \rightarrow (ENV \times STORE) \rightarrow (ENV \times STORE)$ où $FCT$ correspond à
l'entité syntaxique \textit{function} définie par la figure~\ref{fig:gram-c}.
Cette fonction calcule une nouvelle mémoire à partir d'une fonction annotée et
d'une mémoire $\mem$, ce qui permet de traiter les appels de fonction (règles
\eqlabel{C-fct1} et \eqlabel{C-fct2} de la figure~\ref{fig:sem-instr}) et la
fonction sous vérification (qui n'est pas appelée).

La sémantique des fonctions est donnée en figure~\ref{fig:sem-fct} par la règle
\eqlabel{F}.
Les différents cas possibles sont notés \eqlabel{F-1} à \eqlabel{F-4} et sont
ordonnés.
Si $f$ est la fonction sous vérification, alors sa précondition $p_1$ est
supposée vraie par définition.
Si la fonction considérée n'est pas la fonction sous vérification, alors la
la mémoire d'erreur $\errormem$ est obtenue si le prédicat $p_1$ s'évalue en
faux (\eqlabel{F-1}).
Si l'évaluation d'un élément appartenant à $G-X$ (ensemble des left-values
n'appartenant pas à la clause \lstinline'assigns' de la fonction) est différente
entre le début et la fin de l'exécution du corps de la fonction, alors
$\errormem$ est obtenue (\eqlabel{F-2}).
Si le prédicat de la postcondition $p_2$ est faux à la fin de la fonction, alors
$\errormem$ est obtenue (\eqlabel{F-3}).
Enfin, si aucun des trois cas précédents ne s'est produit, le résultat est la
mémoire obtenue après exécution des instructions du corps de la fonction
(\eqlabel{F-4}).


\section*{Conclusion du chapitre}

Dans ce chapitre nous avons présenté un sous-ensemble du langage C et du
langage \eacsl normalisé que nous traitons.
Nous avons défini la sémantique dénotationnelle de chaque élément du langage
pour pouvoir justifier de la correction de la traduction des annotations en C
dans le but de générer des tests.
Le chapitre~\ref{sec:traduction} présentera la traduction de ces annotations
\eacsl en code C sémantiquement équivalent.
