
\chapter{Modèle mémoire E-ACSL}
\label{sec:eacsl}

\chapterintro


Dans ce chapitre nous présentons notre implémentation du modèle mémoire en C
qui permet d'exécuter les annotations \eacsl présentées dans
le chapitre~\ref{sec:runtime}.
Notre bibliothèque permet au greffon \eacsltoc de vérifier à l'exécution les
annotations \eacsl portant sur le modèle mémoire.

\eacsltoc traduit automatiquement un programme C annoté en un autre
programme dont l'exécution échouera si une annotation n'est pas valide.
Si aucune annotation n'est violée, le comportement
du nouveau programme est exactement le même que celui du programme d'origine.
Ce greffon utilise notre bibliothèque afin de vérifier à l'exécution les
annotations \eacsl portant sur le modèle mémoire.

Nous présentons la bibliothèque en partie~\ref{sec:eacsl-impl} et les résultats
de nos expérimentations en partie~\ref{sec:eacsl-exp}.


\section{Implémentation}
\label{sec:eacsl-impl}

Dans cette partie nous présentons l'architecture générale de la bibliothèque
ainsi que l'implémentation de quelques fonctions.


\subsection{Architecture de la bibliothèque}


\begin{landscape}
  \begin{figure}[tb]
    \includegraphics{figures/mmodel_architecture.pdf}
    \label{fig:mmodel-architecture}
    \caption{Architecture de la bibliothèque de modèle mémoire d'\eacsl}
  \end{figure}
\end{landscape}

La figure~\ref{fig:mmodel-architecture} présente l'architecture générale de la
bibliothèque au moyen du graphe de dépendances des fonctions C.
Une flèche $A \rightarrow B$ signifie que la fonction $A$ appelle la fonction
$B$.
Les fonctions \lstinline'valid', \lstinline'base_addr', \lstinline'valid_read',
\lstinline'initialized', \lstinline'block_length', \lstinline'out_of_bound',
\lstinline'initialize' et \lstinline'offset' ont été regroupées afin de ne pas
surcharger le graphe.
Chacune de ces huit fonctions ne dépend que de la fonction \lstinline'get_cont'.
Les fonctions dont le cadre est bleu doivent être appeler en lieu et place des
fonctions de la bibliothèque standard associées (\lstinline'malloc', etc.).
Les fonctions dont le cadre est rouge correspondent à des annotations \eacsl et
retournent la valeur du terme ou du prédicat \eacsl correspondant.
Ces fonctions ne modifient pas le contenu du modèle mémoire.
Les fonctions dont le cadre est vert servent à modifier le contenu du modèle
mémoire (ajout ou suppression d'élément, initialisation, etc.).
Les fonctions dont le cadre est jaune correspondent à l'implémentation de la
structure de données gardant les informations à propos des blocs alloués.
Plusieurs implémentations sont fournies pour ces fonctions, correspondant à
différentes structures de données génériques : listes chaînées, arbres binaires
de recherche, Splay trees et Patricia tries.
Les fonctions dont le cadre est bleu, vert ou rouge sont implémentées de manière
indépendante à la structure de données de la couche jaune.

Cette architecture facilite la conception des algorithmes, ainsi que la
comparaison d'efficacité des différentes implémentations de la structure de
données, effectuée en partie~\ref{sec:eacsl-exp}.


\section{Expérimentations}
\label{sec:eacsl-exp}


Pour évaluer notre solution, nous avons effectué plus de 300 exécutions sur
plus de 30 programmes, obtenus à partir d'une dizaine d'exemples. Nous avons
volontairement gardés des exemples plutôt courts (moins de 200 lignes de code)
car ils ont dû être annotés en \acsl manuellement.

Nous avons mesuré le temps d'exécution du programme d'origine et du code
instrumenté par \eacsltoc avec différentes options, afin d'évaluer les
performances des différentes implémentations et optimisations. Des indicateurs
comme le nombre de variables, d'allocations mémoires, d'enregistrements et de
requêtes a également été enregistré.



\textbf{Implémentation du store :}\\
Pour déterminer quelle implémentation du $store$ est la plus appropriée, nous
avons comparé des implémentations utilisant : des Patricia tries, des listes
chaînées, des arbres binaires de recherche non équilibrés et des Splay trees.

Notre implémentation utilisant les Patricia tries est en moyenne 2500 fois plus
rapide que l'implémentation à base de listes chaînées, 200 fois plus rapide que
celle utilisant les arbres binaires de recherche, et 27 fois plus rapide que
celle se basant sur les Splay trees.

La version utilisant les Splay trees offre
des performances comparables (ou légèrement meilleures, jusqu'à 3 fois) sur les
exemples contenant de fréquents accès mémoire consécutifs au même bloc dans le
$store$. En revanche, sur des examples où les accès méoire consécutifs ne se
font pas sur le même bloc (une multiplication de matrices dans notre exemple),
les performances sont beaucoup moins bonnes (jusqu'à 500 fois). Ceci est dû à
la nature des Splay treees : le dernier élément accédé est remonté à la racine
de l'arbre.

\textbf{Calcul du plus grand préfixe commun :} \\
Nous avons comparé deux implémentations de ce calcul. La première utilise un
parcours linéaire de l'adresse (bit-à-bit, de gauche à droite). La seconde
est une recherche dichotomique du meilleur préfixe dans un tableau dont le
contenu et les indices (indiquant le prochain élément à tester) sont
pré-calculés. Cette seconde implémentation s'est révélée en moyenne 2.7 fois
plus rapide que la première sur nos exemples.

\textbf{Capacité de détection d'erreurs :} \\
Nous avons utilisé le ``test mutationnel'' pour évaluer la capacité de détection
d'erreurs en utilisant la vérification d'assertion à l'exécution avec
\framac. Nous avons considéré 5 exemples annotés et généré leurs
{\em mutants} (en appliquant une {\em mutation} sur leur code source) et leur
avons appliqué la vérification à l'exécution. Les mutations incluent :
modifications d'opérateur arithmétique numérique, modifications d'opérateur
arithmétique sur les pointeurs, modifications d'opérateur de comparaison et
modifications d'opérateur logique ($land$ et $lor$).
L'outil de génération de test \pathcrawler \cite{\citepathcrawler} a été
utilisé pour produire les cas de test. Chaque mutant a été instrumenté par
\eacsltoc et exécuté sur chaque cas de test pour vérifier que la
spécification était satisfaite à l'exécution. Les programmes d'origine passent
toutes les vérifications à l'exécution. Lorsqu'une violation d'une annotation a
été reportée pour au moins un cas de testn le mutant est considéré comme étant
{\em tué}. La Table~\ref{tab:mutation-exp} illustre les résultats. Exception
faite des mutants équivalents (lorsque la mutation produit un programme
équivalent au programme d'origine), tous les mutants erronés ont été tués.


La Table~\ref{tab:mmodel-exp} contient les résultats des expérimentations
comparant les différentes implémentations du $store$ et du calcul du plus grand
préfixe commun, la Fig.~\ref{fig:mmodel-exp} représente graphiquement ces
données. bS$_{10000}$ est une recherche binaire dans un tableaux de 10000
éléments. iS$_{10000}$ est un tri par insertion d'un tableau de 10000 éléments.
mM$_{n^2}$ est une multiplication de matrices $n \times n$. mI$_{n^2}$ contient
des calculs matriciels (dont inversion et multiplication) sur des  matrices
$n \times n$. qS$_n$ est un tri rapide sur un tableau de $n$ éléments.
bbS$_{10000}$ est un tri à bulles sur un tableau à 10000 éléments. m$_{30000}$ est
une fusion de deux listes chaînées de 10000 et 20000 éléments. Rbt$_{10000}$ est
une insertion/suppression de 10000 éléments dans un arbre rouge et noir. mS$_n$
est un tri fusion d'une liste chaînée de $n$ éléments. La ligne supplémentaire
``+ RTE'' de chaque exemple correspond à une application préalable du greffon
\rte qui génère des assertions qui sont vraies si le programme ne
contient pas d'erreur à l'exécution.

Les colonnes ont la signification suivante : \danger{} contient le nombre
d'alarmes du programme,  $\emptyset$ contient le temps d'exécution du programme
original, bst correspond à l'implémentation par arbres binaires de recherche,
mask est le nombre de fois qu'est effectué le calcul du plus grand préfixe
commun, sb est le nombre d'insertion dans le $store$, Pt correspond à
l'implémentation par Patricia tries, St correspond à l'implémentation par Splay
trees. L'exposant $^1$ (respectivement $^2$) correspond aux expérimentations
sans (resp. avec) application d'une analyse statique $Dataflow$ permettant de
n'instrumenter que ce qui est nécessaire (section 6 de \cite{\citeeacsltoc}).
L'indice $_1$ (resp. $_2$)
correspond à l'implémentation non optimisée (resp. optimisée) du calcul du
plus grand préfixe commun pour l'implémentation utilisant les Patricia tries.
Le temps d'analyse du programme avec \valgrind \cite{\citevalgrind} est
indiqué dans la dernière colonne.

Nous remarquons que le temps d'exécution de \valgrind n'est pas
comparable avec celui de notre solution, cela s'explique simplement par le fait
que celui-ci ne prend pas en compte la spécification \acsl, et se
contente de vérifier des propriétés comme l'absence d'erreur de segmentation ou
l'absence de fuite de mémoire. En revanche, notre démarche vise à supporter au
maximum les annotations \acsl, ce qui nécessite un monitoring plus
lourd.

Nos expérimentations, présentées dans la Fig.~\ref{fig:mmodel-exp}, confirment
nos hypothèses, à savoir :
\begin{itemize}
\item le Patricia trie est la structure de données la plus appropriée pour
  l'implémentation du $store$;
\item notre optimisation du calcul du plus grand préfixe commun par recherche
  dichotomique et utilisation d'indices pré-calculés entraîne un vrai gain de
  performance;
\item l'utilisation d'une analyse statique visant à réduire l'instrumentation
  du programme permet de réduire le temps d'exécution de manière efficace.
\end{itemize}


\begin{landscape}
  \begin{table}[h]
    \centering
    \begin{footnotesize}
    \input{table_eacsl_experiments.tex}
    \end{footnotesize}
    \label{tab:mmodel-exp}
    \caption{Comparaison des différentes implémentations du $store$}
  \end{table}
\end{landscape}


\begin{figure}[bt]
  \begin{tikzpicture}
    \begin{axis}[axis y line=left,width=\textwidth,height=\textwidth,ymode=log]
      \pgfplotstableread{data/table_eacsl_experiments_merge_sort.dat}
      \loadedtable;
      \foreach \i in {
        list,list-DFA,bst,bst-DFA,Pt,Pt-opti,Pt-DFA,Pt-opti-DFA,St,St-DFA} {
        \addplot table [x=N, y=\i] {\loadedtable};
      }
      \legend{list,list-DFA,bst,bst-DFA,Pt,Pt-opti,Pt-DFA,Pt-opti-DFA,St,St-DFA}
    \end{axis}
  \end{tikzpicture}
  \label{fig:mmodel-exp}
  \caption{Comparaison des différentes implémentations du $store$}
\end{figure}


\begin{table}[tb]
  \centering
  \begin{tabular}{c|c|c|c|c|c}
    & alarmes & mutants & équivalents & tués & \% erronés tués \\
    \hline
    fibonacci & 19  & 27 & 2 & 25 & 100\% \\
    \hline
    bubbleSort & 15  & 44 & 2 & 42 & 100\% \\
    \hline
    insertionSort & 10  & 39 & 3 & 36 & 100\% \\
    \hline
    binarySearch & 7 & 38 & 1 & 37 & 100\% \\
    \hline
    merge & 5 & 92 & 5 & 87 & 100\% \\
  \end{tabular}
  \label{tab:mutation-exp}
  \caption{Capacité de détection d'erreurs}
\end{table}


\section*{Conclusion du chapitre}

TODO
