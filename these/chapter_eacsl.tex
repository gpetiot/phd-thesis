
\chapter{Modèle mémoire E-ACSL}
\label{sec:eacsl}

\chapterintro

Dans ce chapitre nous présentons une solution pour le monitoring mémoire des
programmes C, dévelopée pour la vérification d'assertions à l'exécution
({\em runtime assertion checking} \cite{Clarke/06}) dans \framac
\cite{\citeframac}.
Cette solution inclut un langage de spécification exécutable, \eacsl,
et un traducteur, \eacsltoc \cite{\citeeacsltoc}.
Notre objectif est de pouvoir exécuter des annotations écrites avec le langage
de spécification \eacsl.
Nous avons développé une bibliothèque C permettant d'enregistrer et de récupérer
les informations de validité et d'initialisation d'un programme. Les appels aux
fonctions de cette bibiliothèque C sont automatiquement ajoutés aux emplacements
adéquats dans le code source du programme par \eacsltoc durant la
traduction de la spécification \eacsl en C.

\eacsltoc est un greffon de \framac qui traduit automatiquement
un programme C annoté en un autre programme dont l'exécution échouera si une
annotation n'est pas valide. Si aucune annotation n'est violée, le comportement
du nouveau programme est exactement le même que celui du programme d'origine.


\section{Implémentation}


\commentGP{TODO}


\section{Expérimentations}


Pour évaluer notre solution, nous avons effectué plus de 300 exécutions sur
plus de 30 programmes, obtenus à partir d'une dizaine d'exemples. Nous avons
volontairement gardés des exemples plutôt courts (moins de 200 lignes de code)
car ils ont dû être annotés en \acsl manuellement.

Nous avons mesuré le temps d'exécution du programme d'origine et du code
instrumenté par \eacsltoc avec différentes options, afin d'évaluer les
performances des différentes implémentations et optimisations. Des indicateurs
comme le nombre de variables, d'allocations mémoires, d'enregistrements et de
requêtes a également été enregistré.



\textbf{Implémentation du store :}\\
Pour déterminer quelle implémentation du $store$ est la plus appropriée, nous
avons comparé des implémentations utilisant : des Patricia tries, des listes
chaînées, des arbres binaires de recherche non équilibrés et des Splay trees.

Notre implémentation utilisant les Patricia tries est en moyenne 2500 fois plus
rapide que l'implémentation à base de listes chaînées, 200 fois plus rapide que
celle utilisant les arbres binaires de recherche, et 27 fois plus rapide que
celle se basant sur les Splay trees.

La version utilisant les Splay trees offre
des performances comparables (ou légèrement meilleures, jusqu'à 3 fois) sur les
exemples contenant de fréquents accès mémoire consécutifs au même bloc dans le
$store$. En revanche, sur des examples où les accès méoire consécutifs ne se
font pas sur le même bloc (une multiplication de matrices dans notre exemple),
les performances sont beaucoup moins bonnes (jusqu'à 500 fois). Ceci est dû à
la nature des Splay treees : le dernier élément accédé est remonté à la racine
de l'arbre.

\textbf{Calcul du plus grand préfixe commun :} \\
Nous avons comparé deux implémentations de ce calcul. La première utilise un
parcours linéaire de l'adresse (bit-à-bit, de gauche à droite). La seconde
est une recherche dichotomique du meilleur préfixe dans un tableau dont le
contenu et les indices (indiquant le prochain élément à tester) sont
pré-calculés. Cette seconde implémentation s'est révélée en moyenne 2.7 fois
plus rapide que la première sur nos exemples.

\textbf{Capacité de détection d'erreurs :} \\
Nous avons utilisé le ``test mutationnel'' pour évaluer la capacité de détection
d'erreurs en utilisant la vérification d'assertion à l'exécution avec
\framac. Nous avons considéré 5 exemples annotés et généré leurs
{\em mutants} (en appliquant une {\em mutation} sur leur code source) et leur
avons appliqué la vérification à l'exécution. Les mutations incluent :
modifications d'opérateur arithmétique numérique, modifications d'opérateur
arithmétique sur les pointeurs, modifications d'opérateur de comparaison et
modifications d'opérateur logique ($land$ et $lor$).
L'outil de génération de test \pathcrawler \cite{\citepathcrawler} a été
utilisé pour produire les cas de test. Chaque mutant a été instrumenté par
\eacsltoc et exécuté sur chaque cas de test pour vérifier que la
spécification était satisfaite à l'exécution. Les programmes d'origine passent
toutes les vérifications à l'exécution. Lorsqu'une violation d'une annotation a
été reportée pour au moins un cas de testn le mutant est considéré comme étant
{\em tué}. La Table~\ref{tab:mutation-exp} illustre les résultats. Exception
faite des mutants équivalents (lorsque la mutation produit un programme
équivalent au programme d'origine), tous les mutants erronés ont été tués.


La Table~\ref{tab:mmodel-exp} contient les résultats des expérimentations
comparant les différentes implémentations du $store$ et du calcul du plus grand
préfixe commun, la Fig.~\ref{fig:mmodel-exp} représente graphiquement ces
données. bS$_{10000}$ est une recherche binaire dans un tableaux de 10000
éléments. iS$_{10000}$ est un tri par insertion d'un tableau de 10000 éléments.
mM$_{n^2}$ est une multiplication de matrices $n \times n$. mI$_{n^2}$ contient
des calculs matriciels (dont inversion et multiplication) sur des  matrices
$n \times n$. qS$_n$ est un tri rapide sur un tableau de $n$ éléments.
bbS$_{10000}$ est un tri à bulles sur un tableau à 10000 éléments. m$_{30000}$ est
une fusion de deux listes chaînées de 10000 et 20000 éléments. Rbt$_{10000}$ est
une insertion/suppression de 10000 éléments dans un arbre rouge et noir. mS$_n$
est un tri fusion d'une liste chaînée de $n$ éléments. La ligne supplémentaire
``+ RTE'' de chaque exemple correspond à une application préalable du greffon
\rte qui génère des assertions qui sont vraies si le programme ne
contient pas d'erreur à l'exécution.

Les colonnes ont la signification suivante : \danger{} contient le nombre
d'alarmes du programme,  $\emptyset$ contient le temps d'exécution du programme
original, bst correspond à l'implémentation par arbres binaires de recherche,
mask est le nombre de fois qu'est effectué le calcul du plus grand préfixe
commun, sb est le nombre d'insertion dans le $store$, Pt correspond à
l'implémentation par Patricia tries, St correspond à l'implémentation par Splay
trees. L'exposant $^1$ (respectivement $^2$) correspond aux expérimentations
sans (resp. avec) application d'une analyse statique $Dataflow$ permettant de
n'instrumenter que ce qui est nécessaire (section 6 de \cite{\citeeacsltoc}).
L'indice $_1$ (resp. $_2$)
correspond à l'implémentation non optimisée (resp. optimisée) du calcul du
plus grand préfixe commun pour l'implémentation utilisant les Patricia tries.
Le temps d'analyse du programme avec \valgrind \cite{\citevalgrind} est
indiqué dans la dernière colonne.

Nous remarquons que le temps d'exécution de \valgrind n'est pas
comparable avec celui de notre solution, cela s'explique simplement par le fait
que celui-ci ne prend pas en compte la spécification \acsl, et se
contente de vérifier des propriétés comme l'absence d'erreur de segmentation ou
l'absence de fuite de mémoire. En revanche, notre démarche vise à supporter au
maximum les annotations \acsl, ce qui nécessite un monitoring plus
lourd.

Nos expérimentations, présentées dans la Fig.~\ref{fig:mmodel-exp}, confirment
nos hypothèses, à savoir :
\begin{itemize}
\item le Patricia trie est la structure de données la plus appropriée pour
  l'implémentation du $store$;
\item notre optimisation du calcul du plus grand préfixe commun par recherche
  dichotomique et utilisation d'indices pré-calculés entraîne un vrai gain de
  performance;
\item l'utilisation d'une analyse statique visant à réduire l'instrumentation
  du programme permet de réduire le temps d'exécution de manière efficace.
\end{itemize}


\begin{landscape}
  \begin{table}[h]
    \centering
    \begin{footnotesize}
    \input{table_eacsl_experiments.tex}
    \end{footnotesize}
    \label{tab:mmodel-exp}
    \caption{Comparaison des différentes implémentations du $store$}
  \end{table}
\end{landscape}


\begin{figure}[bt]
  \begin{tikzpicture}
    \begin{axis}[axis y line=left,width=\textwidth,height=\textwidth,ymode=log]
      \pgfplotstableread{data/table_eacsl_experiments_merge_sort.dat}
      \loadedtable;
      \foreach \i in {
        list,list-DFA,bst,bst-DFA,Pt,Pt-opti,Pt-DFA,Pt-opti-DFA,St,St-DFA} {
        \addplot table [x=N, y=\i] {\loadedtable};
      }
      \legend{list,list-DFA,bst,bst-DFA,Pt,Pt-opti,Pt-DFA,Pt-opti-DFA,St,St-DFA}
    \end{axis}
  \end{tikzpicture}
  \label{fig:mmodel-exp}
  \caption{Comparaison des différentes implémentations du $store$}
\end{figure}


\begin{table}[tb]
  \centering
  \begin{tabular}{c|c|c|c|c|c}
    & alarmes & mutants & équivalents & tués & \% erronés tués \\
    \hline
    fibonacci & 19  & 27 & 2 & 25 & 100\% \\
    \hline
    bubbleSort & 15  & 44 & 2 & 42 & 100\% \\
    \hline
    insertionSort & 10  & 39 & 3 & 36 & 100\% \\
    \hline
    binarySearch & 7 & 38 & 1 & 37 & 100\% \\
    \hline
    merge & 5 & 92 & 5 & 87 & 100\% \\
  \end{tabular}
  \label{tab:mutation-exp}
  \caption{Capacité de détection d'erreurs}
\end{table}
