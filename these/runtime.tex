
%\chapterintro

\section{Introduction}


Dans ce chapitre nous présentons une solution pour le monitoring mémoire des
programmes C, dévelopée pour la vérification d'assertions à l'exécution
({\em runtime assertion checking} \cite{Clarke/06}) dans \framac
\cite{\citeframac}.
Cette solution inclut un langage de spécification exécutable, \eacsl,
et un traducteur, \eacsltoc \cite{\citeeacsltoc}.
Notre objectif est de pouvoir exécuter des annotations écrites avec le langage
de spécification \eacsl.

\subsection{\textsc{Executable-acsl}}

\eacsl est un sous-ensemble ``exécutable'' du langage \acsl
implémenté dans \framac. Contrairement à \acsl, chaque
spécification \eacsl est exécutable : elle peut être évaluée à
l'exécution.

\subsection{Bibliothèque de monitoring de la mémoire}

Afin de supporter les annotations relatives au modèle mémoire (validité d'un
pointeur, initialisation d'un bloc, appartenance à un bloc, etc.) nous devons
monitorer les opérations effectuées en mémoire par le programme. Pour ce faire,
nous avons développé une bibliothèque C permettant d'enregistrer et de récupérer
les informations de validité et d'initialisation d'un programme. Les appels aux
fonctions de cette bibiliothèque C sont automatiquement ajoutés aux emplacements
adéquats dans le code source du programme par \eacsltoc durant la
traduction de la spécification \eacsl en C.

\eacsltoc est un greffon de \framac qui traduit automatiquement
un programme C annoté en un autre programme dont l'exécution échouera si une
annotation n'est pas valide. Si aucune annotation n'est violée, le comportement
du nouveau programme est exactement le même que celui du programme d'origine.




\section{Informations relatives à la validité et à l'initialisation}


Détaillons les annotations \acsl que nous souhaitons prendre en compte.
Elles sont au nombre de 6 : \lstinline{\base_addr}, \lstinline{\block_length},
\lstinline{\offset}, \lstinline{\valid}, \lstinline{\valid_read} et
\lstinline{\initialized}.

\input{tikz_mem_annots}


\begin{figure}[tb]
  \lstinputlisting[firstline=4,firstnumber=1] {mem_annots.c}
  \caption{Annotations mémoire -- Exemple en C}
  \label{lst:mem-annots}
\end{figure}


\lstinline'\base_addr{L}(p)' retourne l'adresse de base du bloc alloué
qui contient, au label \lstinline{L}, le pointeur \lstinline{p}.

\lstinline'\block_length{L}(p)' retourne la longueur (en octets) du
bloc alloué qui contient, au label \lstinline{L}, le porinteur \lstinline{p}.

\lstinline'\offset{L}(p)' retourne le décalage (en octets), au label
\lstinline{L}, entre \lstinline{p} et son adresse de base.

\lstinline'\valid{L}(p)' (respectivement \lstinline'\valid_read{L}(p)') est vrai
si le déréférencement de \lstinline{p} au label \lstinline{L} est autorisé en
lecture et en écriture (resp. au moins en lecture).
\lstinline'\valid{L}(p)' implique \lstinline'\valid_read{L}(p)'
mais l'inverse n'est pas vrai.

\lstinline'\initialized{L}(p)' est un prédicat prenant un pointeur \lstinline{p}
sur une l-value en argument. Ce prédicat est vrai si la l-value en question est
initialisée au label \lstinline{L}.

La Fig.~\ref{lst:mem-annots} illustre ces annotations sur un programme C, le
programme et ses annotations sont correctes : l'exécution du programme traduit
par \eacsltoc ne génère pas d'erreur.
La Fig.~\ref{fig:mem-annots} schématise la mémoire allouée par le programme de
la Fig.~\ref{lst:mem-annots}.


Pour pouvoir traiter ces annotations \acsl, nous devons donc conserver
pour chaque bloc les informations suivantes :
\begin{itemize}
\item l'adresse de base
\item le nombre d'octets occupés
\item le nombre d'octets initialisés
\item l'initialisation de chaque octet (un bit par octet, sauf si aucun ou tous
  les octets sont initialisés)
\item un booléen indiquant si le bloc est en lecture seule (par exemple si c'est
  une chaîne littérale)
\item un booléen indiquant s'il y a eu un accès au bloc hors bornes
\end{itemize}





\section{Conclusion}
conclusion + future work + application dans le greffon PathCrawler (transition
avec le chapitre suivant)
