
\chapter{Découverte de Faiblesses de Sous-contrats}
\label{sec:swd}

\chapterintro

Dans ce chapitre, nous présentons la notion de faiblesse de l'ensemble des
sous-contrats et de faiblesse d'un sous-contrat, pour les sous-contrats du
programme sous vérification que sont les contrats de boucles et les contrats
de fonctions appelées.
Nous présentons également les spécificités de la traduction des annotations pour
la détection des faiblesses de sous-contrats par rapport à la traduction pour la
détection de non-conformités présentée au chapitre~\ref{sec:traduction}.
La partie~\ref{sec:swd-global} présente la notion de faiblesse de l'ensemble des
sous-contrats et la partie~\ref{sec:swd-single} présente la notion de faiblesse
d'un sous-contrat.
La partie ?? illustre la détection de faiblesses de sous-contrats sur l'exemple
du chapitre~\ref{sec:ncd}.


\section{Détection de faiblesse de l'ensemble des sous-contrats}
\label{sec:swd-global}


Avant de présenter nos définitions de faiblesses de sous-contrat, nous avons
besoin de définir des concepts supplémentaires.
Une boucle (respectivement une fonction, une assertion) \emph{non-imbriquée} de
$f$ est une boucle (respectivement une fonction appelée, une assertion) de $f$
en dehors de toute boucle de $f$.
Un \emph{sous-contrat pour $f$} est le contrat d'une boucle ou d'une fonction
non-imbriquée de $f$.
Une \emph{annotation non-imbriquée} de $f$ est soit une assertion non-imbriquée
soit une annotation d'un sous-contrat pour $f$.
%% Par exemple, la fonction \lstinline'delete_substr' de la
%% figure~\ref{??} (\commentGP{code complet}) du chapitre~\ref{sec:ncd} a quatre
%% sous-contrats : le contrat de la fonction appelée \lstinline'find_substr' et le
%% contrat de chacune des trois boucles de la fonction \lstinline'delete_substr'.
%% Les contrats éventuels des boucles de \lstinline'find_substr' sont des
%% sous-contrats de \lstinline'find_substr' mais pas des sous-contrats de
%% \lstinline'delete_substr'.

Nous nous concentrons sur les annotations non-imbriquées de $f$ et supposons que
tous les sous-contrats pour $f$ sont respectés : les fonctions appelées par $f$
respectent leur contrat et les boucles de $f$ préservent leurs invariants et
respectent les annotations imbriquées.
Soit $c_f$ le contrat de $f$, $\C$ l'ensemble des sous-contrats non-imbriqués
pour $f$, et $\A$ l'ensemble des annotations non-imbriquées de $f$ et des
annotations de $c_f$.
En d'autres termes, $\A$ contient les annotations des contrats $\C\cup\{c_f\}$,
ainsi que les assertions non-imbriquées de $f$.
Nous supposons également que chaque sous-contrat de $f$ contient une clause
\lstinline'assigns' ou \lstinline'loop assigns'.
Cette hypothèse n'est pas limitative puisqu'une telle clause est de toute
manière nécessaire à la preuve de toute fonction ou boucle non triviale.


\begin{figure}[tb]
\begin{center}
\begin{minipage}{0.35\columnwidth}
\begin{lstlisting}[mathescape]
/*@ assigns k1,...,kN;
  @ ensures P; */
$Type_g$ g(...){ code1; }




$Type_f$ f(...){ code2;
  g($Args_g$);
  code3; }
\end{lstlisting}
\end{minipage}
\hspace{-6mm}
\begin{minipage}{0.07\columnwidth}$\to$\end{minipage}
\begin{minipage}{0.35\columnwidth}
\begin{lstlisting}[mathescape]
$Type_g$ g_swd(...){
  k1=Nondet(); ... kN=Nondet();
  $Type_g$ ret = Nondet();
  int post; $Spec2Code$(P, post);
  fassume(post); return ret;
} //respects contract of g
$Type_g$ g(...){ code1; }
$Type_f$ f(...){ code2;
  g_swd($Args_g$);
  code3; }
\end{lstlisting}
\end{minipage}
\vspace{-3mm}
\caption{(a) Un contrat $c\in\C$ d'une fonction $g$ appelée par $f$, et
(b) sa traduction %in $P_\all^{\CW}$ 
pour \CWD}
\vspace{-3mm}
\label{fig:CW-transf-functions}
\end{center}
\end{figure}



\begin{figure*}[tb]
\begin{center}
\begin{minipage}{0.35\columnwidth}
\begin{lstlisting}[mathescape]
$Type_f$ f(...){ code1;
  /*@ loop assigns x1,...,xN;
    @ loop invariant I; */
  while(b){ code2; }
  code3; }
\end{lstlisting}
\end{minipage}
\hspace{-6mm}
\begin{minipage}{0.07\columnwidth}$\to$\end{minipage}
\begin{minipage}{0.55\columnwidth}
\begin{lstlisting}[mathescape]
$Type_f$ f(...){ code1;
  x1=Nondet(); ... xN=Nondet();
  int inv1; $Spec2Code$(I, inv1);
  fassume(inv1 &$ $& !b); //respects l$ $oop contract
  code3; }
\end{lstlisting}
\end{minipage}
\vspace{-3mm}
\caption{(a) Un contrat $c\in\C$ d'une boucle de $f$, et
(b) sa traduction %in $P_\all^{\CW}$ 
pour \CWD}
\vspace{-3mm}
\label{fig:CW-transf-loops}
\end{center}
\end{figure*}

Afin d'appliquer la génération de tests aux contrats des fonctions appelées et
des boucles de $\C$ au lieu de leur code, nous utilisons une transformation de
programme qui produit un nouveau programme $P^{\GSW}$ à partir de $P$.
Le code de chaque appel de fonction et de chaque boucle de $f$ est remplacé
par un nouveau code que nous définissons maintenant.

\begin{figure}[tb]
  \scriptsize{
    {\myinference{$\alpha$-assume-assigns}
      {}
      {(End_f, \mbox{\lstinline'assigns X;'})
        \rulearrow
        \forall (\mbox{\lstinline'x'}:ctype) \in X :
        (End_f, \mbox{\lstinline'x = nondet();'})}{}
    }

    {\myinference{$\alpha$-assume-post}
      {(End_f, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
      {(End_f, \mbox{\lstinline'ensures p;'})
        \rulearrow
        I \concat (End_f, \mbox{\lstinline'fassume(e);'})}{}
    }
  }
  \caption{Règles de traduction pour la détection des faiblesses de
    sous-contrats des fonctions appeleés}
  \label{fig:assume-annot}
\end{figure}

Pour un contrat $c\in\C$ d'une fonction $g$ appelée par $f$, la transformation
de programme (illustrée par la figure~\ref{fig:CW-transf-functions}) génère une
nouvelle fonction \lstinline{g_swd} ayant la même signature et dont le code
simule tous les comportements possibles respectant la postcondition du
contrat $c$, et remplace chaque appel à $g$ par un appel à \lstinline{g_swd}.
Tout d'abord, \lstinline{g_swd} permet aux variables (et plus généralement aux
left-values) présentes dans la clause \lstinline'assigns' de $c$ de changer de
valeur (ligne 2 de la figure~\ref{fig:CW-transf-functions}(b)).
Ceci est possible en affectant une valeur non-déterministe du type adéquat,
dont la génération est ici notée par \lstinline{Nondet()} (ou simplement en
utilisant un tableau contenant les variables d'entrée fraîches, dans lequel on
va lire de nouvelles valeurs pour chaque appel de la fonction $g$).
La règle \textsc{$\alpha$-assume-assigns} de la figure~\ref{fig:assume-annot}
présente la traduction de la clause \lstinline'assigns'.
Si le type de retour de $g$ n'est pas \lstinline{void}, une valeur
non-déterministe supplémentaire est générée pour la valeur de retour
\lstinline{ret} (ligne 3 de la figure~\ref{fig:CW-transf-functions}(b)).
Enfin, la validité de la postcondition est évaluée (en prenant en compte ces
nouvelles valeurs non-déterministes) et admise afin de ne considérer que les
exécutions de la fonction qui respectent cette postcondition, puis la fonction
termine son exécution (lignes 4--5 de la
figure~\ref{fig:CW-transf-functions}(b)).
La règle \textsc{$\alpha$-assume-post} de la figure~\ref{fig:assume-annot}
présente la traduction de la postcondition.

\begin{figure}[tb]
  \scriptsize{
    {\myinference{$\alpha$-assume-loop-assigns}
      {}
      {(l, \mbox{\lstinline'loop assigns X;'})
        \rulearrow
        \forall (\mbox{\lstinline'x'}:ctype) \in X :
        (l, \mbox{\lstinline'x = nondet();'})}{}
    }

    {\myinference{$\alpha$-assume-invariant}
      {(l, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
      {
        (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
        I \concat (l, \mbox{\lstinline'fassume(e && !loopcond);'})
      }{}
    }

    %% {\myinference{$\alpha$-assume-invariant-2}
    %%   {(l, \mbox{\lstinline'p'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
    %%     (EndIter_l, \mbox{\lstinline'p'}) \rulearrow
    %%     (I_2, \mbox{\lstinline'e2'})}
    %%   {
    %%     (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
    %%     I_1 \concat (l, \mbox{\lstinline'fassume(e1);'})
    %%     \concat I_2 \concat (EndIter_l, \mbox{\lstinline'fassert(e2);'})
    %%   }{}
    %% }
  }
  \caption{Règles de traduction pour la détection des faiblesses de
    sous-contrats des boucles}
  \label{fig:assume-loop-annot}
\end{figure}

De manière similaire, pour un contrat $c\in\C$ d'une boucle de $f$, la
transformation de programme remplace le code de la boucle par un autre code qui
simule tous les comportements possibles respectant $c$, c'est-à-dire, s'assurant
de la validité de la ``postcondition de boucle'' $I\wedge \neg b$ après la
boucle, comme illustré sur la figure~\ref{fig:CW-transf-loops}.
Les règles \textsc{$\alpha$-assume-loop-assigns} et
\textsc{$\alpha$-assume-invariant-1} de la figure~\ref{fig:assume-loop-annot}
présentent respectivement la traduction des clauses \lstinline'loop assigns' et
\lstinline'loop invariant'.
La transformation de programme traite toute autre annotation de $\A$ de la
même manière que $P^{\NC}$ : préconditions des fonctions appelées, vérifications
initiales des invariants de boucle et pré- et postcondition de $f$ (qui
n'apparaissent pas sur les figures~\ref{fig:CW-transf-functions}(b)
et~\ref{fig:CW-transf-loops}(b)).


%\begin{tabular}{cc}
\begin{figure}[tb]
  \begin{minipage}{0.5\columnwidth}
  %\begin{figure}
    \lstinputlisting[label=fig:contracts-ex1,caption={Faiblesse de l'ensemble
        des sous-contrats%Absence of \CWCE{}s for any single subcontract does not imply absence of global \CWCE{}s
    }]{listings/ex1.c}
    %\vspace{-2mm}
    %\caption{Absence of \CWCE{}s for any single subcontract does not imply absence of global \CWCE{}s}
    %\label{fig:contracts-ex1}
  %\end{figure}
  %\hspace{4mm}
  \end{minipage}
  \begin{minipage}{0.5\columnwidth}
  %\begin{figure}
%&
    \lstinputlisting[label=fig:contracts-ex2,caption={Faiblesse d'un
        sous-contrat%Global \CWCE{}s do not help to find precisely a too weak subcontract
    }]{listings/ex2.c}
    %\vspace{-2mm}
    %\caption{Global \CWCE{}s do not help to find precisely a too weak subcontract}
    %\label{fig:contracts-ex2}
  %\end{figure}
  \end{minipage}
  %\vspace{-2mm}
  %\caption{(a) Faiblesse globale et (b) Faiblesse unique}
  %\vspace{-5mm}
  %\label{fig:many-contracts}
\end{figure}
%\end{tabular}

\begin{definition}[Faiblesse de l'ensemble des sous-contrats] 
  \label{def:GSW}
  $P$ a une \emph{faiblesse de l'ensemble des sous-contrats} pour $f$  si il
  existe un cas de test $V$ pour $f$ respectant sa précondition, tel que
  $P^{\NC}$ ne rapporte aucune violation d'annotation sur $V$, alors que
  $P^{\GSW}$ rapport une violation d'annotation sur $V$.
  Dans ce cas, on dit que $V$ est un
  \emph{contre-exemple de faiblesse de l'ensemble des sous-contrats} (ou \GSWCE
  pour {\em global subcontract weakness counter-example}) pour l'ensemble des
  sous-contrats $\C$.
\end{definition}

Nous ne considérons pas qu'un même contre-exemple puisse être à la fois un
contre-exemple de non-conformité et un contre exemple de faiblesse de
sous-contrat.
En effet, même si certains contre-exemples peuvent illustrer à la fois une
non-conformité et une faiblesse de sous-contrat, une non-conformité provient
généralement d'un conflit direct entre le code et sa spécification et doit être
corrigée en priorité, tandis qu'une faiblesse de contrat est souvent plus
subtile et ne doit être corrigée qu'une fois les non-conformités éliminées.

Encore une fois, la génération de tests peut être appliquée sur $P^{\GSW}$ pour
générer des \GSWCE potentiels.
Lorsqu'un cas de test $V$ tel que $P^{\GSW}$ échoue sur $V$ a été trouvé, nous
appliquons la validation à l'exécution :
si $P^{\NC}$ échoue sur $V$, alors $V$ est un \NCCE, sinon $V$ est un \GSWCE.
Nous appelons cette technique
\emph{Détection de faiblesse de l'ensemble des sous-contrats}, notée $\GSWD$
pour \textit{Global Subcontract Weakness Detection}.
$\GSWD$ peut produire quatre résultats.
Elle retourne (\nc,\,$V$,\,$a$) si un \NCCE $V$ a été trouvé pour l'annotation
$a$, et (\cw,\,$V$,\,$a$,\,$C$) si $V$ a été classifié en tant que \SWCE
indiquant l'annotation $a$ et l'ensemble des sous-contrats $C$.
Le chemin de programme $\pi_V$ activé par le cas de test $V$ et menant à
l'erreur (sur $P^{\NC}$ ou $P^{\GSW}$) est également récupéré.
If $\GSWD$ a réussi à explorer l'intégralité des chemins du programme sans
trouver de \GSWCE, elle retourne \no.
Sinon, si l'exploration des chemins du programme est seulement partielle, elle
retourne \textsf{?} ({\em unknown}).

Un \GSWCE indique une faiblesse de l'ensemble des sous-contrats d'une fonction
mais n'identifie pas précisément quel contrat $c\in\C$ est trop faible si
c'est le cas.
Nous proposons pour cela une autre transformation de programme de $P$ en un
programme instrumenté $P_c^{\SSW}$.
Elle réalise le remplacement d'un seul appel de fonction non imbriqué ou de
boucle par le code respectant la postcondition du sous-contrat $c$ correspondant
(comme le montrent les figures~\ref{fig:CW-transf-functions}
et~\ref{fig:CW-transf-loops}) et traduit les autres annotations de $\A$ de la
même manière que pour $P^{\NC}$.


\section{Détection de faiblesse d'un sous-contrat}
\label{sec:swd-single}


\begin{definition}[Faiblesse d'un sous-contrat] 
  \label{def:SSW}
  Soit $c$ un sous-contrat pour $f$.
  $c$ est un \emph{sous-contrat trop faible} (ou a une
  \emph{faiblesse de sous-contrat}) pour $f$ s'il existe un cas de test $V$ pour
   $f$ respectant sa précondition, tel que $P^{\NC}$ ne rapporte aucune violation
  d'annotation sur $V$, alors que $P_c^{\SSW}$ rapporte une violation
  d'annotation sur $V$.
  Dans ce cas, on dit que $V$ est un
  \emph{contre-exemple de faiblesse d'un sous-contrat} (ou \SSWCE pour
  \textit{single subcontract weakness counter-example}) pour le sous-contrat
  $c$ de $f$.
\end{definition}

Pour chaque sous-contrat $c\in\C$, la génération de tests peut être appliquée
de manière séparée sur $P_{c}^{\SSW}$ pour générer des \SSWCE potentiels.
Si un tel cas de test $V$ est généré, il est confirmé sur $P^{\NC}$ afin de
déterminer si c'est un \NCCE ou un \SSWCE.
Nous appelons cette technique, appliquée pour tous les sous-contrats l'un après
l'autre jusqu'à ce qu'un contre-exemple $V$ soit trouvé,
\emph{Détection de faiblesse d'un sous-contrat}, notée $\SSWD$ pour
\textit{Single Contract Weakness Detection}.
$\SSWD$ peut produire trois résultats.
Elle retourne (\nc,\,$V$,\,$a$) si un \NCCE $V$ a été trouvé pour une annotation
$a$, et (\cw,\,$V$,\,$a$,\,$\{c\}$) si $V$ a été classé comme étant un \SSWCE
indiquant que le sous-contrat $c$ est trop faible pour l'annotation $a$.
Le chemin de programme $\pi_V$ activé par $V$ et menant à l'erreur (sur $P^{\NC}$
ou $P_c^{\SSW}$) est également récupéré.
Sinon, elle retourne \textsf{?} ({\em unknown}), puisque même en cas
d'exploration complète des chemins du programme l'absence de \SSWCE pour un
unique sous-contrat $c$ n'implique pas l'absence de \GSWCE.

En effet, il arrive que $\SSWD$ ne puisse pas détecter de faiblesse pour un
sous-contrat en particulier alors qu'il y a une faiblesse pour un ensemble de
sous-contrats.
Dans l'exemple de la figure~\ref{fig:contracts-ex1}, si on applique $\SSWD$ à
un sous-contrat quelconque, on obtient toujours \lstinline'x >=  \old(x)+5' à la
fin de la fonction $f$ (on ajoute $1$ à $x$ en exécutant le sous-contrat traduit
et on ajoute $2$ par deux fois en exécurant le code des deux autres fonctions),
donc la postcondition de \lstinline'f' est vérifiée et aucune faiblesse de
sous-contrat n'est détectée.
Si on applique $\GSWD$ pour considérer tous les sous-contrats en une seule fois,
on obtient uniquement \lstinline'x>= \old(x)+3' après exécution des trois
sous-contrats, ce qui permet d'exhiber un contre-exemple pour cette faiblesse
des sous-contrats.

Inversement, $\GSWD$ produit un \GSWCE qui n'indique pas de manière précise
lequel des sous-contrats est trop faible, alors que $\SSWD$ apporte cette
précision.
Dans la figure~\ref{fig:contracts-ex2}, $\GSWD$ remplaçant le code des trois
fonctions appelées par leur contrat, il est impossible de déterminer quel
sous-contrat est trop faible.
Les contre-exemples générés par un prouveur souffrent du même problème
d'imprécision : prendre en compte tous les sous-contrats au lieu du code
correspondant ne permet pas d'identifier la faiblesse d'un unique sous-contrat.
Dans cet exemple nous pouvons être plus précis avec $\SSWD$, puisque le
remplacement de l'appel à \lstinline'g3' par son contrat produit un \SSWCE :
on a \lstinline'x >= \old(x)+3' en exécutant
\lstinline'g1',  \lstinline'g2' et le sous-contrat de \lstinline'g3',
exhibant la faiblesse du sous-contrat de \lstinline'g3'.
Ainsi, la technique $\SSWD$ fournit à l'ingénieur validation un diagnostic plus
précis qu'un contre-exemple produit par un prouveur.

Nous définissons une technique de détection combinée de faiblesses de
sous-contrats, notée \SWD, qui consiste à appliquer d'abord $\SSWD$ puis $\GSWD$
jusqu'à ce qu'un \SWCE soit trouvé. 
$\SWD$ produit les mêmes quatre résultats que $\SSWD$.
Cette méthode nous permet d'être plus précis (et d'indiquer si possible que la
faiblesse ne provient que d'un seul sous-contrat) et complet (capable de trouver
un \GSWCE même lorsqu'il n'y a pas de faiblesse de sous-contrat provenant d'un
unique sous-contrat).


\section*{Conclusion du chapitre}


Dans ce chapitre, nous avons définit les notions de faiblesse de l'ensemble des
sous-contrats et faiblesse d'un sous-contrat.
Nous avons également présenté les spécificités de la traduction des annotations
par rapport à la traduction pour la détection de non-conformités présentée au
chapitre~\ref{sec:traduction}.

Le chapitre~\ref{sec:method} montrera que l'utilisation combinée de la détection
des non-conformités présentée au chapitre~\ref{sec:ncd} et la détection des
faiblesses de sous-contrats présentée dans ce chapitre peut aider au diagnostic
des échecs de preuve.
