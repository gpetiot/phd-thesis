
\chapter{Précondition unique pour l'analyse statique et l'analyse dynamique}

Ce travail est nécessaire afin de poursuivre l'intégration de
\textsc{PathCrawler} \cite{PathCrawler} dans \textsc{Frama-C} \cite{Frama-C}.
Cela évite à l'utilisateur de devoir spécifier son programme avec deux
préconditions différentes et facilite la mise en \oe{}uvre des différentes
combinaisons d'analyse statique et dynamique au sein de la plate-forme.

\section{Fonction sous test}


\begin{figure}[h]
  \begin{lstlisting}
/*@

§$\forall i: 0 \le i < N:$§
  behavior §$B_i$§:
    assumes §$A_i^0$§; §$\dots$§ assumes §$A_i^a$§;
    requires §$R_i^0$§; §$\dots$§ requires §$R_i^r$§;
    ensures §$E_i^0$§; §$\dots$§ ensures §$E_i^e$§;

§$\forall i: 0 \le i < C:$§
    complete behaviors §$\alpha_i^0, \dots, \alpha_i^c$§;

§$\forall i: 0 \le i < D:$§
    disjoint behaviors §$\beta_i^0, \dots, \beta_i^d$§;
*/

int f (§$\dots$§);
  \end{lstlisting}
  \caption{Fonction sous test}
\end{figure}


La fonction sous test a une liste non vide de behaviors, qui comprend un
behavior par défaut. Chaque comportement contient des clauses assumes, requires
et ensures.\\

La pré-condition de la fonction est :

$\bigwedge_i [ (\bigwedge^\alpha A_i^\alpha) \Longrightarrow
(\bigwedge^\alpha R_i^\alpha) ]$

La post-condition de la fonction est :

$\bigwedge_i [ (\bigwedge^\alpha A_i^\alpha) \Longrightarrow
(\bigwedge^\alpha R_i^\alpha) \Longrightarrow
(\bigwedge^\alpha E_i^\alpha) ]$\\

La spécification peut préciser une liste de clauses complete behaviors.
Pour chacune de ces clauses, une liste de behaviors est fournie, l'union de ces
behaviors doit couvrir toutes les exécutions : chaque exécution de la fonction
doit être incluse dans au moins un des behaviors de chaque clause.\\

Une liste de clauses disjoint behaviors peut aussi être précisée. Pour chacune
de ces clauses, une liste de behaviors est fournie, les behaviors de cette liste
doivent être disjoints deux à deux (intersection vide) : chaque exécution de la
fonction doit être incluse dans au plus un des behaviors de chaque clause.


\section{Nouveau point d'entrée}


\begin{figure}[h]
  \begin{lstlisting}
int foo (§$\dots$§, int behaviors[§$N$§]) {
  int ret = f(§$\dots$§);

  §$\forall i: 0 \le i < N:$§
    [else] if(behaviors[§$i$§] == 1) {
      if(!§$E_i^0$§)
        pathcrawler_assert_exception(§$\dots$§);
      §$\dots$§
      if(!§$E_i^e$§)
        pathcrawler_assert_exception(§$\dots$§);
    }

  return ret;
}
  \end{lstlisting}
  \caption{Nouveau point d'entrée}
\end{figure}

On définit une nouvelle fonction qui servira de point d'entrée au programme.
L'argument supplémentaire de cette fonction est un tableau de booléens tel
que $behaviors[i]$ vaut 1 si le behavior $B_i$ s'applique, 0 sinon. Ce tableau
est contraint dans la fonction de précondition.\\

Pour chacun des behaviors, on teste si le behavior s'applique (la précondition
aura déjà mis en relation le contenu du tableau behaviors avec les différentes
clauses assumes et requires). Si le behavior s'applique, on essaie de trouver un
contre-exemple pour chacune des clauses ensures. Des branches artificielles sont
créées menant à {\tt pathcrawler\_assert\_exception}.\\

Cette instrumentation est nécessaire uniquement si on souhaite trouver un
contre-exemple sur la post-condition, ce qui s'apparente à du test fonctionnel.

\section{Précondition}


Dans le cas où seul le behavior par défaut est utilisé, on essaie de traduire
les clauses requires en précondition Prolog. Si la traduction échoue car un des
termes n'est pas représentable dans le langage de préconditon de
\textsc{PathCrawler} (disjonction par exemple), on génèrera la précondition C.\\


\begin{figure}
  \centering
  \begin{tabular}{|c|c|}
    \hline
    Précondition \textsc{Acsl} & Précondition \textsc{PathCrawler}\\
    \hline
    ${\tt \backslash valid (t)}$ & ${\tt dim('t') = 1}$\\
    \hline
    ${\tt \backslash valid (t+(0..N))}$ & ${\tt dim('t') = N+1}$\\
    \hline
    ${\tt X \leq Y}$ & ${\tt X \leq Y}$\\
    \hline
    ${\tt X < Y}$ & ${\tt X < Y}$\\
    \hline
  \end{tabular}
  \caption{Motifs traités}
\end{figure}~\\
  
Dans tous les autres cas, il faudra générer la précondition au format C.\\

\begin{figure}[h]
  \begin{lstlisting}
int foo_precond (§$\dots$§, int behaviors[§$N$§]) {

  §$\forall i: 0 \le i < N:$§
    if(§$A_i^0 \land \dots \land A_i^a$§) {
      if(!§$R_i^0$§) return 0;
      §$\dots$§
      if(!§$R_i^r$§) return 0;
      if(behaviors[§$i$§] §$\ne$§ 1) return 0;
    }
    else {
      if(behaviors[§$i$§] §$\ne$§ 0) return 0;
    }

  return 1;
}
  \end{lstlisting}
  \caption{Précondition}
\end{figure}

Pour chacun des behaviors : si la conjonction des clauses assumes est vraie, la
conjonction des requires est censée être vraie aussi. On retourne 0 dès qu'une
clause requires n'est pas satisfaite. Si toutes les clauses requires sont
vraies, on contraint behaviors[i] à prendre la valeur 1.
Si la conjonction des assumes n'est pas vérifiée, on contraint behaviors[i] à
prendre la valeur 0.


\section{Oracle}


\begin{figure}[h]
  \begin{lstlisting}
int oracle_foo (§$\dots$§, int Pre_behaviors[§$N$§], int behaviors[§$N$§],
  int pathcrawler_retres__foo) {
  
    §$\forall i: 0 \le i < C:$§
    if(§$\sum$§ behaviors[§$\alpha_i$§] == 0) {
      pathcrawler_verdict_failure();
      return;
    }

    §$\forall i: 0 \le i < D:$§
    if(§$\sum$§ behaviors[§$\beta_i$§] > 1) {
      pathcrawler_verdict_failure();
      return;
    }

    pathcrawler_verdict_unknown();
    return;
}
  \end{lstlisting}
  \caption{Oracle}
\end{figure}

Pour chaque clause complete behaviors, on compte le nombre de behaviors activés,
il est censé être strictement positif. Verdict failure s'il est nul. Pour chaque
clause disjoint behaviors, on compte le nombre de behaviors activés, il est
censé être égal à 0 ou 1. Verdict failure s'il est strictement supérieur à 1.\\

Cette instrumentation est nécessaire uniquement si on cherche à valider les
propriétés sur les clauses complete behaviors et disjoint behaviors.
