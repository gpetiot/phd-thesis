
\chapter{Preuve de correction}
\label{sec:preuve-correction}

\chapterintro

L'objectif du chapitre est de prouver certaines propriétés de correction sur
les règles de traduction présentées dans le chapitre~\ref{sec:traduction}.

Nous voulons notamment nous assurer qu'une erreur est trouvée par le
générateur de tests si et seulement si il y a une inconsistance entre le code
et sa spécification.

La sémantique des annotations, des termes et des prédicats de
\eacsl \cite{\citeeacsl} est présentée en partie~\ref{sec:notations}.
Les propriétés que nous vérifions sont définies en partie~\ref{sec:properties}.
Les parties~\ref{sec:term-translation}, \ref{sec:predicate-translation} et
\ref{sec:annotation-translation} détaillent la preuve de ces propriétés
respectivement sur les termes, sur les prédicats et sur les annotations.


\section{Notations}
\label{sec:notations}


Nous définissons les fonctions et symboles qui sont utilisés dans la suite du
chapitre.

\begin{notation}
  ~
  \begin{itemize}
  \item $x$, $y$ et $z$ sont des identificateurs de variable
  \item $v$ est une valeur
  %\item $\bot$ est une valeur spéciale qui signifie qu'une variable n'est pas
  %  ou plus initialisée (après un \lstinline'free' ou une désallocation GMP).
  \item $i$, $i_1$, $i_2$ sont des instructions
  \item $A$, $B$ sont des blocs d'instructions
  \item $e$, $e_1$, $e_2$ sont des expressions C
  \item $t$, $t_1$, $t_2$ sont des termes ($\in TERM$)
  \item $p$, $p_1$, $p_2$ sont des prédicats ($\in PRED$)
  \end{itemize}
\end{notation}


\subsection{Environnements}

Un environnement \env est une fonction partielle \env $: ID \mapsto VAL$ des
identificateurs de variables dans le domaine sémantique des valeurs
possibles.

Le domaine des valeurs est défini comme l'union des types logiques que peuvent
prendre les termes et prédicats \eacsl :
$VAL = \mathbb{B}~\cup~\mathbb{Z}~\cup~\mathbb{R}$

La notation \env[$x \mapsto v$] est désigne un nouvel environnement,
correspondant à l'environnement \env auquel la relation $(x, v)$ a été ajoutée,
ce qui signifie qu'on remplace l'ancienne valeur de $x$ par $v$.

L'accès à la valeur d'une variable dans un environnement est défini par :

\begin{tabular}{rclr}
  (\env[$x \mapsto v$])($x$) & = & $v$ & \eqlabel{env-1} \\
  (\env[$x \mapsto v$])($y$) & = & \env($y$) si $x \neq y$ & \eqlabel{env-2}\\
\end{tabular}

Dans la suite, nous utiliserons la notation
\env[$x \mapsto v_1, y \mapsto v_2$] (en supposant que $x \not = y$) comme un
raccourci pour \env[$x \mapsto v_1$][$y \mapsto v_2$].

La notation \env $-~\{\mbox{\lstinline'x'}\}$ signifie que la left-value
\lstinline'x' et sa valeur sont enlevées de l'environnement \env :

\begin{tabular}{rcl}
  (\env[$x \mapsto v$])$-~\{\mbox{\lstinline'a'}\}$
  &=& (\env$-~\{\mbox{\lstinline'a'}\}$)[$x \mapsto v$] si $x \neq a$ \\
  (\env[$a \mapsto v$])$-~\{\mbox{\lstinline'a'}\}$ &=& \env \\
\end{tabular}

Nous définissons également une relation d'inclusion sur les ensembles,
c'est-à-dire \env$_1$ est inclus dans \env$_2$ si et seulement si
chaque affectation $(x, v)$ présente dans l'environnement \env$_1$ est
également présente dans \env$_2$ :

\env$_1$ $\subset$ \env$_2$ $\equiv$
$\forall (x, v). (x \mapsto v) \in \mbox{\env}_1 \Rightarrow (x \mapsto v) \in \mbox{\env}_2$


\subsection{Sémantique Dénotationnelle des Termes, Prédicats et Expressions}

La sémantique dénotationnelle des expressions C et des termes et prédicats
\eacsl est exprimée avec la fonction
$\mathcal{E} : (EXP \cup TERM \cup PRED) \mapsto ENV \mapsto VAL$.
Cette fonction associe à une expression C (ou un terme ou prédicat \eacsl) dans
un environnement une valeur, à condition que cette expression ne génère pas
d'effet de bord, hypothèse satisfaite par le langage considéré après
normalisation du code par \framac.
%Une expression C \underline{soulignée} utilise la sémantique des entiers non
%bornés.

La sémantique des expressions C et des termes \eacsl est donnée en
figure~\ref{fig:sem-exp}.
La sémantique des prédicats \eacsl est donnée en figure~\ref{fig:sem-pred}.

\begin{figure}[bt]
  \begin{tabular}{rclr}
    \eval{cst}{\env} &=& cst & \eqlabel{E-cst} \\
    \eval{lvalue}{\env} &=& \env(lvalue) si $lvalue$ est une variable
    & \eqlabel{E-lval} \\
    \eval{\lstinline|unop t|}{\env}
    &=& \lstinline|unop| (\eval{\lstinline|t|}{\env}) & \eqlabel{E-unop} \\
    \eval{\lstinline|t1 binop t2|}{\env}
    &=& (\eval{\lstinline|t1|}{\env}) \lstinline|binop|
    (\eval{\lstinline|t2|}{\env}) & \eqlabel{E-binop} \\
    \eval{\lstinline'\\abs(t)'}{\env} &=&
    $\lvert$ \eval{\lstinline't'}{\env} $\rvert$ & \eqlabel{E-abs} \\
    \eval{\lstinline'\\sum(t1, t2, \\lambda integer k; t3)'}{\env} &=&
    $\sum_{k = \mbox{\eval{\lstinline't1'}{\env}}}^{\mbox{\eval{\lstinline't2'}{\env}}} \mbox{\eval{\lstinline't3'}{\env}}$
    & \eqlabel{E-sum} \\
    \eval{\lstinline'\\product(t1, t2, \\lambda integer k; t3)'}{\env} &=&
    $\prod_{k = \mbox{\eval{\lstinline't1'}{\env}}}^{\mbox{\eval{\lstinline't2'}{\env}}} \mbox{\eval{\lstinline't3'}{\env}}$
    & \eqlabel{E-prod} \\
    \eval{\lstinline'\\numof(t1, t2, \\lambda integer k; t3)'}{\env} &=&
    $\sum_{k = \mbox{\eval{\lstinline't1'}{\env}}}^{\mbox{\eval{\lstinline't2'}{\env}}} \mbox{\eval{\lstinline't3 ? 1 : 0'}{\env}}$
    & \eqlabel{E-num} \\
    \eval{\lstinline't1 ? t2 : t3'}{\env} &=& \eval{\lstinline't2'}{\env}
    si (\eval{\lstinline't1'}{\env}) $\neq$ 0, \eval{\lstinline't3'}{\env} sinon
    & \eqlabel{E-tif} \\
    \eval{\lstinline'\\old(t)'}{\env} &=&
    \eval{\lstinline't'}{(\env en début de fonction)}
    & \eqlabel{E-old} \\
    \eval{\lstinline'\\null'}{\env} &=& \lstinline'NULL' & \eqlabel{E-null} \\
    \eval{\lstinline|(type) t|}{\env}
    &=& \lstinline|(type)| (\eval{\lstinline|t|}{\env}) & \eqlabel{E-cast} \\
  \end{tabular}
  \caption{Sémantique dénotationnelle des termes et expressions}
  \label{fig:sem-exp}
\end{figure}


\begin{figure}[bt]
  \begin{tabular}{rclr}
    \eval{\lstinline'\\true'}{\env} &=& \textit{true} & \eqlabel{P-true} \\
    \eval{\lstinline'\\false'}{\env} &=& \textit{false} & \eqlabel{P-false} \\
    \eval{\lstinline'\\valid(t)'}{\env} &=& \textit{true} si \lstinline'*t' est
    défini dans \env, \textit{false} sinon & \eqlabel{P-valid} \\
    \eval{\lstinline'\\forall integer k; t1 <= k <= t2 ==> p'}{\env} &=&
    $\forall k.$ \eval{\lstinline't1'}{\env} $\le$ $k$ $\le$
    \eval{\lstinline't2'}{\env} $\Rightarrow$ \eval{\lstinline'p'}{\env}
    & \eqlabel{P-forall} \\
    \eval{\lstinline'\\exists integer k; t1 <= k <= t2 \&\& p'}{\env} &=&
    $\exists k.$ \eval{\lstinline't1'}{\env} $\le$ $k$ $\le$
    \eval{\lstinline't2'}{\env} $\land$ \eval{\lstinline'p'}{\env}
    & \eqlabel{P-exists} \\
    \eval{\lstinline'\! p'}{\env} &=& $\lnot$ (\eval{\lstinline'p'}{\env})
    & \eqlabel{P-not} \\
    \eval{\lstinline'p1 \&\& p2'}{\env} &=&
    (\eval{\lstinline'p1'}{\env}) $\land$ (\eval{\lstinline'p2'}{\env})
    & \eqlabel{P-and} \\
    \eval{\lstinline'p1 || p2'}{\env} &=&
    (\eval{\lstinline'p1'}{\env}) $\lor$ (\eval{\lstinline'p2'}{\env})
    & \eqlabel{P-or} \\
    \eval{\lstinline'p1 ==> p2'}{\env} &=&
    (\eval{\lstinline'p1'}{\env}) $\Rightarrow$ (\eval{\lstinline'p2'}{\env})
    & \eqlabel{P-impl} \\
    \eval{\lstinline'p1 <==> p2'}{\env} &=&
    (\eval{\lstinline'p1'}{\env}) $\Leftrightarrow$(\eval{\lstinline'p2'}{\env})
    & \eqlabel{P-eq} \\
    \eval{\lstinline't ? p1 : p2'}{\env} &=& \eval{\lstinline'p1'}{\env}
    si (\eval{\lstinline't'}{\env}) $\neq$ 0, \eval{\lstinline'p2'}{\env} sinon
    & \eqlabel{P-pif} \\
    \eval{\lstinline|t1 rel t2|}{\env}
    &=& (\eval{\lstinline|t1|}{\env}) \lstinline|rel|
    (\eval{\lstinline|t2|}{\env}) & \eqlabel{P-rel} \\
  \end{tabular}
  \caption{Sémantique dénotationnelle des prédicats}
  \label{fig:sem-pred}
\end{figure}


\subsection{Sémantique Dénotationnelle des Instructions}

La sémantique dénotationnelle des instructions C est exprimée avec la fonction
$\mathcal{C} : INSTR \mapsto ENV \mapsto ENV$.
Cette fonction associe à une instruction $i$ et un environnement \env un nouvel
environnement qui prend en compte les modifications effectuées par $i$ dans
l'environnement \env.
Une instruction \underline{soulignée} utilise la sémantique des entiers non
bornés.

La sémantique des instructions C est donnée en figure~\ref{fig:sem-instr}.
Dans la règle \eqlabel{C-Z-set}, la variable entière (GMP) \lstinline'lval' est
allouée et on lui affecte la valeur de \lstinline'e'.
Dans la règle \eqlabel{C-Z-unset}, la variable entière (GMP) \lstinline'lval'
est désallouée et enlevée de l'environnement \env.

\begin{figure}
  \begin{tabular}{p{4.2cm} p{.4cm} p{9cm} p{2cm}}
    \comp{\lstinline'\;'}{\env} &=& \env & \eqlabel{C-skip} \\
    \comp{\lstinline'i1 ; i2'}{\env} &=&
    \comp{\lstinline'i2'}{(\comp{\lstinline'i1'}{\env})}
    & \eqlabel{C-seq} \\
    \comp{$\bopen$ \lstinline'i1 ; i2' $\bclose$}{\env} &=&
    \comp{\lstinline'i2'}{(\comp{\lstinline'i1'}{\env})}
    & \eqlabel{C-block} \\
    \comp{\lstinline|lval = e;|}{\env}
    &=& \env[$lval \mapsto$ \eval{e}{\env}] \scriptsize{(arith. bornée)}
    & \eqlabel{C-set} \\
    \comp{\lstinline'if(e)' $\bopen A \bclose$
      \lstinline'else' $\bopen B \bclose$}{\env}
    &=& \comp{A}{\env} si (\eval{e}{\env}) $\neq$ 0, \comp{B}{\env} sinon
    & \eqlabel{C-if} \\
    \comp{\lstinline'/*@ assert p; */'}{\env}
    &=& \env si (\eval{p}{\env}) $\neq$ 0, erreur sinon
    & \eqlabel{C-assert} \\
    \comp{\lstinline'fassert(e);'}{\env}
    &=& \env si (\eval{e}{\env}) $\neq$ 0, erreur sinon & \eqlabel{C-fassert} \\
    \comp{\lstinline'fassume(e);'}{\env}
    &=& \env si (\eval{e}{\env}) $\neq$ 0, contradiction sinon
    & \eqlabel{C-fassume} \\
    \comp{\lstinline|while(e)| $\bopen A \bclose$}{\env}
    &=& \comp{\lstinline|while(e)| $\bopen A \bclose$}{(\comp{A}{\env})}
    si \eval{e}{\env} $\neq$ 0, \env sinon  & \eqlabel{C-while} \\
    \comp{\lstinline'/*@ loop invariant p; loop assigns X; loop variant t; */ while(e)' $\bopen A \bclose$}{\env}
    & = & erreur si $\lnot$ \eval{p}{\env}
    & \eqlabel{C-while-1} \\
    & = & \env si (\eval{\lstinline'e'}{\env}) $=$ 0
    & \eqlabel{C-while-2} \\
    & = & erreur si $\lnot$ \eval{\lstinline't >= 0'}{\env}
    & \eqlabel{C-while-3} \\
    & = & erreur si $\lnot$ \eval{p}{(\comp{A}{\env})}
    & \eqlabel{C-while-4} \\
    & = & erreur si (\eval{t}{(\comp{A}{\env})}) $\ge$ (\eval{t}{\env})
    & \eqlabel{C-while-5} \\
    & = & erreur si
    $\exists x. x \in G-X.$ (\eval{x}{(\comp{A}{\env})}) $\ne$ (\eval{x}{\env})
    & \eqlabel{C-while-6} \\
    & = &
    \comp{\lstinline'/*@ ... */ while(e)' $\bopen A \bclose$}{(\comp{A}{\env})}
    sinon
    & \eqlabel{C-while-7} \\
    \comp{$\Zinit$ \underline{\lstinline|lval = e|} $\semicolon$}{\env}
    &=& \env[$lval \mapsto$ \eval{e}{\env}] \scriptsize{(arith. non bornée)}
    & \eqlabel{C-Z-set} \\
    \comp{\underline{\lstinline|lval|} $\Zclear \semicolon$}{\env}
    &=& \env $-~\{\mbox{\lstinline'a'}\}$ & \eqlabel{C-Z-unset} \\
  \end{tabular}
  \caption{Sémantique dénotationnelle des instructions}
  \label{fig:sem-instr}
\end{figure}


\subsection{Définition des séquences d'insertions de code}

Une insertion de code est un couple $(LABEL \times INSTR)$.
Une liste (ou séquence) d'insertions de code résulte de la traduction d'un
terme, prédicat ou d'une annotation \eacsl.
Une séquence est notée :

\begin{itemize}
\item $\emptylist$ pour une séquence vide;
\item $(l, i) \concat I$ pour la concaténation de $(l, i)$ au début de la
  séquence $I$;
\item $I_1 \concat I_2$ pour la concaténation de deux séquences $I_1$ et $I_2$.
\end{itemize}

Par exemple, la règle suivante montre la séquence d'insertions de code $I$
générée pour la traduction du prédicat \lstinline'p_1 && p_2' :

{\myinference[$\pi$-and]
  { (l, \mbox{\lstinline'p1'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
    (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'}) }
  { (l, \mbox{\lstinline'p1 && p2'}) \rulearrow
    (
    \underbracket{
      I_1 \cdot
      \underbracket{ (l, \mbox{\lstinline'int e = e1;'}) }_{i_1}
      \cdot
      \underbracket{ (l, \mbox{\lstinline'if(e)'}
        \bopen
        I_2 \cdot
        \underbracket{ (l, \mbox{\lstinline'e = e2;'}) }_{i_2}
        \bclose ) }_{i_3} \concat \emptylist
      }_{I},
    \mbox{\lstinline'e'}) }
}~\\

Dans cet exemple, $i_1$, $i_2$ et $i_3$ sont des insertions de code, tandis que
$I_1$, $I_2$ et $I$ sont des séquences d'insertions de code.
\lstinline'e' est une left-value qui a une valeur dans l'environnement courant.


\subsection{Sémantique dénotationnelle des insertions de code}

La sémantique dénotationnelle des insertions de code est exprimée avec la
fonction $\mathcal{I} : list(LABEL * INSTR) \mapsto ENV \mapsto ENV$.
À chaque séquence d'insertions de code C et un environnement est associé un
nouvel environnement.

La fonction $\mathcal{I}$ est définie comme suit :

\begin{tabular}{rclr}
  \compi{$\emptylist$}{\env} & = & \env & \eqlabel{I-empty} \\
  \compi{($l$, $i$) $\concat~\emptylist$}{\env}
  & = & \comp{$i$}{\env$_l$} & \eqlabel{I-instr} \\
  \compi{$I_1 \concat I_2$}{\env} & = & \compi{$I_2$}{(\compi{$I_1$}{\env})}
  & \eqlabel{I-split} \\
\end{tabular}

La règle \eqlabel{I-empty} énonce qu'une séquence vide ne modifie pas
l'environnement.
La règle \eqlabel{I-instr} évalue l'instruction $i$ au label $l$ afin de
calculer le nouvel environnement.
La règle \eqlabel{I-split} traite le cas de la concaténation d'insertions de
code.


\section{Propriétés}
\label{sec:properties}

\begin{notation}
  Soit $P$ un programme C annoté et syntaxiquement correct selon la grammaire
  définie au chapitre précédent.
  Soit $P'$ le programme instrumenté obtenu après traduction du programme $P$.
\end{notation}



\begin{theorem}
  Si une annotation $a$ du programme $P$ est invalide, alors l'exécution
  des instructions obtenues par traduction provoque une erreur dans le
  programme instrumenté $P'$.
\end{theorem}

\begin{theorem}
  Si toutes les annotations d'un programme $P$ sont valides, alors $P$ et $P'$
  (obtenu après traduction de $P$) ont la même sémantique, c'est-à-dire le même
  comportement est observable à l'exécution.
\end{theorem}



\section{Preuve de la Traduction des Termes}
\label{sec:term-translation}

Afin de prouver la correction de la traduction des prédicats et des annotations,
nous devons prouver la correction de la traduction des termes.
Le lemme~\ref{lem:term-correct} énonce que l'évaluation des insertions de code
$I$ générées lors de la traduction d'un terme \lstinline't' ajoute une nouvelle
variable \lstinline'e' (fraîche) à l'environnement \env, dont la valeur
correspond à l'évaluation de \lstinline't' dans \env.
Cette propriété doit être prouvée sur chaque terme de la grammaire des termes
définie au chapitre précédent.
Pour des raisons de lisibilité, la preuve de cette propriété est uniquement
fournie pour la règle \textsc{$\tau$-const} de traduction des constantes.

\begin{lemma}
  \label{lem:term-correct}
  Soit \lstinline't' : $\tau$ un terme de type $\tau$, qui se traduit en
  $(I, \mbox{\lstinline'e'})$.
  La traduction est correcte si et seulement si, pour n'importe quel
  environnement \env :

  \comp{$I$}{\env} = \env[\lstinline'e' $\mapsto$ \eval{\lstinline't'}{\env}]

  et \comp{$I$}{\env} ne produit pas d'erreur.
\end{lemma}


\subsection{Preuve de la Traduction des Constantes}

{\myinference[$\tau$-const]
  {}
  { (l, \mbox{\lstinline'v'} : \mathbb{Z}) \rulearrow
    ((l, \Zinit\underline{\mbox{\lstinline'x = v;'}}), \mbox{\lstinline'x'}) }
}

Pour n'importe quel environnement \env, nous prouvons que :

\comp{$\Zinit$\underline{\lstinline'x = v;'}}{\env}
= \env[\lstinline'x' $\mapsto$ \eval{\lstinline'v'}{\env}].

Cette évaluation ne produit pas d'erreur.


\begin{proof}
  ~\\
  \begin{tabular}{rclr}
    \comp{$\Zinit$\underline{\lstinline'x = v;'}}{\env}
    &$\eq{\eqlabel{C-Z-set}}$&
    \env[\lstinline'x' $\mapsto$ \eval{\lstinline'v'}{\env}] \\
  \end{tabular}
\end{proof}


\section{Preuve de la Traduction des Prédicats}
\label{sec:predicate-translation}


Afin de prouver la correction de la traduction des annotations,
nous devons prouver la correction de la traduction des prédicats.
Le lemme~\ref{lem:pred-correct} énonce que l'évaluation des insertions de code
$I$ générées lors de la traduction d'un prédicat \lstinline'p' ajoute une
nouvelle variable \lstinline'e' (fraîche) à l'environnement \env, dont la valeur
correspond à l'évaluation de \lstinline'p' dans \env.
Cette propriété doit être prouvée sur chaque prédicat de la grammaire définie
au chapitre précédent.
Pour des raisons de lisibilité, la preuve de cette propriété est uniquement
fournie pour les règles \textsc{$\pi$-and} et \textsc{$\pi$-forall} (en annexe).


\begin{lemma}\label{lem:pred-correct}
  Soit \lstinline'p' un prédicat qui se traduit en $(I, \mbox{\lstinline'e'})$.
  La traduction est correcte si et seulement si, pour n'importe quel
  environnement \env :

  \comp{$I$}{\env} = \env[\lstinline'e' $\mapsto$ \eval{\lstinline'p'}{\env}].
\end{lemma}


\subsection{Preuve de la Traduction des Conjonctions}

{\myinference[$\pi$-and]
  { (l, \mbox{\lstinline'p1'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
    (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'}) }
  { (l, \mbox{\lstinline'p1 && p2'}) \rulearrow
    (I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
    (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
    (l, \mbox{\lstinline'e = e2;'}) \bclose ),
    \mbox{\lstinline'e'})
  }
}~\\

Pour n'importe quel environnement \env, nous prouvons que :

\comp{$I$}{\env} =
\env[\lstinline'e' $\mapsto$ \eval{\lstinline'p1 && p2'}{\env}].


\begin{proof}
  ~\\
  Hypothèses : $p_1$ et $p_2$ sont correctement instrumentés.
  Pour tout environnement \env :

  \begin{tabular}{rclr}
    \comp{$I_1$}{\env} & = &
    \env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env}] & \eqlabel{h1} \\
    \comp{$I_2$}{\env} & = &
    \env[\lstinline'e2' $\mapsto$ \eval{\lstinline'p2'}{\env}] & \eqlabel{h2} \\
  \end{tabular}

  Développons le membre gauche :
  
  \begin{tabular}{rcl}
    \multicolumn{3}{l}{\comp{$I$}{\env}} \\
    & = & \comp{
      $I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
      (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
      (l, \mbox{\lstinline'e = e2;'}) \bclose )$
    }{\env} \\
    & = & \comp{
      $\mbox{\lstinline'if(e)'} \bopen I_2 \concat
      (l, \mbox{\lstinline'e = e_2;'}) \bclose$
    }{
      (\comp{\lstinline'int e = e1;'}{(\comp{$I_1$}{\env})
      })
    } \\
    & $\eq{\eqlabel{h1}}$ & \comp{
      $\mbox{\lstinline'if(e)'} \bopen I_2 \concat
      (l, \mbox{\lstinline'e = e_2;'}) \bclose$
    }{
      (\comp{\lstinline'int e = e1;'}{
        (\env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env}])
      })
    } \\
    & $\eq{\eqlabel{C-set}}$ & \comp{
      $\mbox{\lstinline'if(e)'} \bopen I_2 \concat
      (l, \mbox{\lstinline'e = e_2;'}) \bclose$
    }{
      (\env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
        \lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}])
    } \\

    %% cas true
    \multicolumn{3}{l}{
      Cas où la valeur de l'expression de la conditionnelle est vraie :} \\
    \multicolumn{3}{l}{
      Nouvelle hypothèse : \eval{\lstinline'p1'}{\env} = \textit{true}
      ~~\eqlabel{h3}
    } \\
    \multicolumn{3}{l}{
      Car
      \eval{\lstinline'e'}{(
        \env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
          \lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
        )} = \textit{true}} \\
    & $\eq{\eqlabel{C-if}}$ & \comp{
      $\bopen I_2 \concat
      (l, \mbox{\lstinline'e = e_2;'}) \bclose$
    }{
      (\env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
        \lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}])
    } \\
    & $\eq{\eqlabel{C-block}}$ & \comp{
      $I_2 \concat (l, \mbox{\lstinline'e = e_2;'})$
    }{
      (\env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
        \lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}])
    } \\
    & = & \comp{
      $(l, \mbox{\lstinline'e = e_2;'})$
    }{
      (\comp{$I_2$}{(\env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
          \lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}])})
    } \\
    & $\eq{\eqlabel{h2}}$ & \comp{
      $(l, \mbox{\lstinline'e = e_2;'})$
    }{
      (\env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
        \lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env},
        \lstinline'e2' $\mapsto$ \eval{\lstinline'p2'}{\env}])
    } \\
    & $\eq{\eqlabel{C-set}}$
    & \env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
      \lstinline'e2' $\mapsto$ \eval{\lstinline'p2'}{\env},
      \lstinline'e' $\mapsto$ \eval{\lstinline'p2'}{\env}] \\
    & = & \env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
      \lstinline'e2' $\mapsto$ \eval{\lstinline'p2'}{\env},
      \lstinline'e' $\mapsto$
      \textit{true} $\land$ \eval{\lstinline'p2'}{\env}] \\
    & $\eq{\eqlabel{h3}}$
    & \env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
      \lstinline'e2' $\mapsto$ \eval{\lstinline'p2'}{\env},
      \lstinline'e' $\mapsto$
      \eval{\lstinline'p1'}{\env} $\land$ \eval{\lstinline'p2'}{\env}] \\
    & $\eq{\eqlabel{P-and}}$
    & \env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
      \lstinline'e2' $\mapsto$ \eval{\lstinline'p2'}{\env},
      \lstinline'e' $\mapsto$ \eval{\lstinline'p1 \&\& p2'}{\env}] \\

    %% cas false
    \multicolumn{3}{l}{
      Cas où la valeur de l'expression de la conditionnelle est fausse :} \\
    \multicolumn{3}{l}{
      Nouvelle hypothèse : \eval{\lstinline'p1'}{\env} = \textit{false}
      ~~\eqlabel{h4}
    }\\
    \multicolumn{3}{l}{
      Car \eval{\lstinline'e'}{(
        \env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
          \lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
        )} = \textit{false}}\\
    & $\eq{\eqlabel{C-if}}$
    & \env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
      \lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}] \\
    & $\eq{\eqlabel{h4}}$
    & \env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
      \lstinline'e' $\mapsto$
      \eval{\lstinline'p1'}{\env} $\land$ \eval{\lstinline'p2'}{\env}] \\
    & $\eq{\eqlabel{P-and}}$
    & \env[\lstinline'e1' $\mapsto$ \eval{\lstinline'p1'}{\env},
      \lstinline'e' $\mapsto$
      \eval{\lstinline'p1 \&\& p2'}{\env}] \\
  \end{tabular}

  Nous avons donc prouvé que
  \comp{$I$}{\env} = \env[\lstinline'e' $\mapsto$
    \eval{\lstinline'p1 \&\& p2'}{\env}].~\\
\end{proof}





\section{Preuve de la Traduction des Annotations}
\label{sec:annotation-translation}


\subsection{Assertions}


{\scriptsize
  {\myinference[$\alpha$-assert]
    {(l, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
    {(l, \mbox{\lstinline'assert p;'})
      \rulearrow I \concat (l, \mbox{\lstinline'fassert(e);'})}
  }
}


Pour n'importe quel environnement \env, nous prouvons que :

\comp{\lstinline'/*@ assert p; */ ;'}{\env} = erreur
$\equiv$ \comp{$I \concat$ \lstinline'fassert(e);'}{\env} = erreur


\begin{proof}
  ~\\
  On sait que \eval{e}{\comp{$I$}{\env}} = \eval{p}{\env} par hypothèse que
  la traduction des prédicats est correcte.

  Cas \eval{p}{\env} = \textit{true} :

  \comp{\lstinline'/*@ assert p; */ ;'}{\env} = \env
  donc \comp{\lstinline'/*@ assert p; */ ;'}{\env} $\not \equiv$ erreur

  \comp{$I \concat$ \lstinline'fassert(e);'}{\env}
  = \comp{\lstinline'fassert(e);'}{\comp{$I$}{\env}}
  = \comp{$I$}{\env}.

  \commentGP{Prouver que \comp{$I$}{\env} ne génère pas d'erreur.}

  Cas \eval{p}{\env} = \textit{false} :

  \comp{\lstinline'/*@ assert p; */ ;'}{\env} = erreur

  \comp{$I \concat$ \lstinline'fassert(e);'}{\env}
  = \comp{\lstinline'fassert(e);'}{\comp{$I$}{\env}}
  = erreur.

  On a donc bien :

  \comp{\lstinline'/*@ assert p; */ ;'}{\env} = erreur
  $\equiv$ \comp{$I \concat$ \lstinline'fassert(e);'}{\env} = erreur.
\end{proof}


\subsection{Vérification des contrats de boucles}


{\scriptsize
  {\myinference[$\alpha$-check-loop-assigns]
    {(l, \mbox{\lstinline'x'}) \rulearrow (I, \mbox{\lstinline'e'})}
    {
      \splitfrac {
        (l, \mbox{\lstinline'loop assigns X;'}) \rulearrow
      } {
        I \concat
        \forall (x:ctype) \in G-X:
        (BegIter_l, \mbox{\lstinline'ctype assigns_x = e;'})
        \concat (EndIter_l, \mbox{\lstinline'fassert(e == assigns_x);'})
      }
    }
  }
}

{\scriptsize
  {\myinference[$\alpha$-check-invariant]
    {(l, \mbox{\lstinline'p'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
      (EndIter_l, \mbox{\lstinline'p'}) \rulearrow (I_2, \mbox{\lstinline'e2'})}
    {
      (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
      I_1 \concat (l, \mbox{\lstinline'fassert(e1);'})
      \concat I_2 \concat (EndIter_l, \mbox{\lstinline'fassert(e2);'})
    }
  }
}

{\scriptsize
  {\myinference[$\alpha$-variant]
    {
      (BegIter_l, \mbox{\lstinline't'}) \rulearrow (I_1, \mbox{\lstinline'e1'})
      \\
      (EndIter_l, \mbox{\lstinline't'}) \rulearrow (I_2, \mbox{\lstinline'e2'})
    }
    {
      \splitfrac
          {
            (l, \mbox{\lstinline'loop variant t;'}) \rulearrow
          }
          {
            I_1 \concat ((BegIter_l,
            \mbox{\lstinline'fassert('}
            \underline{\mbox{\lstinline'0 <= e1'}}
            \mbox{\lstinline');' }
            \underline{\Zinit \mbox{\lstinline'old_variant = e1'} \Zclear}
            \semicolon)
            \concat I_2
            \concat(EndIter_l,
            \mbox{\lstinline'fassert('}
            \underline{\mbox{\lstinline'e2'}\Zclear
              \mbox{\lstinline'< old_variant'} \Zclear}
            \mbox{\lstinline');'})
          }
    }
  }
}


\subsection{Vérification des contrats de fonctions}















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\commentGP{à mettre en annexe ?}
\section{Annexe : Preuve de la Traduction des Quantifications Universelles}

{\myinference[$\pi$-forall]
  {
    (l, \mbox{\lstinline't1'} : \mathbb{Z}) \rulearrow
    (I_1, \mbox{\lstinline'e1'}) \\
    (l, \mbox{\lstinline't2'} : \mathbb{Z}) \rulearrow
    (I_2, \mbox{\lstinline'e2'}) \\
    (l, \mbox{\lstinline'p'}) \rulearrow (I_3, \mbox{\lstinline'e3'})
  }
  {
    \splitfrac {
      (l, \mbox{\lstinline'\\forall integer k; t1 <= k <= t2 ==> p'})
      \rulearrow
    } {
      \splitfrac {
        (I_1 \cdot I_2
        \cdot (l, \mbox{\lstinline'int e = 1;'})
        \cdot
          (l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} )
      } {
        \cdot
          (l, \mbox{\lstinline'while('}
          \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
          \bopen
          I_3
          \cdot (l, \mbox{\lstinline'e = e3;'})
          \cdot (l, \underline{\mbox{\lstinline'k++'}} \semicolon)
          \bclose )
        \cdot
          (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon )
        \cdot
          (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon )
        \cdot
          (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon ),
        \mbox{\lstinline'e'})
      }
    }
  }
}~\\


Pour n'importe quel environnement \env, nous prouvons que :

\comp{$I$}{\env} =
\env[\lstinline'e' $\mapsto$
  \eval{\lstinline'\\forall integer k; t1 <= k <= t2 ==> p'}{\env}].


\begin{proof}
  ~\\
  Hypothèses : \lstinline't1', \lstinline't2' et \lstinline'p' sont correctement
  instrumentés.
  Pour tout environnement \env :

  \begin{tabular}{rclr}
    \comp{$I_1$}{\env}
    & = & \env[$e_1 \mapsto$ \eval{$t_1$}{\env}] & \eqlabel{h1} \\
    \comp{$I_2$}{\env}
    & = & \env[$e_2 \mapsto$ \eval{$t_2$}{\env}] & \eqlabel{h2} \\
    \comp{$I_3$}{\env}
    & = & \env[$e_3 \mapsto$ \eval{$p$}{\env}] & \eqlabel{h3} \\
  \end{tabular}

  Développons le membre gauche :
  
  \begin{tabular}{p{.5cm} p{.5cm} p{11.5cm}}
    \multicolumn{3}{l}{\comp{$I$}{\env}} \\
    & = &
    \comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              (\comp{$\mbox{\lstinline'int e = 1;'}$}{
                (\comp{$I_2$}{(\comp{$I_1$}{\env})})
              })
            })
          })
        })
      })
    } \\
    & = &
    \comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              (\comp{$\mbox{\lstinline'int e = 1;'}$}{
                (\comp{$I_2$}{(\env[$e_1 \mapsto$ \eval{$t_1$}{\env}])})
              })
            })
          })
        })
      })
    } \\
    & = &
    \comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              (\comp{$\mbox{\lstinline'int e = 1;'}$}{
                (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
                  $e_2 \mapsto$ \eval{$t_2$}{\env}])
              })
            })
          })
        })
      })
    } \\
    & = &
    \comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
                $e_2 \mapsto$ \eval{$t_2$}{\env},
                $e \mapsto$ 1])
            })
          })
        })
      })
    } \\
    & = &
    \comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
              $e_2 \mapsto$ \eval{$t_2$}{\env},
              $e \mapsto$ 1,
              $k \mapsto$ \eval{$t_1$}{\env}])
          })
        })
      })
    } \\
  \end{tabular}

  Cas \eval{$t_1$}{\env} $>$ \eval{$t_2$}{\env} (hypothèse \eqlabel{h4}) :

  \begin{tabular}{p{.5cm} p{.5cm} p{11.5cm}}
    &=& \comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
            $e_2 \mapsto$ \eval{$t_2$}{\env},
            $e \mapsto$ 1,
            $k \mapsto$ \eval{$t_1$}{\env}])
        })
      })
    } \\
    &=& \comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\env[\lstinline't1' $\mapsto$ \eval{\lstinline't1'}{\env},
          \lstinline't2' $\mapsto$ \eval{\lstinline't2'}{\env},
          \lstinline'e' $\mapsto$ 1])
      })
    } \\
    &=& \comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\env[\lstinline'e2' $\mapsto$ \eval{\lstinline't2'}{\env},
        \lstinline'e' $\mapsto$ 1])
    } \\
    &=& \env[\lstinline'e' $\mapsto$ 1] \\
    &=& \env[\lstinline'e' $\mapsto$
      \lstinline'\forall integer k; \false ==> p'] \\
    &$\eq{\eqlabel{h4}}$& \env[\lstinline'e' $\mapsto$
      \lstinline'\forall integer k; t1 <= k <= t2 ==> p'] \\
  \end{tabular}

  Cas \eval{$t_1$}{\env} $\le$ \eval{$t_2$}{\env} (hypothèse \eqlabel{h5}) :

  Pour calculer le nouvel environnement résultant de l'exécution de la boucle
  nous aurons besoin de deux invariants de boucle :

  \begin{tabular}{rclr}
    \multicolumn{3}{c}{
      \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} + 1
    }
    & \eqlabel{inv-1} \\
    \eval{\lstinline'e'}{\env} &=&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}
    & \eqlabel{inv-2} \\
  \end{tabular}

  Montrons que \eqlabel{inv-1} et \eqlabel{inv-2} sont vrais pour tout
  environnement \env.
  Montrons tout d'abord que ces invariants sont établis avant la première
  itération.

  Développons
  \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} + 1 :

  \begin{tabular}{rcl}
    \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} + 1
    &=& \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env}
    $\le$ \eval{$t_2$}{\env} + 1 \\
    &=& \eval{$t_1$}{\env} $\le$ \eval{$t_2$}{\env} + 1 \\
    &$\eq{h5}$& \textit{true} \\
  \end{tabular}

  Développons le membre droit de

  \eval{$e$}{\env} =
  \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env} :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}
    } \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= k-1 ==> p'}{\env} \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= t_1-1 ==> p'}{\env} \\
    &=& \eval{\lstinline'\\forall integer z; \\false ==> p'}{\env} \\
    &=& \eval{\lstinline'\\true'}{\env} \\
    &=& 1 \\
    &=& \eval{$e$}{\env} \\
  \end{tabular}

  Ces deux invariants sont établis avant la première itération, montrons qu'ils
  sont maintenus après chaque itération.
  On suppose donc que ces invariants sont vrais après une itération quelconque
  et sont donc des hypothèses.
  Soit \env l'environnement au début de l'itération.

  Prouvons que le premier invariant est maintenu après chaque itération :

  On a : \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} + 1
  
  Ce qui peut être réécrit en :
  \eval{$t_1 \le k \le t_2 + 1$}{\env} = \textit{true}

  Montrons :

  \eval{$t_1 \le k \le t_2 + 1$}{\comp{
      $I_3 \cdot \mbox{\lstinline'e = e_3;'}
      \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
    }{
      (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
    }} = \textit{true}

  Développons le membre gauche :

  \begin{tabular}{p{6cm} p{.5cm} p{9cm}}
    \eval{$t_1 \le k \le t_2 + 1$}{\comp{
      $I_3 \cdot \mbox{\lstinline'e = e_3;'}
      \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
    }{
      (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
    }}
    &=&
    \eval{$t_1 \le k \le t_2 + 1$}{
      \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
        $e \mapsto$ \eval{\lstinline'p'}{\env},
        $k \mapsto$ (\eval{\lstinline'k'}{\env})+1]
    } \\
    &=&
    \eval{$t_1 \le k+1 \le t_2 + 1$}{
      \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
        $e \mapsto$ \eval{\lstinline'p'}{\env},
        $k \mapsto$ (\eval{\lstinline'k'}{\env})]
    } \\
    &=& \eval{$t_1 \le k+1 \le t_2 + 1$}{\env} \\
    &=& \eval{$t_1 \le k+1$}{\env} $\land$ \eval{$k+1 \le t_2 + 1$}{\env} \\
    &=& \eval{$t_1 \le k+1$}{\env} $\land$ \eval{$k \le t_2$}{\env} \\
    &=& \textit{true} $\land$ \eval{$k \le t_2$}{\env} \\
    \multicolumn{3}{c}{par hypothèse de récurrence} \\
    &=& \eval{$k \le t_2$}{\env} \\
    &=& \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} \\
    &=& \eval{$k$}{\env} $\le$ \eval{$e_2$}{\env} \\
    &=& \eval{$k \le e_2$}{\env} \\
    &=& \textit{true} \\
    \multicolumn{3}{c}{la condition de boucle est vraie sinon on n'exécuterait
      pas le code de la boucle} \\
  \end{tabular}
  
  Le premier invariant est donc maintenu après chaque itération.
  Prouvons maintenant que le deuxième invariant est maintenu après chaque
  itération.
  Développons le membre gauche :

  \begin{tabular}{p{6cm} p{.5cm} p{9cm}}
    (\comp{
      $I_3 \cdot \mbox{\lstinline'e = e_3;'}
      \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
    }{
      (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
    })(e)
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      \comp{\lstinline'e = e_3;'}{(
        \comp{$I_3$}{(
          \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
            $e_2 \mapsto$ \eval{$t_2$}{\env},
            $e \mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}]
          )}
        )}
      )}
    )(e) \\
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      \comp{\lstinline'e = e_3;'}{(
        \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
          $e_2 \mapsto$ \eval{$t_2$}{\env},
          $e \mapsto$
          \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env},
          $e_3 \mapsto$ \eval{\lstinline'p'}{\env}]
        )}
      )}
    )(e) \\
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
        $e \mapsto$ \eval{\lstinline'p'}{\env}]
      )}
    )(e) \\
    &=&
    (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
      $e_2 \mapsto$ \eval{$t_2$}{\env},
      $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
      $e \mapsto$ \eval{\lstinline'p'}{\env},
      $k \mapsto$ (\eval{\lstinline'k'}{\env})+1]
    )(e) \\
    &=& \eval{\lstinline'p'}{\env} \\
    &=& \eval{\lstinline'e'}{\env} $\land$ \eval{\lstinline'p'}{\env} \\
    \multicolumn{3}{c}{\eval{\lstinline'e'}{\env} est vrai sinon on
      n'exécuterait pas le code de la boucle} \\
  \end{tabular}

  Développons le membre droit :

  \begin{tabular}{p{5cm} p{.5cm} p{9cm}}
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{
      (\comp{
        $I_3 \cdot \mbox{\lstinline'e = e_3;'}
        \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
      }{
        (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
          $e_2 \mapsto$ \eval{$t_2$}{\env},
          $e \mapsto$
          \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
      })
    }
    &=&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{
      (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
        $e \mapsto$ \eval{\lstinline'p'}{\env},
        $k \mapsto$ (\eval{\lstinline'k'}{\env})+1])
    } \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z < k+1 ==> p'}{\env} \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= k ==> p'}{\env} \\
    &=&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env} \newline
    $\land$ \eval{\lstinline'\\forall integer z; z == k ==> p'}{\env} \\
    &=&
    \eval{\lstinline'e'}{\env}
    $\land$ \eval{\lstinline'\\forall integer z; z == k ==> p'}{\env} \\
    &=& \eval{\lstinline'e'}{\env} $\land$ \eval{\lstinline'p'}{\env} \\
    \multicolumn{3}{c}{car \eval{\lstinline'p'}{\env} est la valeur de $p$ pour
    le $k$ courant} \\
  \end{tabular}

  Le deuxième invariant est donc lui aussi maintenu après chaque itération.

  Maintenant que les deux invariants ont été prouvés, reprenons notre preuve :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\comp{$I$}{\env}}
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
              $e_2 \mapsto$ \eval{$t_2$}{\env},
              $e \mapsto$ 1,
              $k \mapsto$ \eval{$t_1$}{\env}])
          })
        })
      })
    })(e) \\
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
            $e_2 \mapsto$ \eval{$t_2$}{\env},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
        })
      })
    })(e) \\
  \end{tabular}

  Notons \env$'$ = \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
    $e_2 \mapsto$ \eval{$t_2$}{\env},
    $e\mapsto$
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}].

  Rappelons que
  \eval{$t_1$}{\env$'$} $\le$ \eval{$k$}{\env$'$} $\le$ \eval{$t_2$}{\env$'$} + 1
  (premier invariant de boucle).

  On sait que la condition de boucle est fausse dans cet environnement \env$'$ :

  \eval{\lstinline'k <= e_2 && e'}{\env$'$} = \textit{false}

  Cas \eval{$k \le e_2$}{\env$'$} = \textit{false}, soit
  \eval{$k > t_2$}{\env$'$} = \textit{true} :
  
  On sait que \eval{$k > t_2$}{\env$'$} et \eval{$k \le t_2+1$}{\env$'$}, donc on
  a \eval{k}{\env$'$} = \eval{$t_2+1$}{\env$'$}.
  Avec cette nouvelle connaissance, on a :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\comp{$I$}{\env}}
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
            $e_2 \mapsto$ \eval{$t_2$}{\env},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
        })
      })
    })(e) \\
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
            $e_2 \mapsto$ \eval{$t_2$}{\env},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < t_2+1 ==> p'}{\env},
            $k \mapsto$ \eval{$t_2+1$}{\env}])
        })
      })
    })(e) \\
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
            $e_2 \mapsto$ \eval{$t_2$}{\env},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{\env},
            $k \mapsto$ \eval{$t_2+1$}{\env}])
        })
      })
    })(e) \\
    &=&
    (\env[$e\mapsto$
      \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{\env},
      $k \mapsto \bot$,
      $e_1 \mapsto \bot$,
      $e_2 \mapsto \bot$]) (e) \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{\env} \\
  \end{tabular}

  Cas \eval{$e$}{\env$'$} = \textit{false} :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{$e$}{\env$'$} = \textit{false}
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env$'$}
    = \textit{false} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z < t_2+1 ==> p'}{\env$'$}
    = \textit{false} \\
    \multicolumn{3}{c}{car \eval{$k$}{\env$'$} $\le$ \eval{$t_2+1$}{\env$'$}} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{\env$'$}
    = \textit{false} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{\env}
    = \textit{false} \\
    \multicolumn{3}{c}{
      car (\eval{$t_1$}{\env}) = (\eval{$t_1$}{\env$'$}) et
      (\eval{$t_2$}{\env}) = (\eval{$t_2$}{\env$'$})
    } \\
  \end{tabular}

  Donc on a :
  \eval{$e$}{\env$'$} $\equiv$
  \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{\env}.

  Reprenons la preuve principale dans le cas
  \eval{$e$}{\env$'$} = \textit{false} :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\comp{$I$}{\env}}
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
            $e_2 \mapsto$ \eval{$t_2$}{\env},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{\env}])
        })
      })
    })(e) \\
    &=&
    (\env[\eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{\env},
      $k \mapsto \bot$,
      $e_1 \mapsto \bot$,
      $e_2 \mapsto \bot$]) (e) \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{\env} \\
  \end{tabular}

  On a bien réussi à prouver que pour tout environnement \env :

  \eval{\lstinline'e'}{\comp{$I$}{\env}}
  = \eval{\lstinline'\\forall integer k; t_1 <= k <= t_2 ==> p'}{\env}
\end{proof}
