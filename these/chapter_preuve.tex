
\chapter{Preuve de correction}
\label{sec:preuve-correction}

\chapterintro

L'objectif du chapitre est de prouver certaines propriétés de correction sur
les règles de traduction présentées dans le chapitre~\ref{sec:traduction}.

Nous voulons notamment nous assurer qu'une erreur est trouvée par le
générateur de tests si et seulement si il y a une inconsistance entre le code
et sa spécification.

La sémantique des annotations, des termes et des prédicats de
\eacsl \cite{\citeeacsl} est présentée en partie~\ref{sec:definitions}.
Les propriétés que nous vérifions sont définies en partie~\ref{sec:properties}.
Les parties~\ref{sec:term-translation}, \ref{sec:predicate-translation} et
\ref{sec:annotation-translation} détaillent la preuve de ces propriétés
respectivement sur les termes, sur les prédicats et sur les annotations.


\section{Définitions}
\label{sec:definitions}


Nous définissons les fonctions et symboles qui sont utilisés dans la suite du
chapitre.

\begin{notation}
  ~
  \begin{itemize}
  \item $x$, $y$ et $z$ sont des identificateurs de variable
  \item $v$ est une valeur
  %\item $\bot$ est une valeur spéciale qui signifie qu'une variable n'est pas
  %  ou plus initialisée (après un \lstinline'free' ou une désallocation GMP).
  \item $i$, $i_1$, $i_2$ sont des instructions
  \item $A$, $B$ sont des blocs d'instructions
  \item $e$, $e_1$, $e_2$ sont des expressions C
  \item $t$, $t_1$, $t_2$ sont des termes ($\in TERM$)
  \item $p$, $p_1$, $p_2$ sont des prédicats ($\in PRED$)
  \item $P$ est un programme C annoté et $P'$ est le programme instrumenté
    obtenu après traduction du programme $P$
  \end{itemize}
\end{notation}


\subsection{Environnements}

Un environnement \env est une fonction partielle \env $: ID \mapsto VAL$ des
identificateurs de variables dans le domaine sémantique des valeurs
possibles.

Le domaine des valeurs est défini comme l'union des types logiques que peuvent
prendre les termes et prédicats \eacsl :
$VAL = \mathbb{B}~\cup~\mathbb{Z}~\cup~\mathbb{R}$

La notation \env[$x \mapsto v$] est désigne un nouvel environnement,
correspondant à l'environnement \env auquel la relation $(x, v)$ a été ajoutée,
ce qui signifie qu'on remplace l'ancienne valeur de $x$ par $v$.

L'accès à la valeur d'une variable dans un environnement est défini par :

\begin{tabular}{rclr}
  (\env[$x \mapsto v$])($x$) & = & $v$ & \eqlabel{env-1} \\
  (\env[$x \mapsto v$])($y$) & = & \env($y$) si $x \neq y$ & \eqlabel{env-2}\\
\end{tabular}

Dans la suite, nous utiliserons la notation
\env[$x \mapsto v_1, y \mapsto v_2$] (en supposant que $x \not = y$) comme un
raccourci pour \env[$x \mapsto v_1$][$y \mapsto v_2$].

La notation \env $-~\{\mbox{\lstinline'x'}\}$ signifie que la left-value
\lstinline'x' et sa valeur sont enlevées de l'environnement \env :

\begin{tabular}{rcl}
  (\env[$x \mapsto v$])$-~\{\mbox{\lstinline'a'}\}$
  &=& (\env$-~\{\mbox{\lstinline'a'}\}$)[$x \mapsto v$] si $x \neq a$ \\
  (\env[$a \mapsto v$])$-~\{\mbox{\lstinline'a'}\}$ &=& \env \\
\end{tabular}

Nous définissons également une relation d'inclusion sur les ensembles,
c'est-à-dire \env$_1$ est inclus dans \env$_2$ si et seulement si
chaque affectation $(x, v)$ présente dans l'environnement \env$_1$ est
également présente dans \env$_2$ :

\env$_1$ $\subset$ \env$_2$ $\equiv$
$\forall (x, v). (x \mapsto v) \in \mbox{\env}_1 \Rightarrow (x \mapsto v) \in \mbox{\env}_2$

Nous définissons un ``environnement d'erreur'', noté \errorenv.
Un tel environnement est le résultat de l'évaluation d'une instruction
provoquant une erreur (par exemple un appel à \lstinline'fassert' sur une
expression fausse) ou d'une instruction dont les annotations ne sont pas
respectées (par exemple, \lstinline'assert' ou \lstinline'loop invariant' faux).
L'évaluation des instructions s'arrête dès qu'un environnement d'erreur est
produit.


\subsection{Sémantique Dénotationnelle des Termes, Prédicats et Expressions}

La sémantique dénotationnelle des expressions C et des termes et prédicats
\eacsl est exprimée avec la fonction
$\mathcal{E} : (EXP \cup TERM \cup PRED) \mapsto ENV \mapsto VAL$.
Cette fonction associe à une expression C (ou un terme ou prédicat \eacsl) dans
un environnement une valeur, à condition que cette expression ne génère pas
d'effet de bord, hypothèse satisfaite par le langage considéré après
normalisation du code par \framac.
%Une expression C \underline{soulignée} utilise la sémantique des entiers non
%bornés.

La sémantique des expressions C et des termes \eacsl est donnée en
figure~\ref{fig:sem-exp}.
La sémantique des prédicats \eacsl est donnée en figure~\ref{fig:sem-pred}.

\begin{figure}[bt]
  \begin{tabular}{rclr}
    \eval{cst}{\env} &=& cst & \eqlabel{E-cst} \\
    \eval{lvalue}{\env} &=& \env(lvalue) si $lvalue$ est une variable
    & \eqlabel{E-lval} \\
    \eval{\lstinline|unop t|}{\env}
    &=& \lstinline|unop| (\eval{\lstinline|t|}{\env}) & \eqlabel{E-unop} \\
    \eval{\lstinline|t1 binop t2|}{\env}
    &=& (\eval{\lstinline|t1|}{\env}) \lstinline|binop|
    (\eval{\lstinline|t2|}{\env}) & \eqlabel{E-binop} \\
    \eval{\lstinline'\\abs(t)'}{\env} &=&
    $\lvert$ \eval{\lstinline't'}{\env} $\rvert$ & \eqlabel{E-abs} \\
    \eval{\lstinline'\\sum(t1, t2, \\lambda integer k; t3)'}{\env} &=&
    $\sum_{k = \mbox{\eval{\lstinline't1'}{\env}}}^{\mbox{\eval{\lstinline't2'}{\env}}} \mbox{\eval{\lstinline't3'}{\env}}$
    & \eqlabel{E-sum} \\
    \eval{\lstinline'\\product(t1, t2, \\lambda integer k; t3)'}{\env} &=&
    $\prod_{k = \mbox{\eval{\lstinline't1'}{\env}}}^{\mbox{\eval{\lstinline't2'}{\env}}} \mbox{\eval{\lstinline't3'}{\env}}$
    & \eqlabel{E-prod} \\
    \eval{\lstinline'\\numof(t1, t2, \\lambda integer k; t3)'}{\env} &=&
    $\sum_{k = \mbox{\eval{\lstinline't1'}{\env}}}^{\mbox{\eval{\lstinline't2'}{\env}}} \mbox{\eval{\lstinline't3 ? 1 : 0'}{\env}}$
    & \eqlabel{E-num} \\
    \eval{\lstinline't1 ? t2 : t3'}{\env} &=& \eval{\lstinline't2'}{\env}
    si (\eval{\lstinline't1'}{\env}) $\neq$ 0, \eval{\lstinline't3'}{\env} sinon
    & \eqlabel{E-tif} \\
    \eval{\lstinline'\\old(t)'}{\env} &=&
    \eval{\lstinline't'}{(\env en début de fonction)}
    & \eqlabel{E-old} \\
    \eval{\lstinline'\\null'}{\env} &=& \lstinline'NULL' & \eqlabel{E-null} \\
    \eval{\lstinline|(type) t|}{\env}
    &=& \lstinline|(type)| (\eval{\lstinline|t|}{\env}) & \eqlabel{E-cast} \\
  \end{tabular}
  \caption{Sémantique dénotationnelle des termes et expressions}
  \label{fig:sem-exp}
\end{figure}


\begin{figure}[bt]
  \begin{tabular}{rclr}
    \eval{\lstinline'\\true'}{\env} &=& \textit{true} & \eqlabel{P-true} \\
    \eval{\lstinline'\\false'}{\env} &=& \textit{false} & \eqlabel{P-false} \\
    \eval{\lstinline'\\valid(t)'}{\env} &=& \textit{true} si \lstinline'*t' est
    défini dans \env, \textit{false} sinon & \eqlabel{P-valid} \\
    \eval{\lstinline'\\forall integer k; t1 <= k <= t2 ==> p'}{\env} &=&
    $\forall k.$ \eval{\lstinline't1'}{\env} $\le$ $k$ $\le$
    \eval{\lstinline't2'}{\env} $\Rightarrow$ \eval{\lstinline'p'}{\env}
    & \eqlabel{P-forall} \\
    \eval{\lstinline'\\exists integer k; t1 <= k <= t2 \&\& p'}{\env} &=&
    $\exists k.$ \eval{\lstinline't1'}{\env} $\le$ $k$ $\le$
    \eval{\lstinline't2'}{\env} $\land$ \eval{\lstinline'p'}{\env}
    & \eqlabel{P-exists} \\
    \eval{\lstinline'\! p'}{\env} &=& $\lnot$ (\eval{\lstinline'p'}{\env})
    & \eqlabel{P-not} \\
    \eval{\lstinline'p1 \&\& p2'}{\env} &=&
    (\eval{\lstinline'p1'}{\env}) $\land$ (\eval{\lstinline'p2'}{\env})
    & \eqlabel{P-and} \\
    \eval{\lstinline'p1 || p2'}{\env} &=&
    (\eval{\lstinline'p1'}{\env}) $\lor$ (\eval{\lstinline'p2'}{\env})
    & \eqlabel{P-or} \\
    \eval{\lstinline'p1 ==> p2'}{\env} &=&
    (\eval{\lstinline'p1'}{\env}) $\Rightarrow$ (\eval{\lstinline'p2'}{\env})
    & \eqlabel{P-impl} \\
    \eval{\lstinline'p1 <==> p2'}{\env} &=&
    (\eval{\lstinline'p1'}{\env}) $\Leftrightarrow$(\eval{\lstinline'p2'}{\env})
    & \eqlabel{P-eq} \\
    \eval{\lstinline't ? p1 : p2'}{\env} &=& \eval{\lstinline'p1'}{\env}
    si (\eval{\lstinline't'}{\env}) $\neq$ 0, \eval{\lstinline'p2'}{\env} sinon
    & \eqlabel{P-pif} \\
    \eval{\lstinline|t1 rel t2|}{\env}
    &=& (\eval{\lstinline|t1|}{\env}) \lstinline|rel|
    (\eval{\lstinline|t2|}{\env}) & \eqlabel{P-rel} \\
  \end{tabular}
  \caption{Sémantique dénotationnelle des prédicats}
  \label{fig:sem-pred}
\end{figure}


\subsection{Sémantique Dénotationnelle des Instructions}

La sémantique dénotationnelle des instructions C est exprimée avec la fonction
$\mathcal{C} : INSTR \mapsto ENV \mapsto ENV$.
Cette fonction associe à une instruction $i$ et un environnement \env un nouvel
environnement qui prend en compte les modifications effectuées par $i$ dans
l'environnement \env.
Une instruction \underline{soulignée} utilise la sémantique des entiers non
bornés.

La sémantique des instructions C est donnée en figure~\ref{fig:sem-instr}.
Dans la règle \eqlabel{C-Z-set}, la variable entière (GMP) \lstinline'lval' est
allouée et on lui affecte la valeur de \lstinline'e'.
Dans la règle \eqlabel{C-Z-unset}, la variable entière (GMP) \lstinline'lval'
est désallouée et enlevée de l'environnement \env.

\begin{figure}
  \begin{tabular}{p{4.2cm} p{.4cm} p{9cm} p{2cm}}
    \comp{\lstinline'\;'}{\env} &=& \env & \eqlabel{C-skip} \\
    \comp{\lstinline'i1 ; i2'}{\env} &=&
    \comp{\lstinline'i2'}{(\comp{\lstinline'i1'}{\env})}
    & \eqlabel{C-seq} \\
    \comp{$\bopen$ \lstinline'i1 ; i2' $\bclose$}{\env} &=&
    \comp{\lstinline'i2'}{(\comp{\lstinline'i1'}{\env})}
    & \eqlabel{C-block} \\
    \comp{\lstinline|lval = e;|}{\env}
    &=& \env[\lstinline'lval' $\mapsto$ \eval{\lstinline'e'}{\env}]
    \scriptsize{(arith. bornée)}
    & \eqlabel{C-set} \\
    \comp{\lstinline'if(e)' $\bopen A \bclose$
      \lstinline'else' $\bopen B \bclose$}{\env}
    &=& \compi{$A$}{\env} si (\eval{\lstinline'e'}{\env}) $\neq$ 0,
    \compi{$B$}{\env} sinon
    & \eqlabel{C-if} \\
    \comp{\lstinline'/*@ assert p; */'}{\env}
    &=& \env si (\eval{\lstinline'p'}{\env}), \errorenv sinon
    & \eqlabel{C-assert} \\
    \comp{\lstinline'fassert(e);'}{\env}
    &=& \env si (\eval{\lstinline'e'}{\env}) $\neq$ 0, \errorenv sinon
    & \eqlabel{C-fassert} \\
    \comp{\lstinline'fassume(e);'}{\env}
    &=& \env si (\eval{\lstinline'e'}{\env}) $\neq$ 0, contradiction sinon
    & \eqlabel{C-fassume} \\
    \comp{\lstinline|while(e)| $\bopen A \bclose$}{\env}
    &=& \comp{\lstinline|while(e)| $\bopen A \bclose$}{(\compi{$A$}{\env})}
    si \eval{\lstinline'e'}{\env} $\neq$ 0, \env sinon  & \eqlabel{C-while} \\
    \comp{\lstinline'/*@ loop invariant p; loop assigns X; loop variant t; */ while(e)' $\bopen A \bclose$}{\env}
    & = & \errorenv si $\lnot$ \eval{\lstinline'p'}{\env}
    & \eqlabel{C-while-1} \\
    & = & \env si (\eval{\lstinline'e'}{\env}) $=$ 0
    & \eqlabel{C-while-2} \\
    & = & \errorenv si $\lnot$ \eval{\lstinline't >= 0'}{\env}
    & \eqlabel{C-while-3} \\
    & = & \errorenv si $\lnot$ \eval{\lstinline'p'}{(\compi{$A$}{\env})}
    & \eqlabel{C-while-4} \\
    & = & \errorenv si (\eval{\lstinline't'}{(\compi{$A$}{\env})}) $\ge$
    (\eval{\lstinline't'}{\env})
    & \eqlabel{C-while-5} \\
    & = & \errorenv si
    $\exists x. x \in G-X.$ (\eval{\lstinline'x'}{(\compi{$A$}{\env})}) $\ne$
    (\eval{\lstinline'x'}{\env})
    & \eqlabel{C-while-6} \\
    & = & \comp{\lstinline'/*@ ... */ while(e)'
      $\bopen A \bclose$}{(\compi{$A$}{\env})} sinon
    & \eqlabel{C-while-7} \\
    \comp{$\Zinit$ \underline{\lstinline|lval = e|} $\semicolon$}{\env}
    &=& \env[\lstinline'lval' $\mapsto$ \eval{\lstinline'e'}{\env}]
    \scriptsize{(arith. non bornée)}
    & \eqlabel{C-Z-set} \\
    \comp{\underline{\lstinline|lval|} $\Zclear \semicolon$}{\env}
    &=& \env $-~\{\mbox{\lstinline'a'}\}$ & \eqlabel{C-Z-unset} \\
  \end{tabular}
  \caption{Sémantique dénotationnelle des instructions}
  \label{fig:sem-instr}
\end{figure}


\subsection{Définition des séquences d'insertions de code}

Une insertion de code est un couple $(LABEL \times INSTR)$.
Une liste (ou séquence) d'insertions de code résulte de la traduction d'un
terme, prédicat ou d'une annotation \eacsl.
Une séquence est notée :

\begin{itemize}
\item $\emptylist$ pour une séquence vide;
\item $(l, i) \concat I$ pour la concaténation de $(l, i)$ au début de la
  séquence $I$;
\item $I_1 \concat I_2$ pour la concaténation de deux séquences $I_1$ et $I_2$.
\end{itemize}

Par exemple, la règle suivante montre la séquence d'insertions de code $I$
générée pour la traduction du prédicat \lstinline'p1 && p2' :

{\myinference[$\pi$-and]
  { (l, \mbox{\lstinline'p1'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
    (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'}) }
  { (l, \mbox{\lstinline'p1 && p2'}) \rulearrow
    (
    \underbracket{
      I_1 \cdot
      \underbracket{ (l, \mbox{\lstinline'int e = e1;'}) }_{i_1}
      \cdot
      \underbracket{ (l, \mbox{\lstinline'if(e)'}
        \bopen
        I_2 \cdot
        \underbracket{ (l, \mbox{\lstinline'e = e2;'}) }_{i_2}
        \bclose ) }_{i_3} \concat \emptylist
      }_{I},
    \mbox{\lstinline'e'}) }
}~\\

Dans cet exemple, $i_1$, $i_2$ et $i_3$ sont des insertions de code, tandis que
$I_1$, $I_2$ et $I$ sont des séquences d'insertions de code.
\lstinline'e' est une left-value qui a une valeur dans l'environnement courant.


\subsection{Sémantique dénotationnelle des insertions de code}

La sémantique dénotationnelle des insertions de code est exprimée avec la
fonction $\mathcal{I} : list(LABEL * INSTR) \mapsto ENV \mapsto ENV$.
À chaque séquence d'insertions de code C et un environnement est associé un
nouvel environnement.

La fonction $\mathcal{I}$ est définie comme suit :

\begin{tabular}{rclr}
  \compi{$\emptylist$}{\env} & = & \env & \eqlabel{I-empty} \\
  \compi{($l$, $i$) $\concat~\emptylist$}{\env}
  & = & \comp{$i$}{\env$_l$} & \eqlabel{I-instr} \\
  \compi{$I_1 \concat I_2$}{\env} & = & \compi{$I_2$}{(\compi{$I_1$}{\env})}
  & \eqlabel{I-split} \\
\end{tabular}

La règle \eqlabel{I-empty} énonce qu'une séquence vide ne modifie pas
l'environnement.
La règle \eqlabel{I-instr} évalue l'instruction $i$ au label $l$ afin de
calculer le nouvel environnement.
La règle \eqlabel{I-split} traite le cas de la concaténation d'insertions de
code.


\section{Propriétés de l'instrumentation}
\label{sec:properties}


Définissons maintenant les propriétés maintenues par le processus
d'instrumentation des programmes annotés.
Ces propriétés sont prouvées dans les sections suivantes.


\begin{theorem}{Préservation des erreurs}\label{th:error}~\\
  L'exécution des instructions obtenues par traduction d'une annotation $a$ du
  programme $P$ provoque une erreur dans le programme traduit $P'$ si et
  seulement si $a$ est invalide.
\end{theorem}

Le théorème~\ref{th:error} assure l'absence de faux positifs et l'absence de
faux négatifs lors de la génération de tests sur le programme traduit.


\begin{theorem}{Inclusion des environnements}\label{th:inclusion}~\\
  Si toutes les annotations d'un programme $P$ sont valides, l'environnement de
  $P$ est inclus dans l'environnement du programme après traduction $P'$.
\end{theorem}

Le théorème~\ref{th:inclusion} implique que les seules variables modifiées sont
les variables fraîchement créées par l'instrumentation, les variables de
l'environnement du programme d'origine ne sont pas modifiées par
l'instrumentation.


\section{Preuve de la Traduction des Termes}
\label{sec:term-translation}

Afin de prouver la correction de la traduction des prédicats et des annotations,
nous devons prouver la correction de la traduction des termes.

\begin{lemma}
  \label{lem:term-correct}
  Soit \lstinline't' : $\tau$ un terme de type $\tau$, qui se traduit en
  $(I, \mbox{\lstinline'e'})$.
  La traduction est correcte si et seulement si, pour n'importe quel
  environnement \env :
  
  \eval{\lstinline'e'}{(\compi{$I$}{\env})} = \eval{\lstinline't'}{\env}
  
  et
  
  \env $\subset$ \compi{$I$}{\env}

  et

  \compi{$I$}{\env} $\neq$ \errorenv.
\end{lemma}

Le lemme~\ref{lem:term-correct} énonce que l'évaluation des insertions de code
$I$ générées lors de la traduction d'un terme \lstinline't' ajoute une nouvelle
variable \lstinline'e' (fraîche) à l'environnement \env, dont la valeur
correspond à l'évaluation de \lstinline't' dans \env.
Les variables qui sont déjà dans l'environnement initial \env ne sont pas
impactées dans l'environnement \compi{$I$}{\env}, et l'environnement résulant
de la traduction du terme n'est pas l'environnement d'erreur \errorenv.
Ces propriétés sont vérifiées par la traduction de chaque terme.
Elles nous permettent de prouver les deux théorèmes~\ref{th:error}
et~\ref{th:inclusion}.
Pour des raisons de lisibilité, la preuve est uniquement fournie pour la règle
\textsc{$\tau$-const} de traduction des constantes.




\subsection{Preuve de la Traduction des Constantes}

{\myinference[$\tau$-const]
  {}
  { (l, \mbox{\lstinline'v'} : \mathbb{Z}) \rulearrow
    ((l, \Zinit\underline{\mbox{\lstinline'x = v;'}}), \mbox{\lstinline'x'}) }
}

Nous prouvons que pour n'importe quel environnement \env  :

\eval{\lstinline'x'}{
  (\compi{$(l, \Zinit$\underline{\lstinline'x = v;'}$)$}{\env})}
= \eval{\lstinline'v'}{\env}

et

\env $\subset$ \compi{$(l, \Zinit$\underline{\lstinline'x = v;'}$)$}{\env}

et

\compi{$(l, \Zinit$\underline{\lstinline'x = v;'}$)$}{\env} $\neq$ \errorenv.

\begin{proof}
  ~\\
  \begin{tabular}{rclr}
    \compi{$(l, \Zinit$\underline{\lstinline'x = v;'}$)$}{\env}
    &$\eq{\eqlabel{I-instr}}$&
    \comp{$\Zinit$\underline{\lstinline'x = v;'}}{\env} \\
    &$\eq{\eqlabel{C-Z-set}}$&
    \env[\lstinline'x' $\mapsto$ \eval{\lstinline'v'}{\env}] \\
  \end{tabular}

  En substituant \compi{$(l, \Zinit$\underline{\lstinline'x = v;'}$)$}{\env} on
  prouve la première partie du lemme~\ref{lem:term-correct} :
  
  \eval{\lstinline'x'}{
    (\env[\lstinline'x' $\mapsto$ \eval{\lstinline'v'}{\env}])}
  $\eq{\eqlabel{E-lval}}$ \eval{\lstinline'v'}{\env}.

  La variable \lstinline'x' étant fraîche dans l'environnement, la deuxième
  partie du lemme~\ref{lem:term-correct} est également vérifiée :
  \env $\subset$ \env[\lstinline'x' $\mapsto$ \eval{\lstinline'v'}{\env}].

  Le nouvel environnement étant \env auquel on a ajouté une nouvelle liaison
  $(x, v)$, ce n'est pas un environnement d'erreur si \env lui-même n'était pas
  un environnement d'erreur, ce qui prouve la troisième partie du lemme.
  \env ne peut pas être \errorenv puisque la traduction se serait arrêtée dès
  l'obtention de l'erreur.
\end{proof}


\section{Preuve de la Traduction des Prédicats}
\label{sec:predicate-translation}


Afin de prouver la correction de la traduction des annotations,
nous devons prouver la correction de la traduction des prédicats.

\begin{lemma}
  \label{lem:pred-correct}
  Soit \lstinline'p' un prédicat qui se traduit en $(I, \mbox{\lstinline'e'})$.
  La traduction est correcte si et seulement si, pour n'importe quel
  environnement \env :
  
  \eval{\lstinline'e'}{(\compi{$I$}{\env})} = \eval{\lstinline'p'}{\env}
  
  et
  
  \env $\subset$ \compi{$I$}{\env}

  et

  \compi{$I$}{\env} $\neq$ \errorenv.
\end{lemma}

Le lemme~\ref{lem:pred-correct} énonce que l'évaluation des insertions de code
$I$ générées lors de la traduction d'un prédicat \lstinline'p' ajoute une
nouvelle variable \lstinline'e' (fraîche) à l'environnement \env, dont la valeur
correspond à l'évaluation de \lstinline'p' dans \env.
Les variables qui sont déjà dans l'environnement initial \env ne sont pas
impactées dans l'environnement \compi{$I$}{\env} et l'environnement résultant de
la traduciton du prédicat n'est pas l'environnement d'erreur.
Ces propriétés sont vérifiées par la traduction de chaque prédicat.
Elles nous permettent de prouver les deux théorèmes~\ref{th:error}
et~\ref{th:inclusion}.
Pour des raisons de lisibilité, la preuve est uniquement fournie pour les règles
\textsc{$\pi$-and} et \textsc{$\pi$-forall} (en annexe).


\subsection{Preuve de la Traduction des Conjonctions}

{\myinference[$\pi$-and]
  { (l, \mbox{\lstinline'p1'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
    (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'}) }
  { (l, \mbox{\lstinline'p1 && p2'}) \rulearrow
    (I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
    (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
    (l, \mbox{\lstinline'e = e2;'}) \bclose ),
    \mbox{\lstinline'e'})
  }
}~\\

Prouvons que pour n'importe quel environnement \env :

\eval{\lstinline'e'}{(
  \compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
    (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
    (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env}
  )} = \eval{\lstinline'p1 && p2'}{\env}

et

\env $\subset$
\compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
  (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
  (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env}

et

\compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
  (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
  (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env} $\neq$ \errorenv.


\begin{proof}
  ~\\
  Hypothèses : \lstinline'p1' et \lstinline'p2' sont correctement instrumentés.
  Pour tout environnement \env :

  \begin{tabular}{rclr}
    \eval{\lstinline'e1'}{(\compi{$I_1$}{\env})} & = &
    \eval{\lstinline'p1'}{\env} & \eqlabel{h1} \\
    \eval{\lstinline'e2'}{(\compi{$I_2$}{\env})} & = &
    \eval{\lstinline'p2'}{\env} & \eqlabel{h2} \\
    \env & $\subset$ & \compi{$I_1$}{\env} & \eqlabel{h3} \\
    \env & $\subset$ & \compi{$I_2$}{\env} & \eqlabel{h4} \\
    \compi{$I_1$}{\env} & $\neq$ & \errorenv & \eqlabel{h5} \\
    \compi{$I_2$}{\env} & $\neq$ & \errorenv & \eqlabel{h6} \\
  \end{tabular}

  Développons \compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
    (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
    (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env} :
  
  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
        (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
        (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env}} \\
    & $\eq{\eqlabel{I-split}}$ & \compi{
      $(l, \mbox{\lstinline'if(e)'} \bopen I_2 \concat
      (l, \mbox{\lstinline'e = e2;'}) \bclose )$
    }{
      (\compi{$(l, \mbox{\lstinline'int e = e1;'})$}{(\compi{$I_1$}{\env})
      })
    } \\
    & $\eq{\eqlabel{I-instr}}$ & \compi{
      $(l, \mbox{\lstinline'if(e)'} \bopen I_2 \concat
      (l, \mbox{\lstinline'e = e2;'}) \bclose )$
    }{
      (\comp{\lstinline'int e = e1;'}{(\compi{$I_1$}{\env})
      })
    } \\
    & $\eq{\eqlabel{C-set}}$ & \compi{
      $(l, \mbox{\lstinline'if(e)'} \bopen I_2 \concat
      (l, \mbox{\lstinline'e = e2;'}) \bclose )$
    }{
      ((\compi{$I_1$}{\env})
      [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
      )
    } \\
    & $\eq{\eqlabel{I-instr}}$ & \comp{
      $\mbox{\lstinline'if(e)'} \bopen I_2 \concat
      (l, \mbox{\lstinline'e = e2;'}) \bclose$
    }{
      ((\compi{$I_1$}{\env})
      [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
      )
    } \\

    %% cas true
    \multicolumn{3}{l}{
      (1) Cas où la valeur de l'expression de la conditionnelle est vraie :} \\
    \multicolumn{3}{l}{
      Nouvelle hypothèse : \eval{\lstinline'p1'}{\env} = \textit{true}
      ~~\eqlabel{h7}
    } \\
    \multicolumn{3}{l}{
      Car
      \eval{\lstinline'e'}{(
        (\compi{$I_1$}{\env})
        [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
      )} = \textit{true}} \\
    & $\eq{\eqlabel{C-if}}$ & \compi{
      $I_2 \concat (l, \mbox{\lstinline'e = e2;'})$
    }{(
      (\compi{$I_1$}{\env})
      [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
      )} \\
    & $\eq{\eqlabel{I-split}}$ & \compi{
      $(l, \mbox{\lstinline'e = e2;'})$
    }{(\compi{$I_2$}{(
        (\compi{$I_1$}{\env})
        [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
        )}
      )} \\
    & $\eq{\eqlabel{I-instr}}$ & \comp{
      \lstinline'e = e2;'
    }{(\compi{$I_2$}{(
        (\compi{$I_1$}{\env})
        [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
        )}
      )} \\
    & $\eq{\eqlabel{C-set}}$ & (\compi{$I_2$}{(
      (\compi{$I_1$}{\env})
      [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
      )}
    )[\lstinline'e' $\mapsto$ \eval{\lstinline'p2'}{\env}] \\
    \multicolumn{3}{l}{
      En évaluant \lstinline'e' dans ce nouvel environnement, on obtient :
    } \\
    \multicolumn{3}{l}{
      \eval{\lstinline'e'}{(\compi{$I_2$}{(
          (\compi{$I_1$}{\env})
          [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
          )}
        )[\lstinline'e' $\mapsto$ \eval{\lstinline'p2'}{\env}]}
    } \\
    & $\eq{\eqlabel{E-lval}}$ & \eval{\lstinline'p2'}{\env} \\
    & $\eq{\eqlabel{h7}}$
    & \eval{\lstinline'p1'}{\env} $\land$ \eval{\lstinline'p2'}{\env} \\
    & $\eq{\eqlabel{P-and}}$ & \eval{\lstinline'p1 \&\& p2'}{\env} \\

    %% cas false
    \multicolumn{3}{l}{
      (2) Cas où la valeur de l'expression de la conditionnelle est fausse :} \\
    \multicolumn{3}{l}{
      Nouvelle hypothèse : \eval{\lstinline'p1'}{\env} = \textit{false}
      ~~\eqlabel{h8}
    }\\
    \multicolumn{3}{l}{
      Car \eval{\lstinline'e'}{(
        (\compi{$I_1$}{\env})
        [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
        )} = \textit{false}}\\
    &$\eq{\eqlabel{C-if}}$
    & (\compi{$I_1$}{\env})[\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
    \\
    \multicolumn{3}{l}{
      En évaluant \lstinline'e' dans ce nouvel environnement, on obtient :
    } \\
    \multicolumn{3}{l}{
      \eval{\lstinline'e'}{(
        (\compi{$I_1$}{\env})
        [\lstinline'e' $\mapsto$ \eval{\lstinline'p1'}{\env}]
        )}
    } \\
    & $\eq{\eqlabel{E-lval}}$
    & \eval{\lstinline'p1'}{\env} \\
    & $\eq{\eqlabel{h8}}$
    & \eval{\lstinline'p1'}{\env} $\land$ \eval{\lstinline'p2'}{\env} \\
    & $\eq{\eqlabel{P-and}}$ & \eval{\lstinline'p1 \&\& p2'}{\env} \\
  \end{tabular}

  Nous avons donc prouvé, pour tout environnement \env :

  \eval{\lstinline'e'}{(
    \compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
      (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
      (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env}
    )} = \eval{\lstinline'p1 && p2'}{\env}.

  De manière informelle, la preuve de la seconde propriété est assurée par le
  fait que d'une part les fragments de code générés ne modifient que la
  variable fraîche \lstinline'e' et d'autre part, les hypothèses \eqlabel{h3}
  et \eqlabel{h4} nous assurent que les fragments $I_1$ et $_2$ ne modifient pas
  les variables de l'environnement \env.
  On en conclut donc que les fragments générés
  $I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
  (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
  (l, \mbox{\lstinline'e = e2;'}) \bclose )$ ne modifient pas les variables de
  l'environnement \env, et donc :

  \env $\subset$
  \compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
    (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
    (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env}.

  Les hypothèses \eqlabel{h5} et \eqlabel{h6} et le fait que les fragments de
  code générés ne produisent pas d'erreur (seule la variable fraîche
  \lstinline'e' est affectée) nous assurent que si \env n'est pas un
  environnement d'erreur (ici encore, \env ne peut pas être \errorenv puisque la
  traduction se serait arrêtée dès l'obtention de l'erreur), alors :

  \compi{$I_1 \cdot (l, \mbox{\lstinline'int e = e1;'}) \cdot
  (l, \mbox{\lstinline'if(e)'} \bopen I_2 \cdot
  (l, \mbox{\lstinline'e = e2;'}) \bclose )$}{\env} $\neq$ \errorenv.
  ~\\
\end{proof}





\section{Preuve de la Traduction des Annotations}
\label{sec:annotation-translation}


Nous allons maintenant prouver les théorèmes~\ref{th:error} et
\ref{th:inclusion} pour chaque classe d'annotations : les assertions, les
contrats de boucle et les contrats de fonction.
Ces preuves s'appuient sur les preuves de correction de la traduction des termes
et des prédicats établies dans les sections précédentes.


\subsection{Preuve de la Traduction des Assertions}


{\myinference[$\alpha$-assert]
  {(l, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
  {(l, \mbox{\lstinline'assert p;'})
    \rulearrow I \concat (l, \mbox{\lstinline'fassert(e);'})}
}


Prouvons que pour tout environnement \env (théorème~\ref{th:error}) :

\comp{\lstinline'/*@ assert p; */ ;'}{\env} = \errorenv
$\equiv$ \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}
= \errorenv

et si l'assertion est valide (théorème~\ref{th:inclusion}) :

\env $\subset$ \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}.


\begin{proof}
  ~\\
  Hypothèses : le prédicat \lstinline'p' est correctement traduit.
  Pour tout environnement \env :
  \begin{tabular}{rclr}
    \eval{\lstinline'e'}{(\compi{$I$}{\env})} &=& \eval{\lstinline'p'}{\env}
    & \eqlabel{h1} \\
    \env & $\subset$ & \compi{$I$}{\env} & \eqlabel{h2} \\
    \compi{$I$}{\env} & $\neq$ & \errorenv & \eqlabel{h3} \\
  \end{tabular}

  (1) Cas où l'assertion est valide :

  Nouvelle hypothèse : \eval{\lstinline'p'}{\env} = \textit{true} \eqlabel{h4}

  Développons le membre gauche :

  \begin{tabular}{rcl}
    \comp{\lstinline'/*@ assert p; */ ;'}{\env} = \errorenv
    &$\eqv{\eqlabel{C-assert}}$& \env = \errorenv \\
    &$\equiv$ & \textit{false}, car si \env = \errorenv, la traduction
    se serait arrêtée. \\
  \end{tabular}

  Développons le membre droit :

  \begin{tabular}{rcl}
    \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env} = \errorenv
    &$\eqv{\eqlabel{I-split}}$
    & \compi{$(l, \mbox{\lstinline'fassert(e);'})$}{(\compi{$I$}{\env})}
    = \errorenv \\
    &$\eqv{\eqlabel{I-instr}}$
    & \comp{\lstinline'fassert(e);'}{(\compi{$I$}{\env})} = \errorenv \\
    &$\eqv{\eqlabel{C-fassert}}$ & \compi{$I$}{\env} = \errorenv \\
    &$\eqv{\eqlabel{h3}}$ & \textit{false} \\
  \end{tabular}

  Quand l'assertion est valide, on a bien :

  \comp{\lstinline'/*@ assert p; */ ;'}{\env} = \errorenv
  $\equiv$ \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}
  = \errorenv.

  D'autre part, d'après le développement du membre droit, on a :

   \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}
   = \compi{$I$}{\env}.
   
   En substituant dans l'hypothèse \eqlabel{h2} on obtient directement :

   \env $\subset$ \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}.

  (2) Cas où l'assertion est invalide :

  Nouvelle hypothèse : \eval{\lstinline'p'}{\env} = \textit{false} \eqlabel{h5}

  Développons le membre gauche :

  \begin{tabular}{rcl}
    \comp{\lstinline'/*@ assert p; */ ;'}{\env} = \errorenv
    &$\eqv{\eqlabel{C-assert}}$& \errorenv = \errorenv \\
    &$\equiv$& \textit{true}
  \end{tabular}

  Développons le membre droit :

  \begin{tabular}{rcl}
    \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env} = \errorenv
    &$\eqv{\eqlabel{I-split}}$
    & \compi{$(l, \mbox{\lstinline'fassert(e);'})$}{(\compi{$I$}{\env})}
    = \errorenv \\
    &$\eqv{\eqlabel{I-instr}}$
    & \comp{\lstinline'fassert(e);'}{(\compi{$I$}{\env})} = \errorenv \\
    &$\eqv{\eqlabel{C-fassert}}$ & \errorenv = \errorenv \\
    &$\equiv$& \textit{true}
  \end{tabular}

  On a donc bien :

  \comp{\lstinline'/*@ assert p; */ ;'}{\env} = \errorenv
  $\equiv$ \compi{$I \concat (l, \mbox{\lstinline'fassert(e);'})$}{\env}
  = \errorenv.
  ~\\
\end{proof}


\subsection{Preuve de la Traduction des Contrats de Boucles}


Nous considérons une boucle complètement annotée avec
\lstinline'loop invariant', \lstinline'loop variant' et
\lstinline'loop assigns'.
La traduction utilise les trois règles suivantes :


{\scriptsize
  {\myinference[$\alpha$-check-loop-assigns]
    {}
    {
      \splitfrac {
        (l, \mbox{\lstinline'loop assigns X;'}) \rulearrow
      }{
        \splitfrac {
          I \concat
          \forall (\mbox{\lstinline'x'}:ctype) \in G-X:
          (BegIter_l, \mbox{\lstinline'ctype assigns_x = x;'})
        }{
          \concat (EndIter_l, \mbox{\lstinline'fassert(x == assigns_x);'})
        }
      }
    }
  }
}

{\scriptsize
  {\myinference[$\alpha$-check-invariant]
    {(l, \mbox{\lstinline'p'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
      (EndIter_l, \mbox{\lstinline'p'}) \rulearrow (I_2, \mbox{\lstinline'e2'})}
    {
      (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
      I_1 \concat (l, \mbox{\lstinline'fassert(e1);'})
      \concat I_2 \concat (EndIter_l, \mbox{\lstinline'fassert(e2);'})
    }
  }
}

{\scriptsize
  {\myinference[$\alpha$-variant]
    {
      (BegIter_l, \mbox{\lstinline't'}) \rulearrow (I_1, \mbox{\lstinline'e1'})
      \\
      (EndIter_l, \mbox{\lstinline't'}) \rulearrow (I_2, \mbox{\lstinline'e2'})
    }
    {
      \splitfrac {
        (l, \mbox{\lstinline'loop variant t;'}) \rulearrow
      }{
        \splitfrac {
          I_1 \concat ((BegIter_l,
          \mbox{\lstinline'fassert('}
          \underline{\mbox{\lstinline'0 <= e1'}}
          \mbox{\lstinline');' }
          \underline{\Zinit \mbox{\lstinline'old_variant = e1'} \Zclear}
          \semicolon)
        }{
          \concat I_2
          \concat(EndIter_l,
          \mbox{\lstinline'fassert('}
          \underline{\mbox{\lstinline'e2'}\Zclear
            \mbox{\lstinline'< old_variant'} \Zclear}
          \mbox{\lstinline');'})
        }
      }
    }
  }
}


Donnons une intuition de la preuve de correction de la traduction des
contrats de boucle à partir de ces règles.


\subsection{Preuve de la Traduction des Contrats de Fonctions}

\commentGP{TODO}













%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\commentGP{mettre toute la preuve en annexe ?}
\commentGP{juste mettre la preuve des invariants en annexe ?}
\section{Annexe : Preuve de la Traduction des Quantifications Universelles}

{\myinference[$\pi$-forall]
  {
    (l, \mbox{\lstinline't1'} : \mathbb{Z}) \rulearrow
    (I_1, \mbox{\lstinline'e1'}) \\
    (l, \mbox{\lstinline't2'} : \mathbb{Z}) \rulearrow
    (I_2, \mbox{\lstinline'e2'}) \\
    (l, \mbox{\lstinline'p'}) \rulearrow (I_3, \mbox{\lstinline'e3'})
  }
  {
    \splitfrac {
      (l, \mbox{\lstinline'\\forall integer k; t1 <= k <= t2 ==> p'})
      \rulearrow
    } {
      \splitfrac {
        (I_1 \cdot I_2
        \cdot (l, \mbox{\lstinline'int e = 1;'})
        \cdot
          (l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} )
      } {
        \cdot
          (l, \mbox{\lstinline'while('}
          \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
          \bopen
          I_3
          \cdot (l, \mbox{\lstinline'e = e3;'})
          \cdot (l, \underline{\mbox{\lstinline'k++'}} \semicolon)
          \bclose )
        \cdot
          (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon )
        \cdot
          (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon )
        \cdot
          (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon ),
        \mbox{\lstinline'e'})
      }
    }
  }
}~\\


Prouvons que pour n'importe quel environnement \env :

\eval{\lstinline'e'}{(\compi{$I$}{\env})} =
\eval{\lstinline'\\forall integer k; t1 <= k <= t2 ==> p'}{\env}

et

\env $\subset$ \compi{$I$}{\env}

et

\compi{$I$}{\env} $\neq$ \errorenv.


\begin{proof}
  ~\\
  Hypothèses : \lstinline't1', \lstinline't2' et \lstinline'p' sont correctement
  traduits.
  Pour tout environnement \env :

  \begin{tabular}{rclr}
    \eval{\lstinline'e1'}{(\compi{$I_1$}{\env})}
    & = & \eval{\lstinline't1'}{\env} & \eqlabel{h1} \\
    \eval{\lstinline'e2'}{(\compi{$I_2$}{\env})}
    & = & \eval{\lstinline't2'}{\env} & \eqlabel{h2} \\
    \eval{\lstinline'e3'}{(\comp{$I_3$}{\env})}
    & = & \eval{\lstinline'p'}{\env} & \eqlabel{h3} \\
    \env & $\subset$ & \compi{$I_1$}{\env} & \eqlabel{h4} \\
    \env & $\subset$ & \compi{$I_2$}{\env} & \eqlabel{h5} \\
    \env & $\subset$ & \compi{$I_3$}{\env} & \eqlabel{h6} \\
    \compi{$I_1$}{\env} & $\neq$ & \errorenv & \eqlabel{h7} \\
    \compi{$I_2$}{\env} & $\neq$ & \errorenv & \eqlabel{h8} \\
    \compi{$I_3$}{\env} & $\neq$ & \errorenv & \eqlabel{h9} \\
  \end{tabular}

  Développons \compi{$I$}{\env} :
  
  \begin{tabular}{p{0cm} p{.5cm} p{14cm}}
    \multicolumn{3}{l}{\compi{$I$}{\env}} \\
    &=&
    \compi{$I_1 \cdot I_2 \cdot (l, \mbox{\lstinline'int e = 1;'}) \cdot
      (l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
      (l, \mbox{\lstinline'while('}
      \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
      \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
      (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
      (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{\env}
    \\
    &$\eq{\eqlabel{I-split}}$&
    \compi{$I_2 \cdot (l, \mbox{\lstinline'int e = 1;'}) \cdot
      (l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
      (l, \mbox{\lstinline'while('}
      \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
      \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
      (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
      (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      (\compi{$I_1$}{\env})}
    \\
    &$\eq{\eqlabel{I-split}}$&
    \compi{$(l, \mbox{\lstinline'int e = 1;'}) \cdot
      (l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
      (l, \mbox{\lstinline'while('}
      \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
      \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
      (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
      (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      (\compi{$I_2$}{(\compi{$I_1$}{\env})})
    }
    \\
    &$\eq{\eqlabel{I-split}}$&
    \compi{$(l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
      (l, \mbox{\lstinline'while('}
      \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
      \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
      (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
      (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      (\compi{$(l, \mbox{\lstinline'int e = 1;'})$}{
        (\compi{$I_2$}{(\compi{$I_1$}{\env})})})
    }
    \\
    &$\eq{\eqlabel{I-instr}}$&
    \compi{$(l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
      (l, \mbox{\lstinline'while('}
      \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
      \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
      (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
      (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      (\comp{\lstinline'int e = 1;'}{(\compi{$I_2$}{(\compi{$I_1$}{\env})})})
    }
    \\
    &$\eq{\eqlabel{C-set}}$&
    \compi{$(l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} ) \cdot
      (l, \mbox{\lstinline'while('}
      \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
      \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
      (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
      (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
    }
    \\
    &$\eq{\eqlabel{I-split}}$&
    \compi{$(l, \mbox{\lstinline'while('}
      \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
      \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
      (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
      (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      (\compi{$(l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} )$}{
        ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])})
    }
    \\
    &$\eq{\eqlabel{I-instr}}$&
    \compi{$(l, \mbox{\lstinline'while('}
      \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
      \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
      (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
      (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      (\comp{$\Zinit \underline{\mbox{\lstinline'k = e1;'}}$}{
        ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])})
    }
    \\
    &$\eq{\eqlabel{C-Z-set}}$&
    \compi{$(l, \mbox{\lstinline'while('}
      \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
      \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
      (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose ) \cdot
      (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
        \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
    }
    \\
    &$\eq{\eqlabel{I-split}}$&
    \compi{$(l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      (\compi{$(l, \mbox{\lstinline'while('}
        \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
        \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
        (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose )$}{
        ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
          \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
      })
    }
    \\
    &$\eq{\eqlabel{I-instr}}$&
    \compi{$(l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      (\comp{$\mbox{\lstinline'while('}
        \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
        \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
        (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose$}{
        ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
          \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
      })
    }
    \\
  \end{tabular}

  (1) Cas \eval{\lstinline't1'}{\env} $>$ \eval{\lstinline't2'}{\env}
  (nouvelle hypothèse \eqlabel{rel1}) :

  \begin{tabular}{p{0cm} p{.5cm} p{14cm}}
    &$\eq{\eqlabel{C-while}}$&
    \compi{$(l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
        \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
    }
    \\
    &$\eq{\eqlabel{I-split}}$&
    \compi{$(l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      (\compi{$(l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon )$}{
        ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
          \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
      })
    }
    \\
    &$\eq{\eqlabel{I-instr}}$&
    \compi{$(l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      (\comp{$\underline{\mbox{\lstinline'k'}} \Zclear \semicolon$}{
        ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
          \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
      })
    }
    \\
    &$\eq{\eqlabel{C-Z-unset}}$&
    \compi{$(l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
      (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
      ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
    }
    \\
    &$\eq{\eqlabel{I-split}}$&
    \compi{$(l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{(
      \compi{$(l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon )$}{
        ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
      })
    }
    \\
    &$\eq{\eqlabel{I-instr}}$&
    \compi{$(l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{(
      \comp{$\underline{\mbox{\lstinline'e1'}} \Zclear \semicolon$}{
        ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
      })
    }
    \\
    &$\eq{\eqlabel{C-Z-unset}}$&
    \compi{$(l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{(
      ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
      $-~\{\mbox{\lstinline'e1'}\}$)
    }
    \\
    &$\eq{\eqlabel{I-instr}}$&
    \comp{$\underline{\mbox{\lstinline'e2'}} \Zclear \semicolon$}{(
      ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
      $-~\{\mbox{\lstinline'e1'}\}$)
    }
    \\
    &$\eq{\eqlabel{C-Z-unset}}$&
      ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
      $-~\{\mbox{\lstinline'e1',\lstinline'e2'}\}$
    \\
  \end{tabular}

  En évaluant \lstinline'e' dans ce nouvel environnement, on obtient :

  \begin{tabular}{rcl}
    \eval{\lstinline'e'}{
      (((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
      $-~\{\mbox{\lstinline'e1',\lstinline'e2'}\}$)}
    & $\eq{\eqlabel{E-lval}}$ & 1 \\
    & = & \lstinline'\forall integer k; \false ==> p' \\
    & $\eq{\eqlabel{rel1}}$
    & \lstinline'\forall integer k; t1 <= k <= t2 ==> p' \\
  \end{tabular}

  D'après les hypothèses \eqlabel{h4}, \eqlabel{h5} et le fait que les seules
  variables modifiées ont été générées par l'instrumentation (\lstinline'e',
  \lstinline'e1' et \lstinline'e2'), on a :

  \env $\subset$
  (((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
  $-~\{\mbox{\lstinline'e1',\lstinline'e2'}\}$).

  Les hypothèses \eqlabel{h7} et \eqlabel{h8} nous permettent de déduire que :

  (((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1])
  $-~\{\mbox{\lstinline'e1',\lstinline'e2'}\}$) $\neq$ \errorenv.

  (2) Cas \eval{\lstinline't1'}{\env} $\le$ \eval{\lstinline't2'}{\env}
  (nouvelle hypothèse \eqlabel{rel2}) :

  Pour calculer le nouvel environnement résultant de l'exécution de la boucle
  nous avons besoin de deux invariants de boucle :

  \begin{tabular}{rclr}
    \multicolumn{3}{c}{
      \eval{\lstinline't1'}{\env} $\le$ \eval{\lstinline'k'}{\env} $\le$
      \eval{\lstinline't2'}{\env} + 1
    }
    & \eqlabel{inv-1} \\
    \eval{\lstinline'e'}{\env} &=&
    \eval{\lstinline'\\forall integer z; t1 <= z < k ==> p'}{\env}
    & \eqlabel{inv-2} \\
  \end{tabular}

  Supposons que ces propriétés ont été prouvées.
  \commentGP{Preuve longue. Pas nécessaire ?}
  Notons \env$'$ l'environnement après exécution de la boucle :

  \env$'$ = 
  \comp{$\mbox{\lstinline'while('}
    \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
    \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
    (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose$}{
    ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
      \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
  }

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\compi{$I$}{\env}}
    &=&
    \eval{\lstinline'e'}{
      (\compi{$(l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) \cdot
        (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon ) \cdot
        (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon )$}{
        (\compi{$(l, \mbox{\lstinline'while('}
          \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
          \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
          (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose )$}{
          ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
            \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
        })
      })
    } \\
    &=&
    \eval{\lstinline'e'}{
        (\compi{$(l, \mbox{\lstinline'while('}
          \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& e)'}
          \bopen I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
          (l, \underline{\mbox{\lstinline'k++'}} \semicolon) \bclose )$}{
          ((\compi{$I_2$}{(\compi{$I_1$}{\env})})[\lstinline'e' $\mapsto$ 1,
            \lstinline'k' $\mapsto$ \eval{\lstinline't1'}{\env}])
        })
    } \\
    &=& \eval{\lstinline'e'}{\env$'$} \\
    &=& \eval{\lstinline'\\forall integer z; t1 <= z < k ==> p'}{\env} \\
  \end{tabular}

  Rappelons que
  \eval{\lstinline't1'}{\env$'$} $\le$ \eval{\lstinline'k'}{\env$'$} $\le$
  \eval{\lstinline't2'}{\env$'$} + 1
  (premier invariant de boucle).

  On sait que la condition de boucle est fausse dans cet environnement \env$'$ :

  \eval{\lstinline'k <= e2 && e'}{\env$'$} = \textit{false}

  Il y a donc deux cas non exclusifs :
  \begin{itemize}
  \item[$\bullet$] \eval{\lstinline'k <= e2'}{\env$'$} = \textit{false}
  \item[$\bullet$] \eval{\lstinline'e'}{\env$'$} = \textit{false}
  \end{itemize}

  (2-a) Cas \eval{\lstinline'k <= e2'}{\env$'$} = \textit{false}, soit
  \eval{\lstinline'k > t2'}{\env$'$} = \textit{true} :
  
  On sait que \eval{\lstinline'k > t2'}{\env$'$} et
  \eval{\lstinline'k <= t2+1'}{\env$'$},
  donc on
  a \eval{\lstinline'k'}{\env$'$} = \eval{\lstinline't2+1'}{\env$'$}.
  Avec cette nouvelle connaissance, on a :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\compi{$I$}{\env}}
    &=& \eval{\lstinline'\\forall integer z; t1 <= z < k ==> p'}{\env} \\
    &=& \eval{\lstinline'\\forall integer z; t1 <= z < t2+1 ==> p'}{\env} \\
    &=& \eval{\lstinline'\\forall integer z; t1 <= z <= t2 ==> p'}{\env} \\
  \end{tabular}

  (2-b) Cas \eval{$e$}{\env$'$} = \textit{false} :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\env$'$} = \textit{false}
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t1 <= z < k ==> p'}{\env$'$}
    = \textit{false} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t1 <= z < t2+1 ==> p'}{\env$'$}
    = \textit{false} \\
    \multicolumn{3}{c}{car \eval{\lstinline'k'}{\env$'$} $\le$
      \eval{\lstinline't2+1'}{\env$'$}} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t1 <= z <= t2 ==> p'}{\env$'$}
    = \textit{false} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t1 <= z <= t2 ==> p'}{\env}
    = \textit{false} \\
    \multicolumn{3}{c}{
      car (\eval{\lstinline't1'}{\env}) = (\eval{\lstinline't1'}{\env$'$}) et
      (\eval{\lstinline't2'}{\env}) = (\eval{\lstinline't2'}{\env$'$})
    } \\
  \end{tabular}

  Donc on a :
  \eval{\lstinline'e'}{\env$'$} $\equiv$
  \eval{\lstinline'\\forall integer z; t1 <= z <= t2 ==> p'}{\env}.

  On a donc aussi :

  \eval{\lstinline'e'}{\compi{$I$}{\env}} =
  \eval{\lstinline'\\forall integer z; t1 <= z <= t2 ==> p'}{\env}.

  Grâce aux hypothèses \eqlabel{h4}, \eqlabel{h5}, \eqlabel{h6} et le fait que
  les seules variables affectées sont \lstinline'e' et \lstinline'k', qui
  n'appartiennent pas à l'environnement initial \env, on peut établir :
  \env $\subset$ \compi{$I$}{\env}.

  De manière similaire, grâce aux hypothèses \eqlabel{h7}, \eqlabel{h8},
  \eqlabel{h9}, et le fait que les fragments de code générés de provoquent pas
  d'erreur, le nouvel environnement est différent de \errorenv.
\end{proof}



\newpage

\begin{proof}
  ~\\
  \commentGP{à mettre en annexe ou pas ?}
  \commentGP{je pense que la preuve n'est pas nécessaire}

  Montrons que \eqlabel{inv-1} et \eqlabel{inv-2} sont vrais pour tout
  environnement \env.
  Montrons tout d'abord que ces invariants sont établis avant la première
  itération.

  Développons
  \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} + 1 :

  \begin{tabular}{rcl}
    \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} + 1
    &=& \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env}
    $\le$ \eval{$t_2$}{\env} + 1 \\
    &=& \eval{$t_1$}{\env} $\le$ \eval{$t_2$}{\env} + 1 \\
    &$\eq{rel2}$& \textit{true} \\
  \end{tabular}

  Développons le membre droit de

  \eval{$e$}{\env} =
  \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env} :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}
    } \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= k-1 ==> p'}{\env} \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= t_1-1 ==> p'}{\env} \\
    &=& \eval{\lstinline'\\forall integer z; \\false ==> p'}{\env} \\
    &=& \eval{\lstinline'\\true'}{\env} \\
    &=& 1 \\
    &=& \eval{$e$}{\env} \\
  \end{tabular}

  Ces deux invariants sont établis avant la première itération, montrons qu'ils
  sont maintenus après chaque itération.
  On suppose donc que ces invariants sont vrais après une itération quelconque
  et sont donc des hypothèses.
  Soit \env l'environnement au début de l'itération.

  Prouvons que le premier invariant est maintenu après chaque itération :

  On a : \eval{$t_1$}{\env} $\le$ \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} + 1
  
  Ce qui peut être réécrit en :
  \eval{$t_1 \le k \le t_2 + 1$}{\env} = \textit{true}

  Montrons :

  \eval{$t_1 \le k \le t_2 + 1$}{\compi{
      $I_3 \cdot (l, \mbox{\lstinline'e = e3;'}) \cdot
      (l, \underline{\mbox{\lstinline'k++'}} \semicolon)$
    }{
      (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
    }} = \textit{true}

  Développons le membre gauche :

  \begin{tabular}{p{6cm} p{.5cm} p{9cm}}
    \eval{$t_1 \le k \le t_2 + 1$}{\comp{
      $I_3 \cdot \mbox{\lstinline'e = e_3;'}
      \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
    }{
      (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
    }}
    &=&
    \eval{$t_1 \le k \le t_2 + 1$}{
      \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
        $e \mapsto$ \eval{\lstinline'p'}{\env},
        $k \mapsto$ (\eval{\lstinline'k'}{\env})+1]
    } \\
    &=&
    \eval{$t_1 \le k+1 \le t_2 + 1$}{
      \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
        $e \mapsto$ \eval{\lstinline'p'}{\env},
        $k \mapsto$ (\eval{\lstinline'k'}{\env})]
    } \\
    &=& \eval{$t_1 \le k+1 \le t_2 + 1$}{\env} \\
    &=& \eval{$t_1 \le k+1$}{\env} $\land$ \eval{$k+1 \le t_2 + 1$}{\env} \\
    &=& \eval{$t_1 \le k+1$}{\env} $\land$ \eval{$k \le t_2$}{\env} \\
    &=& \textit{true} $\land$ \eval{$k \le t_2$}{\env} \\
    \multicolumn{3}{c}{par hypothèse de récurrence} \\
    &=& \eval{$k \le t_2$}{\env} \\
    &=& \eval{$k$}{\env} $\le$ \eval{$t_2$}{\env} \\
    &=& \eval{$k$}{\env} $\le$ \eval{$e_2$}{\env} \\
    &=& \eval{$k \le e_2$}{\env} \\
    &=& \textit{true} \\
    \multicolumn{3}{c}{la condition de boucle est vraie sinon on n'exécuterait
      pas le code de la boucle} \\
  \end{tabular}
  
  Le premier invariant est donc maintenu après chaque itération.
  Prouvons maintenant que le deuxième invariant est maintenu après chaque
  itération.
  Développons le membre gauche :

  \begin{tabular}{p{6cm} p{.5cm} p{9cm}}
    (\comp{
      $I_3 \cdot \mbox{\lstinline'e = e_3;'}
      \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
    }{
      (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
    })(e)
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      \comp{\lstinline'e = e_3;'}{(
        \comp{$I_3$}{(
          \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
            $e_2 \mapsto$ \eval{$t_2$}{\env},
            $e \mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}]
          )}
        )}
      )}
    )(e) \\
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      \comp{\lstinline'e = e_3;'}{(
        \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
          $e_2 \mapsto$ \eval{$t_2$}{\env},
          $e \mapsto$
          \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env},
          $e_3 \mapsto$ \eval{\lstinline'p'}{\env}]
        )}
      )}
    )(e) \\
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      \env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
        $e \mapsto$ \eval{\lstinline'p'}{\env}]
      )}
    )(e) \\
    &=&
    (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
      $e_2 \mapsto$ \eval{$t_2$}{\env},
      $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
      $e \mapsto$ \eval{\lstinline'p'}{\env},
      $k \mapsto$ (\eval{\lstinline'k'}{\env})+1]
    )(e) \\
    &=& \eval{\lstinline'p'}{\env} \\
    &=& \eval{\lstinline'e'}{\env} $\land$ \eval{\lstinline'p'}{\env} \\
    \multicolumn{3}{c}{\eval{\lstinline'e'}{\env} est vrai sinon on
      n'exécuterait pas le code de la boucle} \\
  \end{tabular}

  Développons le membre droit :

  \begin{tabular}{p{5cm} p{.5cm} p{9cm}}
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{
      (\comp{
        $I_3 \cdot \mbox{\lstinline'e = e_3;'}
        \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
      }{
        (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
          $e_2 \mapsto$ \eval{$t_2$}{\env},
          $e \mapsto$
          \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env}])
      })
    }
    &=&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{
      (\env[$e_1 \mapsto$ \eval{$t_1$}{\env},
        $e_2 \mapsto$ \eval{$t_2$}{\env},
        $e_3 \mapsto$ \eval{\lstinline'p'}{\env},
        $e \mapsto$ \eval{\lstinline'p'}{\env},
        $k \mapsto$ (\eval{\lstinline'k'}{\env})+1])
    } \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z < k+1 ==> p'}{\env} \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= k ==> p'}{\env} \\
    &=&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{\env} \newline
    $\land$ \eval{\lstinline'\\forall integer z; z == k ==> p'}{\env} \\
    &=&
    \eval{\lstinline'e'}{\env}
    $\land$ \eval{\lstinline'\\forall integer z; z == k ==> p'}{\env} \\
    &=& \eval{\lstinline'e'}{\env} $\land$ \eval{\lstinline'p'}{\env} \\
    \multicolumn{3}{c}{car \eval{\lstinline'p'}{\env} est la valeur de $p$ pour
    le $k$ courant} \\
  \end{tabular}

  Le deuxième invariant est donc lui aussi maintenu après chaque itération.
\end{proof}
