
\chapter{Preuve de correction}
\label{sec:preuve-correction}


La grammaire des termes et prédicats de \eacsl \cite{\citeeacsl} autorisés dans
les annotations est détaillée en section~\ref{sec:grammar}, leur sémantique est
présentée en section~\ref{sec:semantics}.
Les propriétés que nous vérifions sont définies en section~\ref{sec:properties}.
Les sections~\ref{sec:term-translation}, \ref{sec:predicate-translation} et
\ref{sec:annotation-translation} détaillent la preuve de ces propriétés
respectivement sur les termes, sur les prédicats et sur les annotations.


\section{Grammaire du langage en entrée}
\label{sec:grammar}

\begin{figure}[tb]
  \begin{tabular}{lrl}
    \textit{unop} & ::= & \lstinline'-' $\mid$ \lstinline'*' $\mid$
    \lstinline'!' $\mid$ \lstinline'~' \\
    \textit{binop} & ::= & \lstinline'+' $\mid$ \lstinline'-' $\mid$
    \lstinline'*' $\mid$ \lstinline'/' $\mid$ \lstinline'%' $\mid$
    \lstinline'>' $\mid$ \lstinline'>=' $\mid$ \lstinline'<' $\mid$
    \lstinline'<=' $\mid$ \lstinline'==' $\mid$ \lstinline'!=' \\
    \textit{term} & ::= & \textit{cst} \\
    & $\mid$ & \textit{lvalue} \\
    & $\mid$ & \textit{unop} \textit{term} \\
    & $\mid$ & \textit{term} \textit{binop} \textit{term} \\
    & $\mid$ & \lstinline'\abs(' \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\sum(' \textit{term}$,$ \textit{term}$,$
    \lstinline'\lambda integer' \textit{id}$;$ \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\product(' \textit{term}, \textit{term},
    \lstinline'\lambda integer' \textit{id}; \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\numof(' \textit{term}, \textit{term},
    \lstinline'\lambda integer' \textit{id}; \textit{term} \lstinline')' \\
    & $\mid$ & \textit{term} \texttt{?} \textit{term} \texttt{:} \textit{term}\\
    & $\mid$ & \lstinline'\old(' \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\null' \\
    & $\mid$ & \lstinline'(' \textit{type} \lstinline')' \textit{term} \\
    \textit{relation} & ::= & \lstinline'>' $\mid$ \lstinline'>=' $\mid$
    \lstinline'<' $\mid$ \lstinline'<=' $\mid$ \lstinline'==' $\mid$
    \lstinline'!=' \\
    \textit{pred} & ::= & \lstinline'\true' \\
    & $\mid$ & \lstinline'\false' \\
    & $\mid$ & \lstinline'\valid(' \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\forall integer' \textit{id};
    \textit{term} <= \textit{id} <= \textit{term}
    \lstinline'==>' \textit{pred} \\
    & $\mid$ & \lstinline'\exists integer' \textit{id};
    \textit{term} <= \textit{id} <= \textit{term}
    \lstinline'&&' \textit{pred} \\
    & $\mid$ & ! \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'&&' \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'||' \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'==>' \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'<==>' \textit{pred} \\
    & $\mid$ & \textit{term} ? \textit{pred} : \textit{pred} \\
    & $\mid$ & \textit{term} \textit{relation} \textit{term} \\
    \textit{assert} & ::= & \lstinline'assert' \textit{pred} \\
    \textit{requires} & ::= & \lstinline'requires' \textit{pred} \\
    \textit{typically} & ::= & \lstinline'typically' \textit{pred} \\
    \textit{ensures} & ::= & \lstinline'ensures' \textit{pred} \\
    \textit{assigns} & ::= & \lstinline'assigns' \textit{term}$^{+}$ \\
    \textit{loop-invariant} & ::= & \lstinline'loop invariant' \textit{pred} \\
    \textit{loop-variant} & ::= & \lstinline'loop variant' \textit{term} \\
    \textit{loop-assigns} & ::= & \lstinline'loop assigns' \textit{term}$^{+}$
  \end{tabular}
  \caption{Grammaire des termes, prédicats et annotations \eacsl}
  \label{fig:gram-eacsl}
\end{figure}

\begin{figure}[tb]
  \begin{tabular}{lrl}
    \textit{exp} & ::= & \textit{cst} \\
    & $\mid$ & \textit{lvalue} \\
    & $\mid$ & \textit{unop} \textit{exp} \\
    & $\mid$ & \textit{exp} \textit{binop} \textit{exp} \\
    & $\mid$ & \lstinline'(' \textit{type} \lstinline')' \textit{term} \\
    \textit{instr} & ::= & ; \\
    & $\mid$ & \textit{lval} \lstinline'=' \textit{exp}; \\
    & $\mid$ & \textit{id} (\textit{exp}$^{*}$); \\
    & $\mid$ & \textit{lval} \lstinline'=' \textit{id} (\textit{exp}$^{*}$); \\
    & $\mid$ & \lstinline'return' \textit{exp}; \\
    & $\mid$ & \lstinline'if(' \textit{exp} \lstinline')'
    $\bopen$ \textit{instr}$^*$ $\bclose$
    \lstinline'else' $\bopen$ \textit{instr}$^*$ $\bclose$ \\
    \textit{loop-instr} & ::= & \lstinline'while(' \textit{exp} \lstinline')'
    $\bopen$ \textit{instr}$^*$ $\bclose$ \\
    \textit{annot-instr} & ::= & \lstinline'/*@' \textit{assert} \lstinline'*/'
    \textit{instr} \\
    & $\mid$ & \lstinline'/*@' \textit{loop-invariant} \textit{loop-variant}
    \textit{loop-assigns} \lstinline'*/' \textit{loop-instr} \\
    \textit{function} & ::= & \lstinline'/*@' \textit{requires} \textit{assigns}
    \textit{ensures} \lstinline'*/' \textit{type} \textit{id}
    (\textit{type} \textit{lvalue}$^{*}$)
    $\bopen$ \textit{decl}$^{*}$ \textit{annot-instr}$^{*}$
    $\bclose$
  \end{tabular}
  \caption{Grammaire des expressions et instructions C}
  \label{fig:gram-c}
\end{figure}



\section{Semantique du langage C annoté avec \eacsl}
\label{sec:semantics}


\begin{notation}

  ~
  \begin{itemize}
  \item $x$, $y$ et $z$ sont des identificateurs de variable
  \item $v$ est une valeur
  \item \eval{$t$}{env} est l'évaluation du terme \eacsl ou de l'expression C
    $t$ dans l'environnement $env$
  \item \comp{$I$}{env} calcule a nouvel environnement résultant de
    l'exécution des instructions $I$ dans l'environnement $env$
  \item $update(env, x, v)$ est l'environnement contenant les mêmes
    relations (variable, valeur) que $env$, et la relation supplémentaire
    ($x$, $v$)
  \item $update(env, x, v)(x) = v$
  \item $update(env, x, v)(y) = env(y)$ si $x \neq y$
  \item $\bot$ est une valeur spéciale qui signifie qu'une variable n'est pas
    ou plus initialisée
  \item une instruction soulignée \underline{\lstinline{instr}} est une
    instruction utilisant la sémantique des entiers non bornés
  \item $\Zinit$\underline{\lstinline{x}} signifie que la variable entière
    \lstinline'x' est allouée et prête à être utilisée
  \item \underline{\lstinline{x}}$\Zclear$ signifie que la variable entière
    \lstinline'x' est désallouée.
  \end{itemize}
\end{notation}


\subsection{Sémantique des termes \eacsl et expression C}

\begin{tabular}{rclr}
  \eval{cst}{$env$} &=& cst & \eqlabel{E-cst} \\
  \eval{lvalue}{$env$} &=& $env$(lvalue) & \eqlabel{E-lval} \\
  \eval{\lstinline|unop x|}{$env$}
  &=& \lstinline|unop| (\eval{\lstinline|x|}{$env$}) & \eqlabel{E-unop} \\
  \eval{\lstinline|x binop y|}{$env$}
  &=& (\eval{\lstinline|x|}{$env$}) \lstinline|binop|
  (\eval{\lstinline|y|}{$env$}) & \eqlabel{E-binop} \\
  \eval{\lstinline'\\abs(t)'}{$env$} &=&
  $\lvert$ \eval{\lstinline't'}{$env$} $\rvert$ & \eqlabel{E-abs} \\
  \eval{\lstinline'\\sum(x, y, \\lambda integer k; z)'}{$env$} &=&
  $\sum_{k = \mbox{\eval{\lstinline'x'}{$env$}}}^{\mbox{\eval{\lstinline'y'}{$env$}}} \mbox{\eval{\lstinline'z'}{$env$}}$
  & \eqlabel{E-sum} \\
  \eval{\lstinline'\\product(x, y, \\lambda integer k; z)'}{$env$} &=&
  $\prod_{k = \mbox{\eval{\lstinline'x'}{$env$}}}^{\mbox{\eval{\lstinline'y'}{$env$}}} \mbox{\eval{\lstinline'z'}{$env$}}$
  & \eqlabel{E-prod} \\
  \eval{\lstinline'\\numof(x, y, \\lambda integer k; z)'}{$env$} &=&
  $\sum_{k = \mbox{\eval{\lstinline'x'}{$env$}}}^{\mbox{\eval{\lstinline'y'}{$env$}}} \mbox{\eval{\lstinline'z ? 1 : 0'}{$env$}}$
  & \eqlabel{E-num} \\
  \eval{\lstinline'x ? y : z'}{$env$} &=& \eval{\lstinline'y'}{$env$}
  si (\eval{\lstinline'x'}{$env$}) $\neq$ 0 & \eqlabel{E-tif} \\
  &=& \eval{\lstinline'z'}{$env$}
  si (\eval{\lstinline'x'}{$env$}) = 0 & \eqlabel{E-tif'} \\
  \eval{\lstinline'\\old(t)'}{$env$} &=&
  \eval{\lstinline't'}{($env$ en début de fonction)}
  & \eqlabel{E-old} \\
  \eval{\lstinline'\\null'}{$env$} &=& \lstinline'NULL' & \eqlabel{E-null} \\
  \eval{\lstinline|(type) x|}{$env$}
  &=& \lstinline|(type)| (\eval{\lstinline|x|}{$env$}) & \eqlabel{E-cast} \\
\end{tabular}


\subsection{Sémantique des prédicats \eacsl}


\begin{tabular}{rclr}
  \eval{\lstinline'\\true'}{$env$} &=& \textit{true} & \eqlabel{P-true} \\
  \eval{\lstinline'\\false'}{$env$} &=& \textit{false} & \eqlabel{P-false} \\
  \eval{\lstinline'\\valid(t)'}{$env$} &=&
  "\lstinline'*t' est défini dans $env$" & \eqlabel{P-valid} \\
  \eval{\lstinline'\\forall integer k; a <= k <= b ==> y'}{$env$} &=&
  $\forall_{k=\mbox{\eval{\lstinline'a'}{$env$}}}^{\mbox{\eval{\lstinline'b'}{$env$}}} \mbox{\eval{\lstinline'y'}{$env$}}$
  & \eqlabel{P-forall} \\
  \eval{\lstinline'\\exists integer k; a <= k <= b \&\& y'}{$env$} &=&
  $\exists_{k=\mbox{\eval{\lstinline'a'}{$env$}}}^{\mbox{\eval{\lstinline'b'}{$env$}}} \mbox{\eval{\lstinline'y'}{$env$}}$
  & \eqlabel{P-exists} \\
  \eval{\lstinline'\! p'}{$env$} &=& $\lnot$ (\eval{\lstinline'p'}{$env$})
  & \eqlabel{P-not} \\
  \eval{\lstinline'p \&\& q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\land$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-and} \\
  \eval{\lstinline'p || q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\lor$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-or} \\
  \eval{\lstinline'p ==> q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\Rightarrow$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-impl} \\
  \eval{\lstinline'p <==> q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\Leftrightarrow$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-eq} \\
  \eval{\lstinline'x ? y : z'}{$env$} &=& \eval{\lstinline'y'}{$env$}
  si \eval{\lstinline'x'}{$env$} & \eqlabel{P-pif} \\
  &=& \eval{\lstinline'z'}{$env$} sinon & \eqlabel{P-pif'} \\
  \eval{\lstinline|x rel y|}{$env$}
  &=& (\eval{\lstinline|x|}{$env$}) \lstinline|rel|
  (\eval{\lstinline|y|}{$env$}) & \eqlabel{P-rel} \\
\end{tabular}


\subsection{Sémantique des instructions}

\begin{tabular}{rclr}
  \comp{A $\cdot$ B}{$env$} &=& \comp{B}{(\comp{A}{$env$})} & \eqlabel{C-seq} \\
  \comp{\lstinline|a = b;|}{$env$}
  &=& update($env$, a, \eval{b}{$env$}) & \eqlabel{C-assign} \\
  \comp{$\Zinit$ \underline{\lstinline|a = b|} $\semicolon$}{$env$}
  &=& update($env$, a, \eval{b}{$env$}) & \eqlabel{C-assign'} \\
  \comp{\underline{\lstinline|a|} $\Zclear \semicolon$}{$env$}
  &=& update($env$, a, $\bot$) & \eqlabel{C-unset} \\
  \comp{\lstinline|if(x) A else B|}{$env$}
  &=& \comp{A}{$env$} si \eval{x}{$env$} & \eqlabel{C-if} \\
  &=& \comp{B}{$env$} sinon & \eqlabel{C-if'} \\
  \comp{\lstinline|while(x) A|}{$env$}
  &=& \comp{\lstinline|while(x) A|}{(\comp{A}{$env$})}
  si \eval{x}{$env$} & \eqlabel{C-while} \\
  &=& $env$ sinon & \eqlabel{C-while'} \\
\end{tabular}


\section{Properties}
\label{sec:properties}

\begin{notation}
  Soit $P$ un programme C correct syntaxiquement selon la grammaire définie en
  figure~\ref{fig:gram-eacsl} et~\ref{fig:gram-c}.
  Soit $P'$ le programme instrumenté obtenu après traduction du programme $P$.
\end{notation}



\begin{theorem}
  Si une annotation $a$ est invalide, alors l'exécution dans le programme $P$
  des instructions obtenues par instrumentation provoque une erreur dans le
  programme instrumenté $P'$.
  \commentGP{une propriété pour chaque type d'annotation ?}
\end{theorem}

\begin{theorem}
  Si toutes les annotations d'un programme $P$ sont valides, alors $P$ et $P'$
  (obtenu après instrumentation de $P$) ont la même sémantique, et le même
  comportement est observable à l'exécution.
\end{theorem}



\section{Term translation}
\label{sec:term-translation}


\begin{lemma}\label{lem:term-correct}
  Soit $t$ : $\tau$ un terme de type $\tau$, qui se traduit en $(I, t')$.
  La traduction est correcte si et seulement si, pour n'importe quel
  environnement $env$ :

  \eval{$t'$}{\comp{$I$}{env}} = \eval{$t$}{env}.
\end{lemma}


\subsection{Constant Term}

{\myinference[CST]
  {}
  { (l, v : \mathbb{Z}) \rulearrow
    ((l, \Zinit\underline{\mbox{\lstinline'x = v;'}}), x) }
}

Pour n'importe quel environnement $env$, nous prouvons que :

\eval{x}{\comp{$\Zinit$\underline{\lstinline'x = v;'}}{env}} = \eval{v}{env}.


\begin{proof}
  ~\\
  \begin{tabular}{rclr}
    \eval{x}{\comp{$\Zinit$\underline{\lstinline'x = v;'}}{env}}
    & $\eq{C-assign'}$ & \eval{x}{update(env, x, \eval{v}{env})} & \\
    & $\eq{E-lval}$ & \eval{v}{env} &
  \end{tabular}
\end{proof}


\section{Predicate translation}
\label{sec:predicate-translation}


\begin{lemma}\label{lem:pred-correct}
  Soit $p$ un prédicat qui se traduit en $(I, p')$.
  La traduction est correct si et seulement si, pour n'importe quel
  environnement $env$ :

  \eval{$p'$}{\comp{$I$}{env}} = \eval{$p$}{env}.
\end{lemma}


\subsection{And Predicate}

{\myinference[AND]
  { (l, p_1) \rulearrow (I_1, e_1) \\ (l, p_2) \rulearrow (I_2, e_2) }
  { (l, \mbox{\lstinline'p_1 && p_2'}) \rulearrow
    (
    \underbracket{
      I_1 \cdot
      \underbracket{ (l, \mbox{\lstinline'int e = e_1;'}) }_{i_1}
      \cdot
      \underbracket{ (l, \mbox{\lstinline'if(e)'})
        \bopen
        I_2 \cdot
        \underbracket{ (l, \mbox{\lstinline'e = e_2;'}) }_{i_2}
        \bclose }_{i_3}
      }_{I},
    e) }
}~\\

Pour n'importe quel environnement $env$, nous prouvons que :

\eval{\lstinline'e'}{\comp{$I$}{$env$}} = \eval{\lstinline'p1 && p2'}{$env$}.


\begin{proof}
  ~\\
  Hypothèses : $p_1$ et $p_2$ sont correctement instrumentés.
  Pour tout environnement $env$ :

  \begin{tabular}{rclr}
    \eval{$e_1$}{\comp{$I_1$}{$env$}}
    & = & \eval{$p_1$}{$env$} & \eqlabel{h1} \\
    $\equiv$ \comp{$I_1$}{$env$}
    & = & $env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}] & \\
    \eval{$e_2$}{\comp{$I_2$}{$env$}}
    & = & \eval{$p_2$}{$env$} & \eqlabel{h2} \\
    $\equiv$ \comp{$I_2$}{$env$}
    & = & $env$[$e_2 \mapsto$ \eval{$p_2$}{$env$}] & \\
  \end{tabular}

  On doit prouver l'égalité suivante :

  \eval{\lstinline'e'}{\comp{$I$}{$env$}}
  $\eq{?}$ \eval{\lstinline'p1 && p2'}{$env$}

  Développons le membre gauche :
  
  \begin{tabular}{p{3cm} p{.5cm} p{12cm}}
    \eval{\lstinline'e'}{\comp{$I$}{$env$}}
    & = & (\comp{$I$}{$env$})(e) \\
    & $\eq{C-seq}$ & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
      (l, \lstinline'e = e_2;') $\bclose$ }{
      (\comp{\lstinline'int e = e1;'}{
        (\comp{$I_1$}{$env$})
      })
    })(e) \\
    & $\eq{h1}$ & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
      (l, \lstinline'e = e_2;') $\bclose$ }{
      (\comp{\lstinline'int e = e1;'}{
        ($env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}])
      })
    })(e) \\
    %% & = & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
    %%   (l, \lstinline'e = e_2;') $\bclose$ }{
    %%   (
    %%   ($env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}])[$e \mapsto$
    %%     \eval{$e_1$}{$env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}]}]
    %%   )
    %% })(e) \\
    & $\eq{C-assign}$ & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
      (l, \lstinline'e = e_2;') $\bclose$ }{
      (
      $env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}, $e \mapsto$ \eval{$p_1$}{$env$}]
      )
    })(e) \\

    %% cas true
    \multicolumn{3}{l}{
      Quand \eval{e}{(
        $env$
        [$e_1 \mapsto$ \eval{$p_1$}{$env$},
          $e \mapsto$ \eval{$p_1$}{$env$}]
      )} = \textit{true} : ~~\eqlabel{h3}}\\
    & $\eq{C-if}$ & (\comp{$I_2 \concat$
      (l, \lstinline'e = e_2;')  }{
      (
      $env$
      [$e_1 \mapsto$ \eval{$p_1$}{$env$},
        $e \mapsto$ \eval{$p_1$}{$env$}]
      )
    })(e) \\
    & $\eq{C-seq}$ & (\comp{\lstinline'e = e_2;'}{
      (\comp{$I_2$}{
        (
        $env$
        [$e_1 \mapsto$ \eval{$p_1$}{$env$},
          $e \mapsto$ \eval{$p_1$}{$env$}]
        )
      })
    })(e) \\
    & $\eq{h2}$ & (\comp{\lstinline'e = e_2;'}{
      (
      $env$
      [$e_1 \mapsto$ \eval{$p_1$}{$env$},
        $e \mapsto$ \eval{$p_1$}{$env$},
        $e_2 \mapsto$ \eval{$p_2$}{$env$}]
      )
    })(e) \\
    & $\eq{C-assign}$ & ($env$
                [$e_1 \mapsto$ \eval{$p_1$}{$env$},
                $e_2 \mapsto$ \eval{$p_2$}{$env$},
                  $e \mapsto$ \eval{$p_2$}{$env$}]
                ) (e) \\
    & = & \eval{$p_2$}{$env$} \\
    & = & true $\land$ \eval{$p_2$}{$env$} \\
    & $\eq{h3}$ & \eval{$p_1$}{$env$} $\land$ \eval{$p_2$}{$env$} \\
    & $\eq{P-and}$ & \eval{\lstinline'p1 \&\& p2'}{$env$} \\

    %% cas false
    \multicolumn{3}{l}{
      Quand \eval{e}{(
        $env$
        [$e_1 \mapsto$ \eval{$p_1$}{$env$},
          $e \mapsto$ \eval{$p_1$}{$env$}]
        )} = \textit{false} : ~~\eqlabel{h4}}\\
    & $\eq{C-if'}$ & (
    $env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}, $e \mapsto$ \eval{$p_1$}{$env$}]
    ) (e) \\
    & = & \eval{$p_1$}{$env$} \\
    & $\eq{h4}$ & false \\
    & = & false $\land$ \eval{$p_2$}{$env$} \\
    & $\eq{h4}$ & \eval{$p_1$}{$env$} $\land$ \eval{$p_2$}{$env$} \\
    & $\eq{P-and}$ & \eval{\lstinline'p1 \&\& p2'}{$env$} \\
  \end{tabular}
\end{proof}


\subsection{Forall Predicate}

{\myinference[FORALL]
  {
    (l, t_1 : \mathbb{Z}) \rulearrow (I_1, e_1) \\
    (l, t_2 : \mathbb{Z}) \rulearrow (I_2, e_2) \\
    (l, p) \rulearrow (I_3, e_3)
  }
  {
    \splitfrac {
      (l, \mbox{\lstinline'\\forall integer k; t_1 <= k <= t_2 ==> p'})
      \rulearrow
    } {
      \splitfrac {
        (I_1 \cdot I_2
        \cdot \underbracket{ (l, \mbox{\lstinline'int e = 1;'}) }_{i_1}
        \cdot
        \underbracket{
          (l, \Zinit \underline{\mbox{\lstinline'k = e_1;'}} ) }_{i_2}
      } {
        \cdot
        \underbracket{
          (l, \mbox{\lstinline'while('}
          \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
          \bopen
          I_3
          \cdot \underbracket{ \mbox{\lstinline'e = e_3;'} }_{i_4}
          \cdot
          \underbracket{ \underline{\mbox{\lstinline'k++'}} \semicolon }_{i_5}
          \bclose )
        }_{i_3}
        \cdot
        \underbracket{
          (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) }_{i_6}
        \cdot
        \underbracket{
          (l, \underline{\mbox{\lstinline'e_1'}} \Zclear \semicolon ) }_{i_7}
        \cdot
        \underbracket{
          (l, \underline{\mbox{\lstinline'e_2'}} \Zclear \semicolon ) }_{i_8},
        e)
      }
    }
  }
}~\\


Pour n'importe quel environnement $env$, nous prouvons que :

\eval{\lstinline'e'}{\comp{$I$}{$env$}} =
\eval{\lstinline'\\forall integer ; t_1 <= k <= t_2 ==> p'}{$env$}.


\begin{proof}
  ~\\
  Hypothèses : $t_1$, $t_2$ et $p$ sont correctement instrumentés et $t_1$ est
  inférieur ou égal à $t_2$ (dans le cas contraire la quantification $\forall$
  est trivialement vraie, ce qui ne nous intéresse pas).
  Pour tout environnement $env$ :

  \begin{tabular}{rclr}
    \eval{$e_1$}{\comp{$I_1$}{$env$}}
    & = & \eval{$t_1$}{$env$} & \eqlabel{h1} \\
    $\equiv$ \comp{$I_1$}{$env$}
    & = & $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$}] & \\
    \eval{$e_2$}{\comp{$I_2$}{$env$}}
    & = & \eval{$t_2$}{$env$} & \eqlabel{h2} \\
    $\equiv$ \comp{$I_2$}{$env$}
    & = & $env$[$e_2 \mapsto$ \eval{$t_2$}{$env$}] & \\
    \eval{$e_3$}{\comp{$I_3$}{$env$}}
    & = & \eval{$p$}{$env$} & \eqlabel{h3} \\
    $\equiv$ \comp{$I_3$}{$env$}
    & = & $env$[$e_3 \mapsto$ \eval{$p$}{$env$}] & \\
    \eval{$t_1$}{$env$} & $\le$ & \eval{$t_2$}{$env$} & \eqlabel{h4} \\
  \end{tabular}

  On doit prouver l'égalité suivante :

  \eval{\lstinline'e'}{\comp{$I$}{$env$}}
  $\eq{?}$ \eval{\lstinline'\\forall integer k; t_1 <= k <= t_2 ==> p'}{$env$}

  Développons le membre gauche :
  
  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\comp{$I$}{$env$}} &=& (\comp{$I$}{$env$})(e) \\
    & = &
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              (\comp{$\mbox{\lstinline'int e = 1;'}$}{
                (\comp{$I_2$}{(\comp{$I_1$}{$env$})})
              })
            })
          })
        })
      })
    })(e) \\
    & = &
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              (\comp{$\mbox{\lstinline'int e = 1;'}$}{
                (\comp{$I_2$}{($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$}])})
              })
            })
          })
        })
      })
    })(e) \\
    & = &
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              (\comp{$\mbox{\lstinline'int e = 1;'}$}{
                ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
                  $e_2 \mapsto$ \eval{$t_2$}{$env$}])
              })
            })
          })
        })
      })
    })(e) \\
    & = &
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
                $e_2 \mapsto$ \eval{$t_2$}{$env$},
                $e \mapsto$ 1])
            })
          })
        })
      })
    })(e) \\
    & = &
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
              $e_2 \mapsto$ \eval{$t_2$}{$env$},
              $e \mapsto$ 1,
              $k \mapsto$ \eval{$t_1$}{$env$}])
          })
        })
      })
    })(e) \\
  \end{tabular}

  Montrons que pour tout environnement $env$ :

  \begin{tabular}{rclr}
    \multicolumn{3}{c}{
      \eval{$t_1$}{$env$} $\le$ \eval{$k$}{$env$} $\le$ \eval{$t_2$}{$env$} + 1
    }
    & \eqlabel{inv-1} \\
    \eval{$e$}{$env$} &=&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}
    & \eqlabel{inv-2} \\
  \end{tabular}

  sont des invariants de la boucle
  $\mbox{\lstinline'while('}
  \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
  \bopen
  I_3
  \cdot \mbox{\lstinline'e = e_3;'}
  \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$.

  Montrons que ces invariants sont établis avant la première itération :

  Développons
  \eval{$t_1$}{$env$} $\le$ \eval{$k$}{$env$} $\le$ \eval{$t_2$}{$env$} + 1 :

  \begin{tabular}{rcl}
    \eval{$t_1$}{$env$} $\le$ \eval{$k$}{$env$} $\le$ \eval{$t_2$}{$env$} + 1
    &=& \eval{$t_1$}{$env$} $\le$ \eval{$t_1$}{$env$}
    $\le$ \eval{$t_2$}{$env$} + 1 \\
    &=& \eval{$t_1$}{$env$} $\le$ \eval{$t_2$}{$env$} + 1 \\
    &$\eq{h4}$& \textit{true} \\
  \end{tabular}

  Développons le membre droit de

  \eval{$e$}{$env$} =
  \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$} :

  \begin{tabular}{rcl}
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= k-1 ==> p'}{$env$} \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= t_1-1 ==> p'}{$env$} \\
    &=& \eval{\lstinline'\\forall integer z; \\false ==> p'}{$env$} \\
    &=& \eval{\lstinline'\\true'}{$env$} \\
    &=& 1 \\
    &=& \eval{$e$}{$env$} \\
  \end{tabular}

  Ces deux invariants sont établis avant la première itération, montrons qu'ils
  sont maintenus après chaque itération.
  On suppose donc que ces invariants sont vrais après une itération quelconque
  et sont donc des hypothèses.
  Soit $env$ l'environnement au début de l'itération.

  Prouvons que le premier invariant est maintenu après chaque itération :

  On a :

  \eval{$t_1$}{$env$} $\le$ \eval{$k$}{$env$} $\le$ \eval{$t_2$}{$env$} + 1
  
  Ce qui peut être réécrit en :

  \eval{$t_1 \le k \le t_2 + 1$}{$env$} = \textit{true}

  Montrons :

  \eval{$t_1 \le k \le t_2 + 1$}{\comp{
      $I_3 \cdot \mbox{\lstinline'e = e_3;'}
      \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
    }{
      ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
    }} = \textit{true}

  Développons le membre gauche :

  \begin{tabular}{p{6cm} p{.5cm} p{9cm}}
    \eval{$t_1 \le k \le t_2 + 1$}{\comp{
      $I_3 \cdot \mbox{\lstinline'e = e_3;'}
      \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
    }{
      ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
    }}
    &=&
    \eval{$t_1 \le k \le t_2 + 1$}{
      $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e_3 \mapsto$ \eval{\lstinline'p'}{$env$},
        $e \mapsto$ \eval{\lstinline'p'}{$env$},
        $k \mapsto$ (\eval{\lstinline'k'}{$env$})+1]
    } \\
    &=&
    \eval{$t_1 \le k+1 \le t_2 + 1$}{
      $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e_3 \mapsto$ \eval{\lstinline'p'}{$env$},
        $e \mapsto$ \eval{\lstinline'p'}{$env$},
        $k \mapsto$ (\eval{\lstinline'k'}{$env$})]
    } \\
    &=& \eval{$t_1 \le k+1 \le t_2 + 1$}{$env$} \\
    &=& \eval{$t_1 \le k+1$}{$env$} $\land$ \eval{$k+1 \le t_2 + 1$}{$env$} \\
    &=& \eval{$t_1 \le k+1$}{$env$} $\land$ \eval{$k \le t_2$}{$env$} \\
    &=& \textit{true} $\land$ \eval{$k \le t_2$}{$env$} \\
    \multicolumn{3}{c}{par hypothèse de récurrence} \\
    &=& \eval{$k \le t_2$}{$env$} \\
    &=& \eval{$k$}{$env$} $\le$ \eval{$t_2$}{$env$} \\
    &=& \eval{$k$}{$env$} $\le$ \eval{$e_2$}{$env$} \\
    &=& \eval{$k \le e_2$}{$env$} \\
    &=& \textit{true} \\
    \multicolumn{3}{c}{la condition de boucle est vraie sinon on n'exécuterait
      pas le code de la boucle} \\
  \end{tabular}
  
  Le premier invariant est donc maintenu après chaque itération.
  Prouvons maintenant que le deuxième invariant est maintenu après chaque
  itération.
  Développons le membre gauche :

  \begin{tabular}{p{6cm} p{.5cm} p{9cm}}
    (\comp{
      $I_3 \cdot \mbox{\lstinline'e = e_3;'}
      \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
    }{
      ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
    })(e)
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      \comp{\lstinline'e = e_3;'}{(
        \comp{$I_3$}{(
          $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e \mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}]
          )}
        )}
      )}
    )(e) \\
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      \comp{\lstinline'e = e_3;'}{(
        $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
          $e_2 \mapsto$ \eval{$t_2$}{$env$},
          $e \mapsto$
          \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$},
          $e_3 \mapsto$ \eval{\lstinline'p'}{$env$}]
        )}
      )}
    )(e) \\
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e_3 \mapsto$ \eval{\lstinline'p'}{$env$},
        $e \mapsto$ \eval{\lstinline'p'}{$env$}]
      )}
    )(e) \\
    &=&
    ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
      $e_2 \mapsto$ \eval{$t_2$}{$env$},
      $e_3 \mapsto$ \eval{\lstinline'p'}{$env$},
      $e \mapsto$ \eval{\lstinline'p'}{$env$},
      $k \mapsto$ (\eval{\lstinline'k'}{$env$})+1]
    )(e) \\
    &=& \eval{\lstinline'p'}{$env$} \\
    &=& \eval{\lstinline'e'}{$env$} $\land$ \eval{\lstinline'p'}{$env$} \\
    \multicolumn{3}{c}{\eval{\lstinline'e'}{$env$} est vrai sinon on
      n'exécuterait pas le code de la boucle} \\
  \end{tabular}

  Développons le membre droit :

  \begin{tabular}{p{5cm} p{.5cm} p{9cm}}
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{
      (\comp{
        $I_3 \cdot \mbox{\lstinline'e = e_3;'}
        \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
      }{
        ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
          $e_2 \mapsto$ \eval{$t_2$}{$env$},
          $e \mapsto$
          \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
      })
    }
    &=&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{
      ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e_3 \mapsto$ \eval{\lstinline'p'}{$env$},
        $e \mapsto$ \eval{\lstinline'p'}{$env$},
        $k \mapsto$ (\eval{\lstinline'k'}{$env$})+1])
    } \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z < k+1 ==> p'}{$env$} \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= k ==> p'}{$env$} \\
    &=&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$} \newline
    $\land$ \eval{\lstinline'\\forall integer z; z == k ==> p'}{$env$} \\
    &=&
    \eval{\lstinline'e'}{$env$}
    $\land$ \eval{\lstinline'\\forall integer z; z == k ==> p'}{$env$} \\
    &=& \eval{\lstinline'e'}{$env$} $\land$ \eval{\lstinline'p'}{$env$} \\
    \multicolumn{3}{c}{car \eval{\lstinline'p'}{$env$} est la valeur de $p$ pour
    le $k$ courant} \\
  \end{tabular}

  Le deuxième invariant est donc lui aussi maintenu après chaque itération.

  Maintenant que les deux invariants ont été prouvés, reprenons notre preuve :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\comp{$I$}{$env$}}
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
              $e_2 \mapsto$ \eval{$t_2$}{$env$},
              $e \mapsto$ 1,
              $k \mapsto$ \eval{$t_1$}{$env$}])
          })
        })
      })
    })(e) \\
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
        })
      })
    })(e) \\
  \end{tabular}

  Notons $env'$ = $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
    $e_2 \mapsto$ \eval{$t_2$}{$env$},
    $e\mapsto$
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}].

  Rappelons que
  \eval{$t_1$}{$env'$} $\le$ \eval{$k$}{$env'$} $\le$ \eval{$t_2$}{$env'$} + 1
  (premier invariant de boucle).

  On sait que la condition de boucle est fausse dans cet environnement $env'$ :

  \eval{\lstinline'k <= e_2 && e'}{$env'$} = \textit{false}

  Cas \eval{$k \le e_2$}{$env'$} = \textit{false}, soit
  \eval{$k > t_2$}{$env'$} = \textit{true} :
  
  On sait que \eval{$k > t_2$}{$env'$} et \eval{$k \le t_2+1$}{$env'$}, donc on
  a \eval{k}{$env'$} = \eval{$t_2+1$}{$env'$}.
  Avec cette nouvelle connaissance, on a :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\comp{$I$}{$env$}}
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
        })
      })
    })(e) \\
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < t_2+1 ==> p'}{$env$},
            $k \mapsto$ \eval{$t_2+1$}{$env$}])
        })
      })
    })(e) \\
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$},
            $k \mapsto$ \eval{$t_2+1$}{$env$}])
        })
      })
    })(e) \\
    &=&
    ($env$[$e\mapsto$
      \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$},
      $k \mapsto \bot$,
      $e_1 \mapsto \bot$,
      $e_2 \mapsto \bot$]) (e) \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$} \\
  \end{tabular}

  Cas \eval{$e$}{$env'$} = \textit{false} :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{$e$}{$env'$} = \textit{false}
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env'$}
    = \textit{false} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z < t_2+1 ==> p'}{$env'$}
    = \textit{false} \\
    \multicolumn{3}{c}{car \eval{$k$}{$env'$} $\le$ \eval{$t_2+1$}{$env'$}} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env'$}
    = \textit{false} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$}
    = \textit{false} \\
    \multicolumn{3}{c}{
      car (\eval{$t_1$}{$env$}) = (\eval{$t_1$}{$env'$}) et
      (\eval{$t_2$}{$env$}) = (\eval{$t_2$}{$env'$})
    } \\
  \end{tabular}

  Donc on a :
  \eval{$e$}{$env'$} $\equiv$
  \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$}.

  Reprenons la preuve principale dans le cas
  \eval{$e$}{$env'$} = \textit{false} :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\comp{$I$}{$env$}}
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$}])
        })
      })
    })(e) \\
    &=&
    ($env$[\eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$},
      $k \mapsto \bot$,
      $e_1 \mapsto \bot$,
      $e_2 \mapsto \bot$]) (e) \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$} \\
  \end{tabular}

  On a bien réussi à prouver que pour tout environnement $env$ :

  \eval{\lstinline'e'}{\comp{$I$}{$env$}}
  = \eval{\lstinline'\\forall integer k; t_1 <= k <= t_2 ==> p'}{$env$}
\end{proof}


\section{Annotation translation}
\label{sec:annotation-translation}
