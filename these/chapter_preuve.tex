
\chapter{Preuve de correction}
\label{sec:preuve-correction}


La grammaire des termes et prédicats de \eacsl \cite{\citeeacsl} autorisés dans
les annotations est détaillée en section~\ref{sec:grammar}, leur sémantique est
présentée en section~\ref{sec:semantics}.
Les propriétés que nous vérifions sont définies en section~\ref{sec:properties}.
Les sections~\ref{sec:term-translation}, \ref{sec:predicate-translation} et
\ref{sec:annotation-translation} détaillent la preuve de ces propriétés
respectivement sur les termes, sur les prédicats et sur les annotations.


\section{Grammaire du langage en entrée}
\label{sec:grammar}

\begin{figure}[tb]
  \begin{tabular}{lrl}
    \textit{unop} & ::= & \lstinline'-' $\mid$ \lstinline'*' $\mid$
    \lstinline'!' $\mid$ \lstinline'~' \\
    \textit{binop} & ::= & \lstinline'+' $\mid$ \lstinline'-' $\mid$
    \lstinline'*' $\mid$ \lstinline'/' $\mid$ \lstinline'%' $\mid$
    \lstinline'>' $\mid$ \lstinline'>=' $\mid$ \lstinline'<' $\mid$
    \lstinline'<=' $\mid$ \lstinline'==' $\mid$ \lstinline'!=' \\
    \textit{term} & ::= & \textit{cst} \\
    & $\mid$ & \textit{lvalue} \\
    & $\mid$ & \textit{unop} \textit{term} \\
    & $\mid$ & \textit{term} \textit{binop} \textit{term} \\
    & $\mid$ & \lstinline'\abs(' \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\sum(' \textit{term}$,$ \textit{term}$,$
    \lstinline'\lambda integer' \textit{id}$;$ \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\product(' \textit{term}, \textit{term},
    \lstinline'\lambda integer' \textit{id}; \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\numof(' \textit{term}, \textit{term},
    \lstinline'\lambda integer' \textit{id}; \textit{term} \lstinline')' \\
    & $\mid$ & \textit{term} \texttt{?} \textit{term} \texttt{:} \textit{term}\\
    & $\mid$ & \lstinline'\old(' \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\null' \\
    & $\mid$ & \lstinline'(' \textit{type} \lstinline')' \textit{term} \\
  \end{tabular}
  \caption{Grammaire des termes \eacsl}
  \label{fig:gram-term}
\end{figure}

\begin{figure}[tb]
  \begin{tabular}{lrl}
    \textit{relation} & ::= & \lstinline'>' $\mid$ \lstinline'>=' $\mid$
    \lstinline'<' $\mid$ \lstinline'<=' $\mid$ \lstinline'==' $\mid$
    \lstinline'!=' \\
    \textit{pred} & ::= & \lstinline'\true' \\
    & $\mid$ & \lstinline'\false' \\
    & $\mid$ & \lstinline'\valid(' \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\forall integer' \textit{id};
    \textit{term} <= \textit{id} <= \textit{term}
    \lstinline'==>' \textit{pred} \\
    & $\mid$ & \lstinline'\exists integer' \textit{id};
    \textit{term} <= \textit{id} <= \textit{term}
    \lstinline'&&' \textit{pred} \\
    & $\mid$ & ! \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'&&' \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'||' \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'==>' \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'<==>' \textit{pred} \\
    & $\mid$ & \textit{term} ? \textit{pred} : \textit{pred} \\
    & $\mid$ & \textit{term} \textit{relation} \textit{term} \\
  \end{tabular}
  \caption{Grammaire des prédicats \eacsl}
  \label{fig:gram-pred}
\end{figure}

\begin{figure}[tb]
  \begin{tabular}{lrl}
    \textit{assert} & ::= & \lstinline'assert' \textit{pred} \\
    \textit{requires} & ::= & \lstinline'requires' \textit{pred} \\
    \textit{typically} & ::= & \lstinline'typically' \textit{pred} \\
    \textit{ensures} & ::= & \lstinline'ensures' \textit{pred} \\
    \textit{assigns} & ::= & \lstinline'assigns' \textit{term}$^{+}$ \\
    \textit{loop-invariant} & ::= & \lstinline'loop invariant' \textit{pred} \\
    \textit{loop-variant} & ::= & \lstinline'loop variant' \textit{term} \\
    \textit{loop-assigns} & ::= & \lstinline'loop assigns' \textit{term}$^{+}$
  \end{tabular}
  \caption{Grammaire des annotations \eacsl}
  \label{fig:gram-annot}
\end{figure}

\begin{figure}[tb]
  \begin{tabular}{lrl}
    \textit{exp} & ::= & \textit{cst} \\
    & $\mid$ & \textit{lvalue} \\
    & $\mid$ & \textit{unop} \textit{exp} \\
    & $\mid$ & \textit{exp} \textit{binop} \textit{exp} \\
    & $\mid$ & \lstinline'(' \textit{type} \lstinline')' \textit{term} \\
    \textit{instr} & ::= & ; \\
    & $\mid$ & \textit{lval} \lstinline'=' \textit{exp}; \\
    & $\mid$ & \textit{id} (\textit{exp}$^{*}$); \\
    & $\mid$ & \textit{lval} \lstinline'=' \textit{id} (\textit{exp}$^{*}$); \\
    & $\mid$ & \lstinline'return' \textit{exp}; \\
    & $\mid$ & \lstinline'if(' \textit{exp} \lstinline')'
    $\bopen$ \textit{instr}$^*$ $\bclose$
    \lstinline'else' $\bopen$ \textit{instr}$^*$ $\bclose$ \\
    \textit{loop-instr} & ::= & \lstinline'while(' \textit{exp} \lstinline')'
    $\bopen$ \textit{instr}$^*$ $\bclose$ \\
    \textit{annot-instr} & ::= & \lstinline'/*@' \textit{assert} \lstinline'*/'
    \textit{instr} \\
    & $\mid$ & \lstinline'/*@' \textit{loop-invariant} \textit{loop-variant}
    \textit{loop-assigns} \lstinline'*/' \textit{loop-instr} \\
    \textit{function} & ::= & \lstinline'/*@' \textit{requires} \textit{assigns}
    \textit{ensures} \lstinline'*/' \textit{type} \textit{id}
    (\textit{type} \textit{lvalue}$^{*}$)
    $\bopen$ \textit{decl}$^{*}$ \textit{annot-instr}$^{*}$
    $\bclose$
  \end{tabular}
  \caption{Grammaire des expressions et instructions C}
  \label{fig:gram-c}
\end{figure}


\section{Notations}
\label{sec:notations}


Nous définissons les fonctions et symboles qui sont utilisés dans la suite du
chapitre.

\begin{notation}
  ~
  \begin{itemize}
  \item $x$, $y$ et $z$ sont des identificateurs de variable
  \item $v$ est une valeur
  \item $\bot$ est une valeur spéciale qui signifie qu'une variable n'est pas
    ou plus initialisée
  \end{itemize}
\end{notation}


\subsection{Environnements}

Un environnement $env$ est une fonction partielle $env : ID \mapsto VAL$ des
identificateurs de variables dans le domaine sémantique qui des valeurs
possibles.

Le domaine des valeurs est défini comme l'union des types logiques que peuvent
prendre les termes et prédicats \eacsl et des types C que peuvent prendre les
variables C :
$VAL = \mathbb{Z}~\cup~\mathbb{B}~\cup~\mbox{\lstinline'int'}~\cup~\ldots$

La notation $env$[$x \mapsto v$] est désigne un nouvel environnement,
correspondant à l'environnement $env$ auquel la relation $(x, v)$ a été ajoutée,
ce qui signifie que la variable $x$ a la valeur $v$ dans ce nouvel
environnement.

L'accès à la valeur d'une variable dans un environnement est défini par :
\begin{itemize}
\item ($env$[$x \mapsto v$])($x$) = $v$
\item ($env$[$x \mapsto v$])($y$) = $env$($y$) si $x \neq y$
\end{itemize}


\subsection{Sémantique Dénotationnelle des Expressions}

La sémantique dénotationnelle des expressions C et des termes et prédicats
\eacsl est exprimée avec la fonction
$\mathcal{E} : EXP \mapsto ENV \mapsto VAL$.
Cette fonction associe à une expression C (ou un terme ou prédicat \eacsl) dans
un environnement une valeur, à condition que cette expression ne génère pas
d'effet de bord, ce qui est le cas sur le langage considéré après normalisation
du code par \framac.
Une expression C \underline{soulignée} utilise la sémantique des entiers non
bornés.

La sémantique des expressions C et des termes \eacsl est définie ci-dessous :

\begin{tabular}{rclr}
  \eval{cst}{$env$} &=& cst & \eqlabel{E-cst} \\
  \eval{lvalue}{$env$} &=& $env$(lvalue) & \eqlabel{E-lval} \\
  \eval{\lstinline|unop x|}{$env$}
  &=& \lstinline|unop| (\eval{\lstinline|x|}{$env$}) & \eqlabel{E-unop} \\
  \eval{\lstinline|x binop y|}{$env$}
  &=& (\eval{\lstinline|x|}{$env$}) \lstinline|binop|
  (\eval{\lstinline|y|}{$env$}) & \eqlabel{E-binop} \\
  \eval{\lstinline'\\abs(t)'}{$env$} &=&
  $\lvert$ \eval{\lstinline't'}{$env$} $\rvert$ & \eqlabel{E-abs} \\
  \eval{\lstinline'\\sum(x, y, \\lambda integer k; z)'}{$env$} &=&
  $\sum_{k = \mbox{\eval{\lstinline'x'}{$env$}}}^{\mbox{\eval{\lstinline'y'}{$env$}}} \mbox{\eval{\lstinline'z'}{$env$}}$
  & \eqlabel{E-sum} \\
  \eval{\lstinline'\\product(x, y, \\lambda integer k; z)'}{$env$} &=&
  $\prod_{k = \mbox{\eval{\lstinline'x'}{$env$}}}^{\mbox{\eval{\lstinline'y'}{$env$}}} \mbox{\eval{\lstinline'z'}{$env$}}$
  & \eqlabel{E-prod} \\
  \eval{\lstinline'\\numof(x, y, \\lambda integer k; z)'}{$env$} &=&
  $\sum_{k = \mbox{\eval{\lstinline'x'}{$env$}}}^{\mbox{\eval{\lstinline'y'}{$env$}}} \mbox{\eval{\lstinline'z ? 1 : 0'}{$env$}}$
  & \eqlabel{E-num} \\
  \eval{\lstinline'x ? y : z'}{$env$} &=& \eval{\lstinline'y'}{$env$}
  si (\eval{\lstinline'x'}{$env$}) $\neq$ 0 & \eqlabel{E-tif} \\
  &=& \eval{\lstinline'z'}{$env$}
  si (\eval{\lstinline'x'}{$env$}) = 0 & \eqlabel{E-tif'} \\
  \eval{\lstinline'\\old(t)'}{$env$} &=&
  \eval{\lstinline't'}{($env$ en début de fonction)}
  & \eqlabel{E-old} \\
  \eval{\lstinline'\\null'}{$env$} &=& \lstinline'NULL' & \eqlabel{E-null} \\
  \eval{\lstinline|(type) x|}{$env$}
  &=& \lstinline|(type)| (\eval{\lstinline|x|}{$env$}) & \eqlabel{E-cast} \\
\end{tabular}

La sémantique des prédicats \eacsl est définie ci-dessous :

\begin{tabular}{rclr}
  \eval{\lstinline'\\true'}{$env$} &=& \textit{true} & \eqlabel{P-true} \\
  \eval{\lstinline'\\false'}{$env$} &=& \textit{false} & \eqlabel{P-false} \\
  \eval{\lstinline'\\valid(t)'}{$env$} &=&
  "\lstinline'*t' est défini dans $env$" & \eqlabel{P-valid} \\
  \eval{\lstinline'\\forall integer k; a <= k <= b ==> y'}{$env$} &=&
  $\forall_{k=\mbox{\eval{\lstinline'a'}{$env$}}}^{\mbox{\eval{\lstinline'b'}{$env$}}} \mbox{\eval{\lstinline'y'}{$env$}}$
  & \eqlabel{P-forall} \\
  \eval{\lstinline'\\exists integer k; a <= k <= b \&\& y'}{$env$} &=&
  $\exists_{k=\mbox{\eval{\lstinline'a'}{$env$}}}^{\mbox{\eval{\lstinline'b'}{$env$}}} \mbox{\eval{\lstinline'y'}{$env$}}$
  & \eqlabel{P-exists} \\
  \eval{\lstinline'\! p'}{$env$} &=& $\lnot$ (\eval{\lstinline'p'}{$env$})
  & \eqlabel{P-not} \\
  \eval{\lstinline'p \&\& q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\land$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-and} \\
  \eval{\lstinline'p || q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\lor$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-or} \\
  \eval{\lstinline'p ==> q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\Rightarrow$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-impl} \\
  \eval{\lstinline'p <==> q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\Leftrightarrow$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-eq} \\
  \eval{\lstinline'x ? y : z'}{$env$} &=& \eval{\lstinline'y'}{$env$}
  si \eval{\lstinline'x'}{$env$} & \eqlabel{P-pif} \\
  &=& \eval{\lstinline'z'}{$env$} sinon & \eqlabel{P-pif'} \\
  \eval{\lstinline|x rel y|}{$env$}
  &=& (\eval{\lstinline|x|}{$env$}) \lstinline|rel|
  (\eval{\lstinline|y|}{$env$}) & \eqlabel{P-rel} \\
\end{tabular}


\subsection{Sémantique Dénotationnelle des Instructions}

La sémantique dénotationnelle des instructions C est exprimée avec la fonction
$\mathcal{C} : INSTR \mapsto ENV \mapsto ENV$.
Cette fonction associe à une instruction $i$ et un environnement $env$ un nouvel
environnement qui prend en compte les modifications effectuées par $i$ dans
l'environnement $env$.
Une instruction \underline{soulignée} utilise la sémantique des entiers non
bornés.

La sémantique des instructions C est définie ci-dessous :

\begin{tabular}{rclr}
  \comp{A $\cdot$ B}{$env$} &=& \comp{B}{(\comp{A}{$env$})} & \eqlabel{C-seq} \\
  \comp{\lstinline|a = b;|}{$env$}
  &=& $env$[$a \mapsto$ \eval{b}{$env$}] \scriptsize{(arith. bornée)}
  & \eqlabel{C-assign} \\
  \comp{\lstinline|if(x) A else B|}{$env$}
  &=& \comp{A}{$env$} si \eval{x}{$env$} & \eqlabel{C-if} \\
  &=& \comp{B}{$env$} sinon & \eqlabel{C-if'} \\
  \comp{\lstinline|while(x) A|}{$env$}
  &=& \comp{\lstinline|while(x) A|}{(\comp{A}{$env$})}
  si \eval{x}{$env$} & \eqlabel{C-while} \\
  &=& $env$ sinon & \eqlabel{C-while'} \\ \\

  \comp{$\Zinit$ \underline{\lstinline|a = b|} $\semicolon$}{$env$}
  &=& $env$[$a \mapsto$ \eval{b}{$env$}] \scriptsize{(arith. non bornée)}
  & \eqlabel{C-assign'} \\
  \multicolumn{4}{c}{la variable entière (GMP) \lstinline'a' est allouée et
    on lui affecte la valeur de \lstinline'b'} \\ \\
  \comp{\underline{\lstinline|a|} $\Zclear \semicolon$}{$env$}
  &=& $env$[$a \mapsto \bot$] & \eqlabel{C-unset} \\
  \multicolumn{4}{c}{la variable entière (GMP) \lstinline'a' est désallouée} \\
\end{tabular}


\subsection{Définition des listes d'insertions de code}

Une insertion de code est un couple $(LABEL \times INSTR)$.
Une liste (ou séquence) d'insertions de code résulte de la traduction d'un
terme, prédicat ou d'une annotation \eacsl.

Par exemple, la règle suivante montre la séquence d'insertions de code $I$
générée pour la traduction du prédicat \lstinline'p_1 && p_2' :

{\myinference[AND]
  { (l, p_1) \rulearrow (I_1, e_1) \\ (l, p_2) \rulearrow (I_2, e_2) }
  { (l, \mbox{\lstinline'p_1 && p_2'}) \rulearrow
    (
    \underbracket{
      I_1 \cdot
      \underbracket{ (l, \mbox{\lstinline'int e = e_1;'}) }_{i_1}
      \cdot
      \underbracket{ (l, \mbox{\lstinline'if(e)'})
        \bopen
        I_2 \cdot
        \underbracket{ (l, \mbox{\lstinline'e = e_2;'}) }_{i_2}
        \bclose }_{i_3}
      }_{I},
    e) }
}~\\

Dans cet exemple, $i_1$, $i_2$ et $i_3$ sont des insertions de code, tandis que
$I_1$, $I_2$ et $I$ sont des séquences d'insertions de code.


\section{Properties}
\label{sec:properties}

\begin{notation}
  Soit $P$ un programme C correct syntaxiquement selon la grammaire définie dans
  les figures~\ref{fig:gram-term}, \ref{fig:gram-pred}, \ref{fig:gram-annot}
  et~\ref{fig:gram-c}.
  Soit $P'$ le programme instrumenté obtenu après traduction du programme $P$.
\end{notation}



\begin{theorem}
  Si une annotation $a$ est invalide, alors l'exécution dans le programme $P$
  des instructions obtenues par instrumentation provoque une erreur dans le
  programme instrumenté $P'$.
  \commentGP{une propriété pour chaque type d'annotation ?}
\end{theorem}

\begin{theorem}
  Si toutes les annotations d'un programme $P$ sont valides, alors $P$ et $P'$
  (obtenu après instrumentation de $P$) ont la même sémantique, et le même
  comportement est observable à l'exécution.
\end{theorem}



\section{Term translation}
\label{sec:term-translation}


\begin{lemma}\label{lem:term-correct}
  Soit $t$ : $\tau$ un terme de type $\tau$, qui se traduit en $(I, t')$.
  La traduction est correcte si et seulement si, pour n'importe quel
  environnement $env$ :

  \eval{$t'$}{\comp{$I$}{$env$}} = \eval{$t$}{$env$}.
\end{lemma}


\subsection{Constant Term}

{\myinference[CST]
  {}
  { (l, v : \mathbb{Z}) \rulearrow
    ((l, \Zinit\underline{\mbox{\lstinline'x = v;'}}), x) }
}

Pour n'importe quel environnement $env$, nous prouvons que :

\eval{x}{\comp{$\Zinit$\underline{\lstinline'x = v;'}}{$env$}}
= \eval{v}{$env$}.


\begin{proof}
  ~\\
  \begin{tabular}{rclr}
    \eval{x}{\comp{$\Zinit$\underline{\lstinline'x = v;'}}{$env$}}
    & $\eq{C-assign'}$ & \eval{x}{($env$[$x \mapsto$ \eval{v}{$env$}])} & \\
    & $\eq{E-lval}$ & \eval{v}{$env$} &
  \end{tabular}
\end{proof}


\section{Predicate translation}
\label{sec:predicate-translation}


\begin{lemma}\label{lem:pred-correct}
  Soit $p$ un prédicat qui se traduit en $(I, p')$.
  La traduction est correct si et seulement si, pour n'importe quel
  environnement $env$ :

  \eval{$p'$}{\comp{$I$}{$env$}} = \eval{$p$}{$env$}.
\end{lemma}


\subsection{And Predicate}

{\myinference[AND]
  { (l, p_1) \rulearrow (I_1, e_1) \\ (l, p_2) \rulearrow (I_2, e_2) }
  { (l, \mbox{\lstinline'p_1 && p_2'}) \rulearrow
    (
    \underbracket{
      I_1 \cdot
      \underbracket{ (l, \mbox{\lstinline'int e = e_1;'}) }_{i_1}
      \cdot
      \underbracket{ (l, \mbox{\lstinline'if(e)'})
        \bopen
        I_2 \cdot
        \underbracket{ (l, \mbox{\lstinline'e = e_2;'}) }_{i_2}
        \bclose }_{i_3}
      }_{I},
    e) }
}~\\

Pour n'importe quel environnement $env$, nous prouvons que :

\eval{\lstinline'e'}{\comp{$I$}{$env$}} = \eval{\lstinline'p1 && p2'}{$env$}.


\begin{proof}
  ~\\
  Hypothèses : $p_1$ et $p_2$ sont correctement instrumentés.
  Pour tout environnement $env$ :

  \begin{tabular}{rclr}
    \eval{$e_1$}{\comp{$I_1$}{$env$}}
    & = & \eval{$p_1$}{$env$} & \eqlabel{h1} \\
    $\equiv$ \comp{$I_1$}{$env$}
    & = & $env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}] & \\
    \eval{$e_2$}{\comp{$I_2$}{$env$}}
    & = & \eval{$p_2$}{$env$} & \eqlabel{h2} \\
    $\equiv$ \comp{$I_2$}{$env$}
    & = & $env$[$e_2 \mapsto$ \eval{$p_2$}{$env$}] & \\
  \end{tabular}

  On doit prouver l'égalité suivante :

  \eval{\lstinline'e'}{\comp{$I$}{$env$}}
  $\eq{?}$ \eval{\lstinline'p1 && p2'}{$env$}

  Développons le membre gauche :
  
  \begin{tabular}{p{3cm} p{.5cm} p{12cm}}
    \eval{\lstinline'e'}{\comp{$I$}{$env$}}
    & = & (\comp{$I$}{$env$})(e) \\
    & $\eq{C-seq}$ & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
      (l, \lstinline'e = e_2;') $\bclose$ }{
      (\comp{\lstinline'int e = e1;'}{
        (\comp{$I_1$}{$env$})
      })
    })(e) \\
    & $\eq{h1}$ & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
      (l, \lstinline'e = e_2;') $\bclose$ }{
      (\comp{\lstinline'int e = e1;'}{
        ($env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}])
      })
    })(e) \\
    %% & = & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
    %%   (l, \lstinline'e = e_2;') $\bclose$ }{
    %%   (
    %%   ($env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}])[$e \mapsto$
    %%     \eval{$e_1$}{$env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}]}]
    %%   )
    %% })(e) \\
    & $\eq{C-assign}$ & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
      (l, \lstinline'e = e_2;') $\bclose$ }{
      (
      $env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}, $e \mapsto$ \eval{$p_1$}{$env$}]
      )
    })(e) \\

    %% cas true
    \multicolumn{3}{l}{
      Quand \eval{e}{(
        $env$
        [$e_1 \mapsto$ \eval{$p_1$}{$env$},
          $e \mapsto$ \eval{$p_1$}{$env$}]
      )} = \textit{true} : ~~\eqlabel{h3}}\\
    & $\eq{C-if}$ & (\comp{$I_2 \concat$
      (l, \lstinline'e = e_2;')  }{
      (
      $env$
      [$e_1 \mapsto$ \eval{$p_1$}{$env$},
        $e \mapsto$ \eval{$p_1$}{$env$}]
      )
    })(e) \\
    & $\eq{C-seq}$ & (\comp{\lstinline'e = e_2;'}{
      (\comp{$I_2$}{
        (
        $env$
        [$e_1 \mapsto$ \eval{$p_1$}{$env$},
          $e \mapsto$ \eval{$p_1$}{$env$}]
        )
      })
    })(e) \\
    & $\eq{h2}$ & (\comp{\lstinline'e = e_2;'}{
      (
      $env$
      [$e_1 \mapsto$ \eval{$p_1$}{$env$},
        $e \mapsto$ \eval{$p_1$}{$env$},
        $e_2 \mapsto$ \eval{$p_2$}{$env$}]
      )
    })(e) \\
    & $\eq{C-assign}$ & ($env$
                [$e_1 \mapsto$ \eval{$p_1$}{$env$},
                $e_2 \mapsto$ \eval{$p_2$}{$env$},
                  $e \mapsto$ \eval{$p_2$}{$env$}]
                ) (e) \\
    & = & \eval{$p_2$}{$env$} \\
    & = & true $\land$ \eval{$p_2$}{$env$} \\
    & $\eq{h3}$ & \eval{$p_1$}{$env$} $\land$ \eval{$p_2$}{$env$} \\
    & $\eq{P-and}$ & \eval{\lstinline'p1 \&\& p2'}{$env$} \\

    %% cas false
    \multicolumn{3}{l}{
      Quand \eval{e}{(
        $env$
        [$e_1 \mapsto$ \eval{$p_1$}{$env$},
          $e \mapsto$ \eval{$p_1$}{$env$}]
        )} = \textit{false} : ~~\eqlabel{h4}}\\
    & $\eq{C-if'}$ & (
    $env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}, $e \mapsto$ \eval{$p_1$}{$env$}]
    ) (e) \\
    & = & \eval{$p_1$}{$env$} \\
    & $\eq{h4}$ & false \\
    & = & false $\land$ \eval{$p_2$}{$env$} \\
    & $\eq{h4}$ & \eval{$p_1$}{$env$} $\land$ \eval{$p_2$}{$env$} \\
    & $\eq{P-and}$ & \eval{\lstinline'p1 \&\& p2'}{$env$} \\
  \end{tabular}
\end{proof}


\subsection{Forall Predicate}

{\myinference[FORALL]
  {
    (l, t_1 : \mathbb{Z}) \rulearrow (I_1, e_1) \\
    (l, t_2 : \mathbb{Z}) \rulearrow (I_2, e_2) \\
    (l, p) \rulearrow (I_3, e_3)
  }
  {
    \splitfrac {
      (l, \mbox{\lstinline'\\forall integer k; t_1 <= k <= t_2 ==> p'})
      \rulearrow
    } {
      \splitfrac {
        (I_1 \cdot I_2
        \cdot \underbracket{ (l, \mbox{\lstinline'int e = 1;'}) }_{i_1}
        \cdot
        \underbracket{
          (l, \Zinit \underline{\mbox{\lstinline'k = e_1;'}} ) }_{i_2}
      } {
        \cdot
        \underbracket{
          (l, \mbox{\lstinline'while('}
          \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
          \bopen
          I_3
          \cdot \underbracket{ \mbox{\lstinline'e = e_3;'} }_{i_4}
          \cdot
          \underbracket{ \underline{\mbox{\lstinline'k++'}} \semicolon }_{i_5}
          \bclose )
        }_{i_3}
        \cdot
        \underbracket{
          (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon ) }_{i_6}
        \cdot
        \underbracket{
          (l, \underline{\mbox{\lstinline'e_1'}} \Zclear \semicolon ) }_{i_7}
        \cdot
        \underbracket{
          (l, \underline{\mbox{\lstinline'e_2'}} \Zclear \semicolon ) }_{i_8},
        e)
      }
    }
  }
}~\\


Pour n'importe quel environnement $env$, nous prouvons que :

\eval{\lstinline'e'}{\comp{$I$}{$env$}} =
\eval{\lstinline'\\forall integer ; t_1 <= k <= t_2 ==> p'}{$env$}.


\begin{proof}
  ~\\
  Hypothèses : $t_1$, $t_2$ et $p$ sont correctement instrumentés et $t_1$ est
  inférieur ou égal à $t_2$ (dans le cas contraire la quantification $\forall$
  est trivialement vraie, ce qui ne nous intéresse pas).
  Pour tout environnement $env$ :

  \begin{tabular}{rclr}
    \eval{$e_1$}{\comp{$I_1$}{$env$}}
    & = & \eval{$t_1$}{$env$} & \eqlabel{h1} \\
    $\equiv$ \comp{$I_1$}{$env$}
    & = & $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$}] & \\
    \eval{$e_2$}{\comp{$I_2$}{$env$}}
    & = & \eval{$t_2$}{$env$} & \eqlabel{h2} \\
    $\equiv$ \comp{$I_2$}{$env$}
    & = & $env$[$e_2 \mapsto$ \eval{$t_2$}{$env$}] & \\
    \eval{$e_3$}{\comp{$I_3$}{$env$}}
    & = & \eval{$p$}{$env$} & \eqlabel{h3} \\
    $\equiv$ \comp{$I_3$}{$env$}
    & = & $env$[$e_3 \mapsto$ \eval{$p$}{$env$}] & \\
    \eval{$t_1$}{$env$} & $\le$ & \eval{$t_2$}{$env$} & \eqlabel{h4} \\
  \end{tabular}

  On doit prouver l'égalité suivante :

  \eval{\lstinline'e'}{\comp{$I$}{$env$}}
  $\eq{?}$ \eval{\lstinline'\\forall integer k; t_1 <= k <= t_2 ==> p'}{$env$}

  Développons le membre gauche :
  
  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\comp{$I$}{$env$}} &=& (\comp{$I$}{$env$})(e) \\
    & = &
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              (\comp{$\mbox{\lstinline'int e = 1;'}$}{
                (\comp{$I_2$}{(\comp{$I_1$}{$env$})})
              })
            })
          })
        })
      })
    })(e) \\
    & = &
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              (\comp{$\mbox{\lstinline'int e = 1;'}$}{
                (\comp{$I_2$}{($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$}])})
              })
            })
          })
        })
      })
    })(e) \\
    & = &
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              (\comp{$\mbox{\lstinline'int e = 1;'}$}{
                ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
                  $e_2 \mapsto$ \eval{$t_2$}{$env$}])
              })
            })
          })
        })
      })
    })(e) \\
    & = &
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            (\comp{$\Zinit \underline{\mbox{\lstinline'k = e_1;'}}$}{
              ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
                $e_2 \mapsto$ \eval{$t_2$}{$env$},
                $e \mapsto$ 1])
            })
          })
        })
      })
    })(e) \\
    & = &
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
              $e_2 \mapsto$ \eval{$t_2$}{$env$},
              $e \mapsto$ 1,
              $k \mapsto$ \eval{$t_1$}{$env$}])
          })
        })
      })
    })(e) \\
  \end{tabular}

  Montrons que pour tout environnement $env$ :

  \begin{tabular}{rclr}
    \multicolumn{3}{c}{
      \eval{$t_1$}{$env$} $\le$ \eval{$k$}{$env$} $\le$ \eval{$t_2$}{$env$} + 1
    }
    & \eqlabel{inv-1} \\
    \eval{$e$}{$env$} &=&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}
    & \eqlabel{inv-2} \\
  \end{tabular}

  sont des invariants de la boucle
  $\mbox{\lstinline'while('}
  \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
  \bopen
  I_3
  \cdot \mbox{\lstinline'e = e_3;'}
  \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$.

  Montrons que ces invariants sont établis avant la première itération :

  Développons
  \eval{$t_1$}{$env$} $\le$ \eval{$k$}{$env$} $\le$ \eval{$t_2$}{$env$} + 1 :

  \begin{tabular}{rcl}
    \eval{$t_1$}{$env$} $\le$ \eval{$k$}{$env$} $\le$ \eval{$t_2$}{$env$} + 1
    &=& \eval{$t_1$}{$env$} $\le$ \eval{$t_1$}{$env$}
    $\le$ \eval{$t_2$}{$env$} + 1 \\
    &=& \eval{$t_1$}{$env$} $\le$ \eval{$t_2$}{$env$} + 1 \\
    &$\eq{h4}$& \textit{true} \\
  \end{tabular}

  Développons le membre droit de

  \eval{$e$}{$env$} =
  \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$} :

  \begin{tabular}{rcl}
    \multicolumn{3}{l}{
      \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}
    } \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= k-1 ==> p'}{$env$} \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= t_1-1 ==> p'}{$env$} \\
    &=& \eval{\lstinline'\\forall integer z; \\false ==> p'}{$env$} \\
    &=& \eval{\lstinline'\\true'}{$env$} \\
    &=& 1 \\
    &=& \eval{$e$}{$env$} \\
  \end{tabular}

  Ces deux invariants sont établis avant la première itération, montrons qu'ils
  sont maintenus après chaque itération.
  On suppose donc que ces invariants sont vrais après une itération quelconque
  et sont donc des hypothèses.
  Soit $env$ l'environnement au début de l'itération.

  Prouvons que le premier invariant est maintenu après chaque itération :

  On a :

  \eval{$t_1$}{$env$} $\le$ \eval{$k$}{$env$} $\le$ \eval{$t_2$}{$env$} + 1
  
  Ce qui peut être réécrit en :

  \eval{$t_1 \le k \le t_2 + 1$}{$env$} = \textit{true}

  Montrons :

  \eval{$t_1 \le k \le t_2 + 1$}{\comp{
      $I_3 \cdot \mbox{\lstinline'e = e_3;'}
      \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
    }{
      ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
    }} = \textit{true}

  Développons le membre gauche :

  \begin{tabular}{p{6cm} p{.5cm} p{9cm}}
    \eval{$t_1 \le k \le t_2 + 1$}{\comp{
      $I_3 \cdot \mbox{\lstinline'e = e_3;'}
      \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
    }{
      ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
    }}
    &=&
    \eval{$t_1 \le k \le t_2 + 1$}{
      $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e_3 \mapsto$ \eval{\lstinline'p'}{$env$},
        $e \mapsto$ \eval{\lstinline'p'}{$env$},
        $k \mapsto$ (\eval{\lstinline'k'}{$env$})+1]
    } \\
    &=&
    \eval{$t_1 \le k+1 \le t_2 + 1$}{
      $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e_3 \mapsto$ \eval{\lstinline'p'}{$env$},
        $e \mapsto$ \eval{\lstinline'p'}{$env$},
        $k \mapsto$ (\eval{\lstinline'k'}{$env$})]
    } \\
    &=& \eval{$t_1 \le k+1 \le t_2 + 1$}{$env$} \\
    &=& \eval{$t_1 \le k+1$}{$env$} $\land$ \eval{$k+1 \le t_2 + 1$}{$env$} \\
    &=& \eval{$t_1 \le k+1$}{$env$} $\land$ \eval{$k \le t_2$}{$env$} \\
    &=& \textit{true} $\land$ \eval{$k \le t_2$}{$env$} \\
    \multicolumn{3}{c}{par hypothèse de récurrence} \\
    &=& \eval{$k \le t_2$}{$env$} \\
    &=& \eval{$k$}{$env$} $\le$ \eval{$t_2$}{$env$} \\
    &=& \eval{$k$}{$env$} $\le$ \eval{$e_2$}{$env$} \\
    &=& \eval{$k \le e_2$}{$env$} \\
    &=& \textit{true} \\
    \multicolumn{3}{c}{la condition de boucle est vraie sinon on n'exécuterait
      pas le code de la boucle} \\
  \end{tabular}
  
  Le premier invariant est donc maintenu après chaque itération.
  Prouvons maintenant que le deuxième invariant est maintenu après chaque
  itération.
  Développons le membre gauche :

  \begin{tabular}{p{6cm} p{.5cm} p{9cm}}
    (\comp{
      $I_3 \cdot \mbox{\lstinline'e = e_3;'}
      \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
    }{
      ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e \mapsto$
        \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
    })(e)
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      \comp{\lstinline'e = e_3;'}{(
        \comp{$I_3$}{(
          $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e \mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}]
          )}
        )}
      )}
    )(e) \\
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      \comp{\lstinline'e = e_3;'}{(
        $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
          $e_2 \mapsto$ \eval{$t_2$}{$env$},
          $e \mapsto$
          \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$},
          $e_3 \mapsto$ \eval{\lstinline'p'}{$env$}]
        )}
      )}
    )(e) \\
    &=&
    (\comp{$\underline{\mbox{\lstinline'k++'}} \semicolon$}{(
      $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e_3 \mapsto$ \eval{\lstinline'p'}{$env$},
        $e \mapsto$ \eval{\lstinline'p'}{$env$}]
      )}
    )(e) \\
    &=&
    ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
      $e_2 \mapsto$ \eval{$t_2$}{$env$},
      $e_3 \mapsto$ \eval{\lstinline'p'}{$env$},
      $e \mapsto$ \eval{\lstinline'p'}{$env$},
      $k \mapsto$ (\eval{\lstinline'k'}{$env$})+1]
    )(e) \\
    &=& \eval{\lstinline'p'}{$env$} \\
    &=& \eval{\lstinline'e'}{$env$} $\land$ \eval{\lstinline'p'}{$env$} \\
    \multicolumn{3}{c}{\eval{\lstinline'e'}{$env$} est vrai sinon on
      n'exécuterait pas le code de la boucle} \\
  \end{tabular}

  Développons le membre droit :

  \begin{tabular}{p{5cm} p{.5cm} p{9cm}}
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{
      (\comp{
        $I_3 \cdot \mbox{\lstinline'e = e_3;'}
        \cdot \underline{\mbox{\lstinline'k++'}} \semicolon$
      }{
        ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
          $e_2 \mapsto$ \eval{$t_2$}{$env$},
          $e \mapsto$
          \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
      })
    }
    &=&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{
      ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
        $e_2 \mapsto$ \eval{$t_2$}{$env$},
        $e_3 \mapsto$ \eval{\lstinline'p'}{$env$},
        $e \mapsto$ \eval{\lstinline'p'}{$env$},
        $k \mapsto$ (\eval{\lstinline'k'}{$env$})+1])
    } \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z < k+1 ==> p'}{$env$} \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= k ==> p'}{$env$} \\
    &=&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$} \newline
    $\land$ \eval{\lstinline'\\forall integer z; z == k ==> p'}{$env$} \\
    &=&
    \eval{\lstinline'e'}{$env$}
    $\land$ \eval{\lstinline'\\forall integer z; z == k ==> p'}{$env$} \\
    &=& \eval{\lstinline'e'}{$env$} $\land$ \eval{\lstinline'p'}{$env$} \\
    \multicolumn{3}{c}{car \eval{\lstinline'p'}{$env$} est la valeur de $p$ pour
    le $k$ courant} \\
  \end{tabular}

  Le deuxième invariant est donc lui aussi maintenu après chaque itération.

  Maintenant que les deux invariants ont été prouvés, reprenons notre preuve :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\comp{$I$}{$env$}}
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{(
          \comp{
            $\mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e_2'}}~ \mbox{\lstinline'&& e')}
            \bopen
            I_3
            \cdot \mbox{\lstinline'e = e_3;'}
            \cdot \underline{\mbox{\lstinline'k++'}} \semicolon \bclose$
          }{
            ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
              $e_2 \mapsto$ \eval{$t_2$}{$env$},
              $e \mapsto$ 1,
              $k \mapsto$ \eval{$t_1$}{$env$}])
          })
        })
      })
    })(e) \\
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
        })
      })
    })(e) \\
  \end{tabular}

  Notons $env'$ = $env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
    $e_2 \mapsto$ \eval{$t_2$}{$env$},
    $e\mapsto$
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}].

  Rappelons que
  \eval{$t_1$}{$env'$} $\le$ \eval{$k$}{$env'$} $\le$ \eval{$t_2$}{$env'$} + 1
  (premier invariant de boucle).

  On sait que la condition de boucle est fausse dans cet environnement $env'$ :

  \eval{\lstinline'k <= e_2 && e'}{$env'$} = \textit{false}

  Cas \eval{$k \le e_2$}{$env'$} = \textit{false}, soit
  \eval{$k > t_2$}{$env'$} = \textit{true} :
  
  On sait que \eval{$k > t_2$}{$env'$} et \eval{$k \le t_2+1$}{$env'$}, donc on
  a \eval{k}{$env'$} = \eval{$t_2+1$}{$env'$}.
  Avec cette nouvelle connaissance, on a :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\comp{$I$}{$env$}}
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env$}])
        })
      })
    })(e) \\
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z < t_2+1 ==> p'}{$env$},
            $k \mapsto$ \eval{$t_2+1$}{$env$}])
        })
      })
    })(e) \\
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$},
            $k \mapsto$ \eval{$t_2+1$}{$env$}])
        })
      })
    })(e) \\
    &=&
    ($env$[$e\mapsto$
      \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$},
      $k \mapsto \bot$,
      $e_1 \mapsto \bot$,
      $e_2 \mapsto \bot$]) (e) \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$} \\
  \end{tabular}

  Cas \eval{$e$}{$env'$} = \textit{false} :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{$e$}{$env'$} = \textit{false}
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z < k ==> p'}{$env'$}
    = \textit{false} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z < t_2+1 ==> p'}{$env'$}
    = \textit{false} \\
    \multicolumn{3}{c}{car \eval{$k$}{$env'$} $\le$ \eval{$t_2+1$}{$env'$}} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env'$}
    = \textit{false} \\
    &$\equiv$&
    \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$}
    = \textit{false} \\
    \multicolumn{3}{c}{
      car (\eval{$t_1$}{$env$}) = (\eval{$t_1$}{$env'$}) et
      (\eval{$t_2$}{$env$}) = (\eval{$t_2$}{$env'$})
    } \\
  \end{tabular}

  Donc on a :
  \eval{$e$}{$env'$} $\equiv$
  \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$}.

  Reprenons la preuve principale dans le cas
  \eval{$e$}{$env'$} = \textit{false} :

  \begin{tabular}{p{3cm} p{.5cm} p{11.5cm}}
    \eval{\lstinline'e'}{\comp{$I$}{$env$}}
    &=&
    (\comp{\underline{\mbox{\lstinline'e_2'}} $\Zclear \semicolon$}{
      (\comp{\underline{\mbox{\lstinline'e_1'}} $\Zclear \semicolon$}{
        (\comp{\underline{\mbox{\lstinline'k'}} $\Zclear \semicolon$}{
          ($env$[$e_1 \mapsto$ \eval{$t_1$}{$env$},
            $e_2 \mapsto$ \eval{$t_2$}{$env$},
            $e\mapsto$
            \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$}])
        })
      })
    })(e) \\
    &=&
    ($env$[\eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$},
      $k \mapsto \bot$,
      $e_1 \mapsto \bot$,
      $e_2 \mapsto \bot$]) (e) \\
    &=& \eval{\lstinline'\\forall integer z; t_1 <= z <= t_2 ==> p'}{$env$} \\
  \end{tabular}

  On a bien réussi à prouver que pour tout environnement $env$ :

  \eval{\lstinline'e'}{\comp{$I$}{$env$}}
  = \eval{\lstinline'\\forall integer k; t_1 <= k <= t_2 ==> p'}{$env$}
\end{proof}


\section{Annotation translation}
\label{sec:annotation-translation}
