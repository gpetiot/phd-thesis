
\chapter{Preuve de correction}
\label{sec:preuve-correction}


La grammaire des termes et prédicats de \eacsl \cite{\citeeacsl} autorisés dans
les annotations est détaillée en section~\ref{sec:grammar}, leur sémantique est
présentée en section~\ref{sec:semantics}.
Les propriétés que nous vérifions sont définies en section~\ref{sec:properties}.
Les sections~\ref{sec:term-translation}, \ref{sec:predicate-translation} et
\ref{sec:annotation-translation} détaillent la preuve de ces propriétés
respectivement sur les termes, sur les prédicats et sur les annotations.


\section{Grammaire du langage en entrée}
\label{sec:grammar}

\begin{figure}[tb]
  \begin{tabular}{lrl}
    \textit{unop} & ::= & \lstinline'-' $\mid$ \lstinline'*' $\mid$
    \lstinline'!' $\mid$ \lstinline'~' \\
    \textit{binop} & ::= & \lstinline'+' $\mid$ \lstinline'-' $\mid$
    \lstinline'*' $\mid$ \lstinline'/' $\mid$ \lstinline'%' $\mid$
    \lstinline'>' $\mid$ \lstinline'>=' $\mid$ \lstinline'<' $\mid$
    \lstinline'<=' $\mid$ \lstinline'==' $\mid$ \lstinline'!=' \\
    \textit{term} & ::= & \textit{cst} \\
    & $\mid$ & \textit{lvalue} \\
    & $\mid$ & \textit{unop} \textit{term} \\
    & $\mid$ & \textit{term} \textit{binop} \textit{term} \\
    & $\mid$ & \lstinline'\abs(' \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\sum(' \textit{term}$,$ \textit{term}$,$
    \lstinline'\lambda integer' \textit{id}$;$ \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\product(' \textit{term}, \textit{term},
    \lstinline'\lambda integer' \textit{id}; \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\numof(' \textit{term}, \textit{term},
    \lstinline'\lambda integer' \textit{id}; \textit{term} \lstinline')' \\
    & $\mid$ & \textit{term} \texttt{?} \textit{term} \texttt{:} \textit{term}\\
    & $\mid$ & \lstinline'\old(' \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\null' \\
    & $\mid$ & \lstinline'(' \textit{type} \lstinline')' \textit{term} \\
    \textit{relation} & ::= & \lstinline'>' $\mid$ \lstinline'>=' $\mid$
    \lstinline'<' $\mid$ \lstinline'<=' $\mid$ \lstinline'==' $\mid$
    \lstinline'!=' \\
    \textit{pred} & ::= & \lstinline'\true' \\
    & $\mid$ & \lstinline'\false' \\
    & $\mid$ & \lstinline'\valid(' \textit{term} \lstinline')' \\
    & $\mid$ & \lstinline'\forall integer' \textit{id};
    \textit{pred} \lstinline'==>' \textit{pred} \\
    & $\mid$ & \lstinline'\exists integer' \textit{id};
    \textit{pred} \lstinline'&&' \textit{pred} \\
    & $\mid$ & ! \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'&&' \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'||' \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'==>' \textit{pred} \\
    & $\mid$ & \textit{pred} \lstinline'<==>' \textit{pred} \\
    & $\mid$ & \textit{term} ? \textit{pred} : \textit{pred} \\
    & $\mid$ & \textit{term} \textit{relation} \textit{term} \\
    \textit{assert} & ::= & \lstinline'assert' \textit{pred} \\
    \textit{requires} & ::= & \lstinline'requires' \textit{pred} \\
    \textit{typically} & ::= & \lstinline'typically' \textit{pred} \\
    \textit{ensures} & ::= & \lstinline'ensures' \textit{pred} \\
    \textit{assigns} & ::= & \lstinline'assigns' \textit{term}$^{+}$ \\
    \textit{loop-invariant} & ::= & \lstinline'loop invariant' \textit{pred} \\
    \textit{loop-variant} & ::= & \lstinline'loop variant' \textit{term} \\
    \textit{loop-assigns} & ::= & \lstinline'loop assigns' \textit{term}$^{+}$
  \end{tabular}
  \label{fig:sem-eacsl}
  \caption{Sémantique des termes, prédicats et annotations \eacsl}
\end{figure}

\begin{figure}[tb]
  \begin{tabular}{lrl}
    \textit{exp} & ::= & \textit{cst} \\
    & $\mid$ & \textit{lvalue} \\
    & $\mid$ & \textit{unop} \textit{exp} \\
    & $\mid$ & \textit{exp} \textit{binop} \textit{exp} \\
    & $\mid$ & \lstinline'(' \textit{type} \lstinline')' \textit{term} \\
    \textit{instr} & ::= & ; \\
    & $\mid$ & \textit{lval} \lstinline'=' \textit{exp}; \\
    & $\mid$ & \textit{id} (\textit{exp}$^{*}$); \\
    & $\mid$ & \textit{lval} \lstinline'=' \textit{id} (\textit{exp}$^{*}$); \\
    & $\mid$ & \lstinline'return' \textit{exp}; \\
    & $\mid$ & \lstinline'if(' \textit{exp} \lstinline')'
    $\bopen$ \textit{instr}$^*$ $\bclose$
    \lstinline'else' $\bopen$ \textit{instr}$^*$ $\bclose$ \\
    \textit{loop-instr} & ::= & \lstinline'while(' \textit{exp} \lstinline')'
    $\bopen$ \textit{instr}$^*$ $\bclose$ \\
    \textit{annot-instr} & ::= & \lstinline'/*@' \textit{assert} \lstinline'*/'
    \textit{instr} \\
    & $\mid$ & \lstinline'/*@' \textit{loop-invariant} \textit{loop-variant}
    \textit{loop-assigns} \lstinline'*/' \textit{loop-instr} \\
    \textit{function} & ::= & \lstinline'/*@' \textit{requires} \textit{assigns}
    \textit{ensures} \lstinline'*/' \textit{type} \textit{id}
    (\textit{type} \textit{lvalue}$^{*}$)
    $\bopen$ \textit{decl}$^{*}$ \textit{annot-instr}$^{*}$
    $\bclose$
  \end{tabular}
  \label{fig:sem-c}
  \caption{Sémantique des expressions et instructions C}
\end{figure}



\section{Semantique du langage C annoté avec \eacsl}
\label{sec:semantics}


\begin{notation}

  ~
  \begin{itemize}
  \item $x$, $y$ et $z$ sont des identificateurs de variable
  \item $v$ est une valeur
  \item \eval{$t$}{env} est l'évaluation du terme \eacsl ou de l'expression C
    $t$ dans l'environnement $env$
  \item \comp{$I$}{env} calcule a nouvel environnement résultant de
    l'exécution des instructions $I$ dans l'environnement $env$
  \item $update(env, x, v)$ est l'environnement contenant les mêmes
    relations (variable, valeur) que $env$, et la relation supplémentaire
    ($x$, $v$)
  \item $update(env, x, v)(x) = v$
  \item $update(env, x, v)(y) = env(y)$ si $x \neq y$
  \item $\bot$ est une valeur spéciale qui signifie qu'une variable n'est pas
    ou plus initialisée
  \item une instruction soulignée \underline{\lstinline{instr}} est une
    instruction utilisant la sémantique des entiers non bornés
  \item $\Zinit$\underline{\lstinline{x}} signifie que la variable entière
    \lstinline'x' est allouée et prête à être utilisée
  \item \underline{\lstinline{x}}$\Zclear$ signifie que la variable entière
    \lstinline'x' est désallouée.
  \end{itemize}
\end{notation}


\subsection{Sémantique des termes \eacsl et expression C}

\begin{tabular}{rclr}
  \eval{cst}{$env$} &=& cst & \eqlabel{E-0} \\
  \eval{lvalue}{$env$} &=& $env$(lvalue) & \eqlabel{E-1} \\
  \eval{\lstinline|unop x|}{$env$}
  &=& \lstinline|unop| (\eval{\lstinline|x|}{$env$}) & \eqlabel{E-2} \\
  \eval{\lstinline|x binop y|}{$env$}
  &=& (\eval{\lstinline|x|}{$env$}) \lstinline|binop|
  (\eval{\lstinline|y|}{$env$}) & \eqlabel{E-3} \\
  \eval{\lstinline'\\abs(t)'}{$env$} &=&
  $\lvert$ \eval{\lstinline't'}{$env$} $\rvert$ & \eqlabel{E-4} \\
  \eval{\lstinline'\\sum(x, y, \\lambda integer k; z)'}{$env$} &=&
  $\sum_{k = \mbox{\eval{\lstinline'x'}{$env$}}}^{\mbox{\eval{\lstinline'y'}{$env$}}} \mbox{\eval{\lstinline'z'}{$env$}}$
  & \eqlabel{E-5} \\
  \eval{\lstinline'\\product(x, y, \\lambda integer k; z)'}{$env$} &=&
  $\prod_{k = \mbox{\eval{\lstinline'x'}{$env$}}}^{\mbox{\eval{\lstinline'y'}{$env$}}} \mbox{\eval{\lstinline'z'}{$env$}}$
  & \eqlabel{E-6} \\
  \eval{\lstinline'\\numof(x, y, \\lambda integer k; z)'}{$env$} &=&
  $\sum_{k = \mbox{\eval{\lstinline'x'}{$env$}}}^{\mbox{\eval{\lstinline'y'}{$env$}}} \mbox{\eval{\lstinline'z ? 1 : 0'}{$env$}}$
  & \eqlabel{E-7} \\
  \eval{\lstinline'x ? y : z'}{$env$} &=& \eval{\lstinline'y'}{$env$}
  si (\eval{\lstinline'x'}{$env$}) $\neq$ 0 & \eqlabel{E-8} \\
  &=& \eval{\lstinline'z'}{$env$}
  si (\eval{\lstinline'x'}{$env$}) = 0 & \eqlabel{E-8'} \\
  \eval{\lstinline'\\old(t)'}{$env$} &=&
  \eval{\lstinline't'}{($env$ au début de la fonction courante)}
  & \eqlabel{E-9} \\
  \eval{\lstinline'\\null'}{$env$} &=& \lstinline'NULL' & \eqlabel{E-10} \\
  \eval{\lstinline|(type) x|}{$env$}
  &=& \lstinline|(type)| (\eval{\lstinline|x|}{$env$}) & \eqlabel{E-11} \\
\end{tabular}


\subsection{Sémantique des prédicats \eacsl}


\begin{tabular}{rclr}
  \eval{\lstinline'\\true'}{$env$} &=& \textit{true} & \eqlabel{P-0} \\
  \eval{\lstinline'\\false'}{$env$} &=& \textit{false} & \eqlabel{P-1} \\
  \eval{\lstinline'\\valid(t)'}{$env$} &=&
  "\lstinline'*t' est défini dans $env$" & \eqlabel{P-2} \\
  \eval{\lstinline'\\forall integer k; a <= k <= b ==> y'}{$env$} &=&
  $\forall_{k=\mbox{\eval{\lstinline'a'}{$env$}}}^{\mbox{\eval{\lstinline'b'}{$env$}}} \mbox{\eval{\lstinline'y'}{$env$}}$
  & \eqlabel{P-3} \\
  \eval{\lstinline'\\exists integer k; a <= k <= b \&\& y'}{$env$} &=&
  $\exists_{k=\mbox{\eval{\lstinline'a'}{$env$}}}^{\mbox{\eval{\lstinline'b'}{$env$}}} \mbox{\eval{\lstinline'y'}{$env$}}$
  & \eqlabel{P-4} \\
  \eval{\lstinline'\! p'}{$env$} &=& $\lnot$ (\eval{\lstinline'p'}{$env$})
  & \eqlabel{P-5} \\
  \eval{\lstinline'p \&\& q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\land$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-6} \\
  \eval{\lstinline'p || q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\lor$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-7} \\
  \eval{\lstinline'p ==> q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\Rightarrow$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-8} \\
  \eval{\lstinline'p <==> q'}{$env$} &=&
  (\eval{\lstinline'p'}{$env$}) $\Leftrightarrow$ (\eval{\lstinline'q'}{$env$})
  & \eqlabel{P-9} \\
  \eval{\lstinline'x ? y : z'}{$env$} &=& \eval{\lstinline'y'}{$env$}
  si \eval{\lstinline'x'}{$env$} & \eqlabel{P-10} \\
  &=& \eval{\lstinline'z'}{$env$} sinon & \eqlabel{P-10'} \\
  \eval{\lstinline|x rel y|}{$env$}
  &=& (\eval{\lstinline|x|}{$env$}) \lstinline|rel|
  (\eval{\lstinline|y|}{$env$}) & \eqlabel{P-11} \\
\end{tabular}


\subsection{Sémantique des instructions}

\begin{tabular}{rclr}
  \comp{A $\cdot$ B}{$env$} &=& \comp{B}{(\comp{A}{$env$})} & \eqlabel{C-0} \\
  \comp{$\Zinit$ \underline{\lstinline|a = b|} $\semicolon$}{$env$}
  &=& update($env$, a, \eval{b}{$env$}) & \eqlabel{C-1} \\
  \comp{\underline{\lstinline|a|} $\Zclear \semicolon$}{$env$}
  &=& update($env$, a, $\bot$) & \eqlabel{C-2} \\
  \comp{\lstinline|a = b;|}{$env$}
  &=& update($env$, a, \eval{b}{$env$}) & \eqlabel{C-3} \\
  \comp{\lstinline|if(x) A else B|}{$env$}
  &=& \comp{A}{$env$} si \eval{x}{$env$} & \eqlabel{C-4} \\
  &=& \comp{B}{$env$} sinon & \eqlabel{C-5} \\
  \comp{\lstinline|while(x) A|}{$env$}
  &=& \comp{\lstinline|while(x) A|}{(\comp{A}{$env$})}
  si \eval{x}{$env$} & \eqlabel{C-6} \\
  &=& $env$ sinon & \eqlabel{C-7} \\
\end{tabular}


\section{Properties}
\label{sec:properties}

\begin{notation}
  Soit $P$ un programme C correct syntaxiquement selon la grammaire définie en
  figure~\ref{fig:sem-eacsl} et~\ref{fig:sem-c}.
  Soit $P'$ le programme instrumenté obtenu après traduction du programme $P$.
\end{notation}



\begin{theorem}
  Si une annotation $a$ est invalide, alors l'exécution dans le programme $P$
  des instructions obtenues par instrumentation provoque une erreur dans le
  programme instrumenté $P'$.
  \commentGP{une propriété pour chaque type d'annotation ?}
\end{theorem}

\begin{theorem}
  Si toutes les annotations d'un programme $P$ sont valides, alors $P$ et $P'$
  (obtenu après instrumentation de $P$) ont la même sémantique, et le même
  comportement est observable à l'exécution.
\end{theorem}



\section{Term translation}
\label{sec:term-translation}


\begin{lemma}\label{lem:term-correct}
  Soit $t$ : $\tau$ un terme de type $\tau$, qui se traduit en $(I, t')$.
  La traduction est correcte si et seulement si, pour n'importe quel
  environnement $env$ :

  \eval{$t'$}{\comp{$I$}{env}} = \eval{$t$}{env}.
\end{lemma}


\subsection{Constant Term}

{\myinference[CST]
  {}
  { (l, v : \mathbb{Z}) \rulearrow
    ((l, \Zinit\underline{\mbox{\lstinline'x = v;'}}), x) }
}

Pour n'importe quel environnement $env$, nous prouvons que :

\eval{x}{\comp{$\Zinit$\underline{\lstinline'x = v;'}}{env}} = \eval{v}{env}.


\begin{proof}
  ~\\
  \begin{tabular}{rclr}
    \eval{x}{\comp{$\Zinit$\underline{\lstinline'x = v;'}}{env}}
    & $\eq{C-1}$ & \eval{x}{update(env, x, \eval{v}{env})} & \\
    & $\eq{E-1}$ & \eval{v}{env} &
  \end{tabular}
\end{proof}


\section{Predicate translation}
\label{sec:predicate-translation}


\begin{lemma}\label{lem:pred-correct}
  Soit $p$ un prédicat qui se traduit en $(I, p')$.
  La traduction est correct si et seulement si, pour n'importe quel
  environnement $env$ :

  \eval{$p'$}{\comp{$I$}{env}} = \eval{$p$}{env}.
\end{lemma}


\subsection{And Predicate}

{\myinference[AND]
  { (l, p_1) \rulearrow (I_1, e_1) \\ (l, p_2) \rulearrow (I_2, e_2) }
  { (l, \mbox{\lstinline'p_1 && p_2'}) \rulearrow
    (
    \underbracket{
      I_1 \cdot
      \underbracket{ (l, \mbox{\lstinline'int e = e_1;'}) }_{i_1}
      \cdot
      \underbracket{ (l, \mbox{\lstinline'if(e)'})
        \bopen
        I_2 \cdot
        \underbracket{ (l, \mbox{\lstinline'e = e_2;'}) }_{i_2}
        \bclose }_{i_3}
      }_{I},
    e) }
}~\\

Pour n'importe quel environnement $env$, nous prouvons que :

\eval{\lstinline'e'}{\comp{$I$}{$env$}} = \eval{\lstinline'p1 && p2'}{$env$}.


\begin{proof}
  ~\\
  Hypothèses : $p_1$ et $p_2$ sont correctement instrumentés.
  Pour tout environnement $env$ :

  \begin{tabular}{rclr}
    \eval{$e_1$}{\comp{$I_1$}{$env$}}
    & = & \eval{$p_1$}{$env$} & \eqlabel{h1} \\
    $\equiv$ \comp{$I_1$}{$env$}
    & = & $env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}] & \\
    \eval{$e_2$}{\comp{$I_2$}{$env$}}
    & = & \eval{$p_2$}{$env$} & \eqlabel{h2} \\
    $\equiv$ \comp{$I_2$}{$env$}
    & = & $env$[$e_2 \mapsto$ \eval{$p_2$}{$env$}] & \\
  \end{tabular}

  On doit prouver l'égalité suivante :

  \eval{\lstinline'e'}{\comp{$I$}{$env$}}
  $\eq{?}$ \eval{\lstinline'p1 && p2'}{$env$}

  Développons le membre gauche :
  
  \begin{tabular}{rcl}
    \eval{\lstinline'e'}{\comp{$I$}{$env$}}
    & = & (\comp{$I$}{$env$})(e) \\
    & = & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
      (l, \lstinline'e = e_2;') $\bclose$ }{
      (\comp{\lstinline'int e = e1;'}{
        (\comp{$I_1$}{$env$})
      })
    })(e) \\
    & $\eq{h1}$ & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
      (l, \lstinline'e = e_2;') $\bclose$ }{
      (\comp{\lstinline'int e = e1;'}{
        ($env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}])
      })
    })(e) \\
    & = & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
      (l, \lstinline'e = e_2;') $\bclose$ }{
      (
      ($env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}])[$e \mapsto$
        \eval{$e_1$}{$env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}]}]
      )
    })(e) \\
    & = & (\comp{\lstinline'if(e)' $\bopen \concat I_2 \concat$
      (l, \lstinline'e = e_2;') $\bclose$ }{
      (
      $env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}][$e \mapsto$ \eval{$p_1$}{$env$}]
      )
    })(e) \\

    %% cas true
    \multicolumn{3}{l}{
      Quand \eval{e}{(
        $env$
        [$e_1 \mapsto$ \eval{$p_1$}{$env$}]
        [$e \mapsto$ \eval{$p_1$}{$env$}]
      )} = true : ~~\eqlabel{h3}}\\
    & = & (\comp{$I_2 \concat$
      (l, \lstinline'e = e_2;')  }{
      (
      $env$
      [$e_1 \mapsto$ \eval{$p_1$}{$env$}]
      [$e \mapsto$ \eval{$p_1$}{$env$}]
      )
    })(e) \\
    & = & (\comp{\lstinline'e = e_2;'}{
      (\comp{$I_2$}{
        (
        $env$
        [$e_1 \mapsto$ \eval{$p_1$}{$env$}]
        [$e \mapsto$ \eval{$p_1$}{$env$}]
        )
      })
    })(e) \\
    & $\eq{h2}$ & (\comp{\lstinline'e = e_2;'}{
      (
      $env$
      [$e_1 \mapsto$ \eval{$p_1$}{$env$}]
      [$e \mapsto$ \eval{$p_1$}{$env$}]
      [$e_2 \mapsto$ \eval{$p_2$}{$env$}]
      )
    })(e) \\
    & = & ($env$
                [$e_1 \mapsto$ \eval{$p_1$}{$env$}]
                [$e_2 \mapsto$ \eval{$p_2$}{$env$}]
                [$e \mapsto$ \eval{$p_2$}{$env$}]
                ) (e) \\
    & = & \eval{$p_2$}{$env$} \\
    & = & true $\land$ \eval{$p_2$}{$env$} \\
    & $\eq{h3}$ & \eval{$p_1$}{$env$} $\land$ \eval{$p_2$}{$env$} \\
    & = & \eval{\lstinline'p1 \&\& p2'}{$env$} \\

    %% cas false
    \multicolumn{3}{l}{
      Quand \eval{e}{(
        $env$
        [$e_1 \mapsto$ \eval{$p_1$}{$env$}]
        [$e \mapsto$ \eval{$p_1$}{$env$}]
        )} = false : ~~\eqlabel{h4}}\\
    & = & (
    $env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}][$e \mapsto$ \eval{$p_1$}{$env$}]
    ) (e) \\
    & = & (
    $env$[$e_1 \mapsto$ \eval{$p_1$}{$env$}][$e \mapsto$ \eval{$p_1$}{$env$}]
    ) (e) \\
    & = & \eval{$p_1$}{$env$} \\
    & $\eq{h4}$ & false \\
    & = & false $\land$ \eval{$p_2$}{$env$} \\
    & $\eq{h4}$ & \eval{$p_1$}{$env$} $\land$ \eval{$p_2$}{$env$} \\
    & = & \eval{\lstinline'p1 \&\& p2'}{$env$} \\
  \end{tabular}
\end{proof}


\subsection{Forall Predicate}

{\myinference[FORALL]
  {
    (l, t_1 : \mathbb{Z}) \rulearrow (I_1, e_1) \\
    (l, t_2 : \mathbb{Z}) \rulearrow (I_2, e_2) \\
    (l, p) \rulearrow (I_3, e_3)
  }
  {
    \splitfrac {
      (l, \mbox{\lstinline'\\forall integer id; t_1 <= id < t_2 ==> p'})
      \rulearrow
    } {
      \splitfrac {
        (I_1 \cdot I_2
        \cdot \underbracket{ (l, \mbox{\lstinline'int e = 1;'}) }_{i_1}
        \cdot
        \underbracket{
          (l, \Zinit \underline{\mbox{\lstinline'id = e_1;'}} ) }_{i_2}
      } {
        \cdot
        \underbracket{
          (l, \mbox{\lstinline'while('}
          \underline{\mbox{\lstinline'id < e_2'}}~ \mbox{\lstinline'&& var')}
          \bopen
          I_3
          \cdot \underbracket{ \mbox{\lstinline'e = e_3;'} }_{i_4}
          \cdot \underbracket{ \underline{\mbox{\lstinline'id++;'}} }_{i_5}
          \bclose )
        }_{i_3}
        \cdot
        \underbracket{
          (l, \underline{\mbox{\lstinline'id'}} \Zclear \semicolon ) }_{i_6}
        \cdot
        \underbracket{
          (l, \underline{\mbox{\lstinline'e_1'}} \Zclear \semicolon ) }_{i_7}
        \cdot
        \underbracket{
          (l, \underline{\mbox{\lstinline'e_2'}} \Zclear \semicolon ) }_{i_8},
        e)
      }
    }
  }
}~\\


\begin{proof}
  ~\\
  \begin{tabular}{rclr}
    \comp{$I_1$}{env}
    &=& update(env, $e_1$, \eval{$t_1$}{env}) = env$_{e_1}$ &\\
    \comp{$I_2$}{env$_{e_1}$}
    &=& update(env$_{e_1}$, $e_2$, \eval{$t_2$}{env}) = env$_{e_2}$ &\\
    \comp{$i_1$}{env$_{e_2}$} &=& update(env$_{e_2}$, var, 1) = env$_{i_1}$ &\\
    \comp{$i_2$}{env$_{i_1}$} &=& update(env$_{i_1}$, id, \eval{$e_1$}{env$_{i_1}$})&\\
    &=& update(env$_{i_1}$, id, \eval{$t_1$}{env}) = env$_{i_2}$ &\\
    \eval{$var$}{env$_{i_3}$}
    &=& \eval{\lstinline'\\forall integer i; t_1 <= i < t_2 ==> p'}{env}
    & (Lemma 4.2) \\
    \comp{$i_6$}{env$_{i_3}$} &=& update(env$_{i_3}$, id, $\bot$) = env$_{i_6}$ &\\
    \comp{$i_7$}{env$_{i_6}$} &=& update(env$_{i_6}$, $e_1$, $\bot$) = env$_{i_7}$ &\\
    \comp{$i_8$}{i$_7$} &=& update(env$_{i_7}$, $e_2$, $\bot$) = env$_{i_8}$ &\\
    \eval{$var$}{\comp{$I$}{env}} &=& \eval{$var$}{env$_{i_3}$} &\\
    &=& \eval{\lstinline'\\forall integer id; t_1 <= id < t2 ==> p'}{env} & \\
  \end{tabular}
\end{proof}



\begin{lemma}
  \eval{$var$}{env$_{i_3}$}
  = \eval{\lstinline{\\forall integer i; t_1 <= i < t_2 ==> p}}{env}
\end{lemma}

Supposons l'hypothèse de récurrence H suivante :

\eval{$var$}{env'}
= \eval{\lstinline'\\forall integer i; t_1 <= i < id ==> p'}{env'}.

\begin{proof}
  ~\\
  \begin{tabular}{rclr}
    \comp{$I_3$}{env'} &=& update(env', e, \eval{$p$}{env'}) = env$_e$& \\
    \comp{$i_4$}{env$_e$} &=& update(env$_e$, var, \eval{$e$}{env$_e$}) &\\
    &=& update(env$_e$, var, \eval{$p$}{env'}) = env$_{i_4}$ &\\
    \eval{$var$}{env$_{i_4}$} &=& \eval{$var$}{env'} $\land$ \eval{$var$}{env$_{i_4}$} &\\
    & &the loop condition is true, so \eval{$var$}{env'} is true as well&\\
    &=& \eval{\lstinline'\\forall integer i; t_1 <= i < id ==> p'}{env'} $\land$ \eval{$p$}{env'} &\\
    &=& \eval{\lstinline'\\forall integer i; t_1 <= i < id ==> p'}{env'}& \\
    & & $\land$ \eval{\lstinline'\\forall integer i; i = id ==> p'}{env'} &\\
    &=& \eval{\lstinline'\\forall integer i; t_1 <= i <= id ==> p'}{env'} &\\
    \comp{$i_5$}{env$_{i_4}$}
    &=& update(env$_{i_4}$, id, \eval{$id$}{env$_{i_4}$} + 1) = env$_{i_5}$& \\
    \eval{$var$}{env$_{i_5}$}
    &=& \eval{\lstinline'\\forall integer i; t_1 <= i < id ==> p'}{env'} &\\
    & & because \eval{$id$}{env$_{i_5}$} = \eval{$id$}{env$_{i_4}$} + 1 & \\
    & & so (H) is maintained after each iteration of the loop & \\
    \eval{$var$}{env$_{i_3}$} &=& \eval{\lstinline'\\forall integer i; t_1 <= i < id ==> p'}{env'} &\\
    \eval{$t_1 \le id \le t_2$}{env$_{i_3}$} &=& 1 & Lemma 4.3 \\
    \eval{\underline{id < $e_2$}\lstinline' \&\& var'}{env$_{i_3}$} &=& 0 & \\
    \eval{$id$}{env$_{i_3}$} < \eval{$e_2$}{env$_{i_3}$} $\land$ \eval{$var$}{env$_{i_3}$}
    &=& 0 &\\
    If \eval{$id$}{env$_{i_3}$} < \eval{$e_2$}{env$_{i_3}$} = 0:&&& \\
    \eval{$id$}{env$_{i_3}$} $\ge$ \eval{$e_2$}{env$_{i_3}$} &=& 1 &\\
    \eval{$id$}{env$_{i_3}$} $\ge$ \eval{$t_2$}{env} &=& 1& \\
    \eval{$id$}{env$_{i_3}$} &=& \eval{$t_2$}{env} & thanks to Lemma 4.3 \\
    \eval{$var$}{env$_{i_3}$}
    &=& \eval{\lstinline'\\forall integer i; t_1 <= i < t_2 ==> p'}{env} &\\
    If \eval{$var$}{env$_{i_3}$} = 0:&&& \\
    \eval{\lstinline'\\forall integer i; t_1 <= i < id ==> p'}{env'} &=& 0& \\
    \eval{\lstinline'\\forall integer i; t_1 <= i < t_2 ==> p'}{env'} &=& 0 & thanks to Lemma 4.3 \\
    \eval{\lstinline'\\forall integer i; t_1 <= i < t_2 ==> p'}{env}
    &=& \eval{$var$}{env$_{i_3}$} &\\
    So we have: \eval{$var$}{env$_{i_3}$}
    &=& \eval{\lstinline'\\forall integer i; t_1 <= i < t_2 ==> p'}{env}& \\
  \end{tabular}
\end{proof}


\begin{lemma}
  \eval{$t_1 \le id \le t_2$}{env$_{i_3}$} = 1
\end{lemma}


Supposons l'hypothèse de récurrence H' suivante :

\eval{$t_1 \le id \le t_2$}{env'} = 1.

\begin{proof}
  ~\\
  \begin{tabular}{rclr}
    \eval{$t_1 \le id \le t_2$}{env$_e$}
    &=& \eval{$t_1 \le id \le t_2$}{env$_{i_4}$}\\
    &=& \eval{$t_1 \le id \le t_2$}{env'} &\\
    \eval{$t_1$}{env$_{i_5}$} $\le$ \eval{$id$}{env$_{i_5}$}
    &=& \eval{$t_1$}{env$_{i_4}$} $\le$ \eval{$id$}{env$_{i_5}$}& \\
    &=& \eval{$t_1$}{env$_{i_4}$} $\le$ \eval{$id$}{env$_{i_4}$} + 1 &\\
    &=& 1\ \text{due to H'} &\\
    \eval{$id$}{env$_{i_5}$} $\le$ \eval{$t_2$}{env$_{i_5}$}
    &=& \eval{$id$}{env$_{i_5}$} - 1 < \eval{$t_2$}{env$_{i_5}$}& \\
    &=& \eval{$id$}{env$_{i_4}$} < \eval{$t_2$}{env$_{i_5}$} &\\
    &=& \eval{$id$}{env$_{i_4}$} < \eval{$t_2$}{env$_{i_4}$} &\\
    &=& 1 & (loop condition) \\
  \end{tabular}
\end{proof}

So we have \eval{$t_1 \le id \le t_2$}{env$_{i_5}$} = 1.
So H' is maintained after each loop iteration.
So we have \eval{$t_1 \le id \le t_2$}{env$_{i_3}$} = 1.


\section{Annotation translation}
\label{sec:annotation-translation}
