\begin{figure}[t]
\scriptsize{
  {\myinference[$\alpha$-assert]
    {(l, p) \rulearrow (I, e)}
    {(l, \mbox{\lstinline'assert p;'})
      \rulearrow I \concat (l, \mbox{\lstinline'fassert(e);'})}
  }
  \vspace{-1mm}

  {\myinference[$\alpha$-check-pre\hspace{-2mm}]
    {(Beg_f, p) \rulearrow (I, e)}
    {(Beg_f, \mbox{\lstinline'requires p;'})
      \rulearrow
      I \concat (Beg_f, \mbox{\lstinline'fassert(e);'})}
  }
  {\myinference[$\alpha$-assume-pre\hspace{-2mm}]
    {(Beg_f, p) \rulearrow (I, e)}
    {(Beg_f, \left \{\hspace{-2mm}
      \begin{array}{r}
        \mbox{\lstinline'typically'} \\
        \mbox{\lstinline'requires'}
      \end{array} \mbox{\lstinline'p;'} \right. %\hspace{-2mm}
      )
      \rulearrow
      I \concat (Beg_f, \mbox{\lstinline'fassume(e);'})}
  }
  \vspace{-1mm}

  {\myinference[$\alpha$-check-assigns]
    {(End_f, x) \rulearrow (I, e)}
    {(End_f, \mbox{\lstinline'assigns X;'})
      \rulearrow
      I \concat
      \forall (x:ctype) \not \in X:
      (Beg_f, \mbox{\lstinline'ctype assigns_x = e;'})
      \concat (End_f, \mbox{\lstinline'fassert(e == assigns_x);'})
    }
  }
  {\myinference[$\alpha$-assume-assigns]
    {(End_f, x) \rulearrow (I, e)}
    {(End_f, \mbox{\lstinline'assigns x;'})
      \rulearrow
      I \concat (End_f, \mbox{\lstinline'e = nondet();'})}
  }
  \vspace{-1mm}

  {\myinference[$\alpha$-check-post]
    {(End_f, p) \rulearrow (I, e)}
    {(End_f, \mbox{\lstinline'ensures p;'})
      \rulearrow
      I \concat (End_f, \mbox{\lstinline'fassert(e);'})}
  }
  {\myinference[$\alpha$-assume-post]
    {(End_f, p) \rulearrow (I, e)}
    {(End_f, \mbox{\lstinline'ensures p;'})
      \rulearrow
      I \concat (End_f, \mbox{\lstinline'fassume(e);'})}
  }
}
  \caption{Règles de traduction pour les assertions, pré-/postconditions et
    assigns}
  \label{fig:annot}
\end{figure}

\begin{figure*}[tb]
  \scriptsize{
  {\myinference[$\alpha$-check-loop-assigns]
    {(l, x) \rulearrow (I, e)}
    {
      \splitfrac
      {
        (l, \mbox{\lstinline'loop assigns X;'}) \rulearrow
      }
      {
        I \concat
        \forall (x:ctype) \not \in X:
        (BegIter_l, \mbox{\lstinline'ctype assigns_x = e;'})
        \concat (EndIter_l, \mbox{\lstinline'fassert(e == assigns_x);'})
      }
    }
  }
  {\myinference[$\alpha$-assume-loop-assigns]
    {(l, x) \rulearrow (I, e)}
    {(l, \mbox{\lstinline'loop assigns x;'})
      \rulearrow
      I \concat (l, \mbox{\lstinline'e = nondet();'})}
  }
  \vspace{-1mm}

 {\myinference[$\alpha$-check-invariant]
    {(l, p) \rulearrow (I_1, e_1) \\
      (EndIter_l, p) \rulearrow (I_2, e_2)}
    {
      (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
      I_1 \concat (l, \mbox{\lstinline'fassert(e1);'})
      \concat I_2 \concat (EndIter_l, \mbox{\lstinline'fassert(e2);'})
    }
  }

 {\myinference[$\alpha$-assume-invariant-1]
    {(l, p) \rulearrow (I, e)}
    {
      (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
      I \concat (l, \mbox{\lstinline'fassume(e && !loopcond);'})
    }
  }
 {\myinference[$\alpha$-assume-invariant-2]
    {(l, p) \rulearrow (I_1, e_1) \\
      (EndIter_l, p) \rulearrow (I_2, e_2)}
    {
      (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
      I_1 \concat (l, \mbox{\lstinline'fassume(e1);'})
      \concat I_2 \concat (EndIter_l, \mbox{\lstinline'fassert(e2);'})
    }
  }
 \vspace{-1mm}

 {\myinference[$\alpha$-variant]
   {
     (BegIter_l, t) \rulearrow (I_1, e_1) \\
     (EndIter_l, t) \rulearrow (I_2, e_2)
   }
   {
     \splitfrac
         {
           (l, \mbox{\lstinline'loop variant t;'}) \rulearrow
         }
         {
           I_1 \concat ((BegIter_l,
           \mbox{\lstinline'fassert('}
           \underline{\mbox{\lstinline'0 <= e1'}}
           \mbox{\lstinline');' }
           \underline{\Zinit \mbox{\lstinline'old_variant = e1'} \Zclear}
           \semicolon)
           \concat I_2
           \concat(EndIter_l,
           \mbox{\lstinline'fassert('}
           \underline{\mbox{\lstinline'e2'}\Zclear
             \mbox{\lstinline'< old_variant'} \Zclear}
           \mbox{\lstinline');'})
         }
   }
 }
  }
  \caption{Règles de traduction pour les annotations de boucle : invariants,
    variant et assigns}
  \label{fig:loop-annot}
\end{figure*}


\begin{figure*}[t]
\scriptsize{
  {\myinference[$\tau$-old\hspace{-2mm}{}]
    {}
    {(l, \mbox{\lstinline'\\old(x)'}:ctype) \rulearrow
      (\emptylist, \mbox{\lstinline'old_x'})}
  }
  {\myinference[$\tau$-var\hspace{-2mm}{}]
    {}
    {(l, \mbox{\lstinline'x'}:ctype) \rulearrow
      (\emptylist, \mbox{\lstinline'x'})}
  }
  \vspace{-2mm}

  {\myinference[$\tau$-old-val\hspace{-2mm}{}]
    {(l, t:int) \rulearrow (I, e)}
    {(l, \mbox{\lstinline'\\old(*(x+t))'}:ctype) \rulearrow
      (I,\mbox{\lstinline'*(old_val_x+e)'})}
  }

  {\myinference[$\tau$-res\hspace{-2mm}{}]
    {}
    {(l, \mbox{\lstinline'\\result'}:ctype) \rulearrow
      (\emptylist, \mbox{\lstinline'res'})}
  }
  {\myinference[$\tau$-const\hspace{-1mm}{}]
    {}
    {(l, \mbox{\lstinline'cst'}:\mathbb{Z}) \rulearrow
      ((l, \underline{\Zinit\mbox{\lstinline'var_n = cst'}}),
      \mbox{\lstinline'var_n'})}
  }
}
  \vspace{-5mm}
  \caption{Règles de traduction pour les constantes, identificateurs,
    \lstinline'result' et \lstinline'old'}
  \label{fig:const-id}
\end{figure*}

\begin{figure*}[bt]
  \scriptsize{
    {\myinference[$\tau$-coerce$_1$]
      {(l, t:\mathbb{Z}) \rulearrow (I, e)}
      {
        (l, (int)(t : \mathbb{Z})) \rulearrow
        (I \concat (l,
        \mbox{\lstinline'int var_n = '}
        \underline{\mbox{\lstinline'e'} \Zclear}
        \semicolon
        ), \mbox{\lstinline'var_n'})
      }
    }
    {\myinference[$\tau$-coerce$_2$]
      {(l, t:int) \rulearrow (I, e)}
      {(l, (\mathbb{Z})(t:int)) \rulearrow (I \concat (l,
        \underline{\Zinit \mbox{\lstinline'var_n = e'}}
        \semicolon
        ), \mbox{\lstinline'var_n'})}
    }
  }
  \caption{Règles de traduction pour les conversions}
  \label{fig:coerce}
\end{figure*}

\begin{figure*}[bt]
\scriptsize{
  {\myinference[$\tau$-binop$_1$]
    {(l, t_1:ptr) \rulearrow (I_1, e_1) \quad
      (l, t_2:int) \rulearrow (I_2, e_2) \quad
    op \in \{+, -\}}
    {(l, (\mbox{\lstinline't1 op t2'}):ptr) \rulearrow
      (I_1 \concat I_2, \mbox{\lstinline'e1 op e2'})}
  }
  {\myinference[$\tau$-unop$_1$]
    {(l, t:ptr) \rulearrow (I, e)}
    {(l, (\mbox{\lstinline'* t'}): ctype) \rulearrow
      (I, \mbox{\lstinline'* e'})}
  }
  \vspace{-3mm}

  {\myinference[$\tau$-binop$_2$]
    {(l, t_1:\mathbb{Z}) \rulearrow (I_1, e_1) \quad
      (l, t_2:\mathbb{Z}) \rulearrow (I_2, e_2) \quad
      op \in \{\mathtt{==}, \mathtt{!=}, \mathtt{<},
      \mathtt{<=}, \mathtt{>}, \mathtt{>=}, \mathtt{||},
      \mathtt{\&\&}\}}
    {(l, (\mbox{\lstinline't1 op t2'}):int) \rulearrow
      (I_1 \concat I_2 \concat (l,
      \mbox{\lstinline'int var_n = '}
      \underline{\mbox{\lstinline'e1'}\Zclear \mbox{\lstinline'op e2'}\Zclear}
      \semicolon
      ), \mbox{\lstinline'var_n'})}
  }
  {\myinference[$\tau$-unop$_2$]
    {(l, t:int) \rulearrow (I, e)}
    {(l, (\mbox{\lstinline'\! t'}): int) \rulearrow
      (I, \mbox{\lstinline'\! e'})}
  }
  \vspace{-3mm}

  {\myinference[$\tau$-binop$_3$]
    {(l, t_1:\mathbb{Z}) \rulearrow (I_1, e_1) \quad
      (l, t_2:\mathbb{Z}) \rulearrow (I_2, e_2) \quad
      op \in \{\mathtt{+}, \mathtt{-}, \mathtt{/}, \mathtt{\%},
      \mathtt{<<}, \mathtt{>>}, \mathtt{|}, \mathtt{\&},
      \mathbin{\char`\^}\}}
    {(l, (\mbox{\lstinline't1 op t2'}):\mathbb{Z}) \rulearrow
      (I_1 \concat I_2 \concat (l,
      \underline{\Zinit \mbox{\lstinline'var_n = e1'} \Zclear
        \mbox{\lstinline'op e2'} \Zclear}
      \semicolon
      ), \mbox{\lstinline'var_n'})}
  }
  {\myinference[$\tau$-unop$_3$]
    {(l, t:\mathbb{Z}) \rulearrow (I, e) \quad
      op \in \{ -, \sim\}}
    {(l, (\mbox{\lstinline'op t'}):\mathbb{Z}) \rulearrow (I, \concat (l,
      \underline{\mbox{\lstinline'e = op e'}}
      \semicolon
      ), \mbox{\lstinline'e'})}
  }
  \vspace{-3mm}

  {\myinference[$\tau$-if]
    {(l, t_1:\mathbb{Z}) \rulearrow (I_1, e_1) \\
      (l, t_2:\mathbb{Z}) \rulearrow (I_2, e_2) \\
      (l, t_3:\mathbb{Z}) \rulearrow (I_3, e_3)}
    {
      (l, (\mbox{\lstinline't1 ? t2 : t3'}):\mathbb{Z})
      \rulearrow
      (I_1
      \concat (l,
      \mbox{\lstinline'if('}
      \underline{\mbox{\lstinline'e1'}\Zclear \mbox{\lstinline' \!= 0'}}
      \mbox{\lstinline')'} \bopen
      )
      \concat I_2
      \concat (l,
      \underline{\Zinit \mbox{\lstinline'var_n = e2'} \Zclear}
      \semicolon \bclose
      \mbox{\lstinline'else'} \bopen
      )
      \concat I_3
      \concat
      (l,
      \underline{\Zinit \mbox{\lstinline'var_n = e3'} \Zclear}
      \semicolon
      \bclose ),
      \mbox{\lstinline'var_n'})
    }
  }
}
  \caption{Règles de traduction pour les opérations unaires et binaires}
  \label{fig:op}
\end{figure*}

\begin{figure*}[bt]
  \scriptsize{
    {\myinference[$\tau$-sum]
      {(l, t_1:\mathbb{Z}) \rulearrow (I_1, e_1) \\
        (l, t_2:\mathbb{Z}) \rulearrow (I_2, e_2) \\
        (l, t_3:\mathbb{Z}) \rulearrow (I_3, e_3)}
      {
        \splitfrac
            {(l,
              (\mbox{\lstinline'\\sum(t1, t2, \\lambda integer i; t3)'}):
              \mathbb{Z})
              \rulearrow}
            {
              (I_1 \concat I_2
              \concat
              (l, \underline{\Zinit \mbox{\lstinline'var_n = 0'}} \semicolon
              \mbox{\lstinline' for('}
              \underline{\Zinit \mbox{\lstinline'i_n = e1'} \Zclear}\semicolon
              \underline{\mbox{\lstinline'i_n <= e2'} \Zclear}\semicolon
              \underline{\mbox{\lstinline'i_n++'} \Zclear}
              \mbox{\lstinline')'} \bopen )
              \concat I_3
              \concat
              (l,
              \underline{\mbox{\lstinline'var_n += e3'} \Zclear}\semicolon
              \bclose
              ),
              \mbox{\lstinline'var_n'})
            }
      }
    }

    {\myinference[$\tau$-numof]
      {(l, t_1:\mathbb{Z}) \rulearrow (I_1, e_1) \\
        (l, t_2:\mathbb{Z}) \rulearrow (I_2, e_2) \\
        (l, t_3:int) \rulearrow (I_3, e_3)}
      {
        \splitfrac
            {(l,
              (\mbox{\lstinline'\\numof(t1, t2, \\lambda integer i; t3)'}):
              \mathbb{Z})
              \rulearrow}
            {
              (I_1 \concat I_2
              \concat
              (l,
              \underline{\Zinit \mbox{\lstinline'var_n = 0'}}
              \semicolon
              \mbox{\lstinline' for('}
              \underline{\Zinit \mbox{\lstinline'i_n = e1'} \Zclear}
              \semicolon
              \underline{\mbox{\lstinline'i_n <= e2'} \Zclear}
              \semicolon
              \underline{\mbox{\lstinline'i_n++'} \Zclear}
              \mbox{\lstinline')'} \bopen )
              \concat I_3
              \concat (l,
              \mbox{\lstinline'if(e3)'}
              \underline{\mbox{\lstinline'var_n++'}}
              \semicolon
              \bclose
              ),
              \mbox{\lstinline'var_n'})
            }
      }
    }
  }
\caption{Règles de traduction pour les fonctions logiques \lstinline'sum' et
  \lstinline'numof'}
\label{fig:builtin}
\end{figure*}

\begin{figure*}[t]
\scriptsize{
  {\myinference[$\pi$-equiv]
    {(l, p_1) \rulearrow (I_1, e_1) \\ (l, p_2) \rulearrow (I_2, e_2)}
    {(l, \mbox{\lstinline'p1 <==> p2'})
      \rulearrow
      (I_1 \concat I_2, \mbox{\lstinline'((!e1 || e2) && (!e2 || e1))'})}
  }

  \vspace{-1mm}
  {\myinference[$\pi$-and]
    {(l, p_1) \rulearrow (I_1, e_1) \\ (l, p_2) \rulearrow (I_2, e_2)}
    {(l, \mbox{\lstinline'p1 && p2'})
      \rulearrow
      (I_1 \concat (l, \mbox{\lstinline'int var_n = e1; if(var_n)'} \bopen)
      \concat I_2
      \concat (l, \mbox{\lstinline'var_n = e2;'} \bclose),
      \mbox{\lstinline'var_n'})
    }
  }
  {\myinference[$\pi$-true]
    {}
    {(l, \mbox{\lstinline'\\true'}) \rulearrow
      (\emptylist, \mbox{\lstinline'1'})}
  }

  \vspace{-3mm}
  {\myinference[$\pi$-or]
    {(l, p_1) \rulearrow (I_1, e_1) \\ (l, p_2) \rulearrow (I_2, e_2)}
    {(l, \mbox{\lstinline'p1 || p2'})
      \rulearrow
      (I_1 \concat (l, \mbox{\lstinline'int var_n = e1; if(!var_n)'} \bopen)
      \concat I_2
      \concat (l, \mbox{\lstinline'var_n = e2;'} \bclose),
      \mbox{\lstinline'var_n'})
    }
  }
  {\myinference[$\pi$-false]
    {}
    {(l, \mbox{\lstinline'\\false'}) \rulearrow
      (\emptylist, \mbox{\lstinline'0'})}
  }

  \vspace{-3mm}
  {\myinference[$\pi$-impl]
    {(l, p_1) \rulearrow (I_1, e_1) \\
      (l, p_2) \rulearrow (I_2, e_2)}
    {(l, \mbox{\lstinline'p1 ==> p2'})
      \rulearrow
      (I_1 \concat (l, \mbox{\lstinline'int var_n = 1; if(e1)'} \bopen)
      \concat I_2
      \concat (l, \mbox{\lstinline'var_n = e2;'} \bclose),
      \mbox{\lstinline'var_n'})
    }
  }
  {\myinference[$\pi$-not]
    {(l, p) \rulearrow (I, e)}
    {(l, \mbox{\lstinline'\!p'}) \rulearrow (I, \mbox{\lstinline'\!e'})}
  }
  \vspace{-3mm}

  {\myinference[$\pi$-if]
    {(l, t:\mathbb{Z}) \rulearrow (I_1, e_1) \\
      (l, p_2) \rulearrow (I_2, e_2) \\
      (l, p_3) \rulearrow (I_3, e_3)}
    {
      (l, \mbox{\lstinline't ? p2 : p3'}) \rulearrow
      (I_1 \concat (l, \mbox{\lstinline'int var_n; if('}
      \underline{\mbox{\lstinline'e1'}\Zclear \mbox{\lstinline' \!= 0'}}
      \mbox{\lstinline')'} \bopen)
      \concat I_2 \concat (l, \mbox{\lstinline'var_n=e2;'} \bclose
      \mbox{\lstinline'else'} \bopen)
      \concat I_3 \concat (l, \mbox{\lstinline'var_n=e3;'} \bclose),
      \mbox{\lstinline'var_n'})
    }
  }
  \vspace{-0.5mm}

  {\myinference[$\pi$-rel]
    {(l, t_1:\mathbb{Z}) \rulearrow (I_1, e_1) \quad
      (l, t_2:\mathbb{Z}) \rulearrow (I_2, e_2) \quad
      op \in \{\mathtt{<}, \mathtt{<=}, \mathtt{>}, \mathtt{>=},
      \mathtt{==}, \mathtt{!=}\}}
    {(l, \mbox{\lstinline't1 op t2'}) \rulearrow
      (I_1 \concat I_2 \concat (l,
      \mbox{\lstinline'int var_n ='}
      \underline{\mbox{\lstinline' e1'} \Zclear \mbox{\lstinline' op e2'}
        \Zclear}
      \semicolon
      ), \mbox{\lstinline'var_n'})}
  }
}
  \caption{Règles de traduction pour les prédicats simples}
  \label{fig:pred-logic}
\end{figure*}

\begin{figure*}[bt]
\scriptsize{
  {\myinference[$\pi$-valid]
    {(l, t:ptr) \rulearrow (I, e) }
    {(l, \mbox{\lstinline'\\valid(t)'}) \rulearrow
      (I, \mbox{\lstinline'fvalid(e)'})
    }
  }
  {\myinference[$\pi$-valid-range]
    {(l, t_1:ptr) \rulearrow (I_1, e_1) \\
      (l, t_2:int) \rulearrow (I_2, e_2) \\
      (l, t_3:int) \rulearrow (I_3, e_3)}
    {
      (l, \mbox{\lstinline'\\valid(t1+(t2..t3))'}) \rulearrow
      (I_1 \concat I_2 \concat I_3,\mbox{\lstinline'fvalidr(e1,e2,e3)'})
    }
  }
}
  \caption{Règles de traduction pour les prédicats de validité mémoire}
  \label{fig:valid}
\end{figure*}

\begin{figure*}[bt]
  \scriptsize{
    {\myinference[$\pi$-exists]
      {(l, t_1:\mathbb{Z}) \rulearrow (I_1, e_1) \\
        (l, t_2:\mathbb{Z}) \rulearrow (I_2, e_2) \\
        (l, p) \rulearrow (I, e)}
      {
        \splitfrac
            {(l, \mbox{\lstinline'\\exists integer i; t1 <= i < t2 && p'})
              \rulearrow
            }
            {
              (I_1 \concat I_2\concat
              (l,
              \mbox{\lstinline'int var_n = 0; for('}
              \underline{\Zinit \mbox{\lstinline'i_n = e1'} \Zclear}
              \semicolon
              \underline{\mbox{\lstinline'i_n < e2'} \Zclear}
              \mbox{\lstinline' && !var_n;'}
              \underline{\mbox{\lstinline'i_n++'} \Zclear}
              \mbox{\lstinline')'} \bopen)
              \concat I \concat (l,
              \mbox{\lstinline'var_n = e;'} \bclose),
              \mbox{\lstinline'var_n'})
            }
      }
    }
  }
  \caption{Règles de traduction pour les prédicats quantifiés}
  \label{fig:quantif}
\end{figure*}
