\begin{figure}[bt]
  \scriptsize{
    {\myinference[$\alpha$-assert]
      {(l, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
      {(l, \mbox{\lstinline'assert p;'})
        \rulearrow I \concat (l, \mbox{\lstinline'fassert(e);'})}
    }

    {\myinference[$\alpha$-check-pre\hspace{-2mm}]
      {(Beg_f, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
      {(Beg_f, \mbox{\lstinline'requires p;'})
        \rulearrow
        I \concat (Beg_f, \mbox{\lstinline'fassert(e);'})}
    }

    {\myinference[$\alpha$-assume-pre\hspace{-2mm}]
      {(Beg_f, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
      {(Beg_f, \left \{\hspace{-2mm}
        \begin{array}{r}
          \mbox{\lstinline'typically'} \\
          \mbox{\lstinline'requires'}
        \end{array} \mbox{\lstinline'p;'} \right.
        )
        \rulearrow
        I \concat (Beg_f, \mbox{\lstinline'fassume(e);'})}
    }

    {\myinference[$\alpha$-check-assigns]
      {}
      {
        \splitfrac{
          (End_f, \mbox{\lstinline'assigns X;'}) \rulearrow
        } {
          I \concat
          \forall (\mbox{\lstinline'x'}:ctype) \in G-X:
          (Beg_f, \mbox{\lstinline'ctype assigns_x = x;'})
          \concat (End_f, \mbox{\lstinline'fassert(x == assigns_x);'})
        }
      }
    }

    {\myinference[$\alpha$-check-post]
      {(End_f, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
      {(End_f, \mbox{\lstinline'ensures p;'})
        \rulearrow
        I \concat (End_f, \mbox{\lstinline'fassert(e);'})}
    }
  }
  \caption{Règles de traduction pour les assertions, pré-/postconditions et
    assigns}
  \label{fig:annot}
\end{figure}

\begin{figure*}[bt]
  \scriptsize{
    {\myinference[$\alpha$-check-loop-assigns]
      {}
      {
        \splitfrac{
          (l, \mbox{\lstinline'loop assigns X;'}) \rulearrow
        }{
          I \concat
          \forall (\mbox{\lstinline'x'}:ctype) \in G-X:
          (BegIter_l, \mbox{\lstinline'ctype assigns_x = x;'})
          \concat (EndIter_l, \mbox{\lstinline'fassert(x == assigns_x);'})
        }
      }
    }

    {\myinference[$\alpha$-check-invariant]
      {(l, \mbox{\lstinline'p'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
        (EndIter_l, \mbox{\lstinline'p'}) \rulearrow
        (I_2, \mbox{\lstinline'e2'})}
      {
        (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
        I_1 \concat (l, \mbox{\lstinline'fassert(e1);'})
        \concat I_2 \concat (EndIter_l, \mbox{\lstinline'fassert(e2);'})
      }
    }

    {\myinference[$\alpha$-variant]
      {
        (BegIter_l, \mbox{\lstinline't'}) \rulearrow
        (I_1, \mbox{\lstinline'e1'}) \\
        (EndIter_l, \mbox{\lstinline't'}) \rulearrow
        (I_2, \mbox{\lstinline'e2'})
      }
      {
        \splitfrac
            {
              (l, \mbox{\lstinline'loop variant t;'}) \rulearrow
            }
            {
              I_1 \concat ((BegIter_l,
              \mbox{\lstinline'fassert('}
              \underline{\mbox{\lstinline'0 <= e1'}}
              \mbox{\lstinline');' }
              \underline{\Zinit \mbox{\lstinline'old_variant = e1'} \Zclear}
              \semicolon)
              \concat I_2
              \concat(EndIter_l,
              \mbox{\lstinline'fassert('}
              \underline{\mbox{\lstinline'e2'}\Zclear
                \mbox{\lstinline'< old_variant'} \Zclear}
              \mbox{\lstinline');'})
            }
      }
    }
  }
  \caption{Règles de traduction pour les annotations de boucle : invariants,
    variant et assigns}
  \label{fig:loop-annot}
\end{figure*}


\begin{figure*}[bt]
  \scriptsize{
    {\myinference[$\tau$-old\hspace{-2mm}{}]
      {}
      {(l, \mbox{\lstinline'\\old(x)'}:ctype) \rulearrow
        (\emptylist, \mbox{\lstinline'old_x'})}
    }
    {\myinference[$\tau$-var\hspace{-2mm}{}]
      {}
      {(l, \mbox{\lstinline'x'}:ctype) \rulearrow
        (\emptylist, \mbox{\lstinline'x'})}
    }

    {\myinference[$\tau$-old-val\hspace{-2mm}{}]
      {(l, \mbox{\lstinline't'}:int) \rulearrow (I, \mbox{\lstinline'e'})}
      {(l, \mbox{\lstinline'\\old(*(x+t))'}:ctype) \rulearrow
        (I,\mbox{\lstinline'*(old_val_x+e)'})}
    }

    {\myinference[$\tau$-res\hspace{-2mm}{}]
      {}
      {(l, \mbox{\lstinline'\\result'}:ctype) \rulearrow
        (\emptylist, \mbox{\lstinline'res'})}
    }
    {\myinference[$\tau$-const\hspace{-1mm}{}]
      {}
      {(l, \mbox{\lstinline'cst'}:\mathbb{Z}) \rulearrow
        ((l, \underline{\Zinit\mbox{\lstinline'var_n = cst'}}),
        \mbox{\lstinline'var_n'})}
    }
  }
  \caption{Règles de traduction pour les constantes, identificateurs,
    \lstinline'result' et \lstinline'old'}
  \label{fig:const-id}
\end{figure*}

\begin{figure*}[bt]
  \scriptsize{
    {\myinference[$\tau$-coerce$_1$]
      {(l, \mbox{\lstinline't'}:\mathbb{Z}) \rulearrow
        (I, \mbox{\lstinline'e'})}
      {
        (l, (int)(t : \mathbb{Z})) \rulearrow
        (I \concat (l,
        \mbox{\lstinline'int var_n ='}~
        \underline{\mbox{\lstinline'e'} \Zclear}
        \semicolon
        ), \mbox{\lstinline'var_n'})
      }
    }
    {\myinference[$\tau$-coerce$_2$]
      {(l, \mbox{\lstinline't'}:int) \rulearrow (I, \mbox{\lstinline'e'})}
      {(l, (\mathbb{Z})(t:int)) \rulearrow (I \concat (l,
        \underline{\Zinit \mbox{\lstinline'var_n = e'}}
        \semicolon
        ), \mbox{\lstinline'var_n'})}
    }
  }
  \caption{Règles de traduction pour les conversions}
  \label{fig:coerce}
\end{figure*}

\begin{figure*}[bt]
  \scriptsize{
    {\myinference[$\tau$-binop$_1$]
      {(l, \mbox{\lstinline't1'}:ptr) \rulearrow (I_1, \mbox{\lstinline'e1'})
        \quad
        (l, \mbox{\lstinline't2'}:int) \rulearrow (I_2, \mbox{\lstinline'e2'})
        \quad
        op \in \{+, -\}}
      {(l, (\mbox{\lstinline't1 op t2'}):ptr) \rulearrow
        (I_1 \concat I_2 \concat (l, ptr~\mbox{\lstinline'var_n = e1 op e2;'}),
        \mbox{\lstinline'var_n'})}
    }

    {\myinference[$\tau$-unop$_1$]
      {(l, \mbox{\lstinline't'}:ptr) \rulearrow (I, \mbox{\lstinline'e'})}
      {(l, (\mbox{\lstinline'* t'}): ctype) \rulearrow
        (I \concat (l, ctype~\mbox{\lstinline'var_n = *e;'}),
        \mbox{\lstinline'var_n'})}
    }

    {\myinference[$\tau$-binop$_2$]
      {(l, \mbox{\lstinline't1'}:\mathbb{Z}) \rulearrow
        (I_1, \mbox{\lstinline'e1'}) \quad
        (l, \mbox{\lstinline't2'}:\mathbb{Z}) \rulearrow
        (I_2, \mbox{\lstinline'e2'}) \quad
        op \in \{\mathtt{==}, \mathtt{!=}, \mathtt{<},
        \mathtt{<=}, \mathtt{>}, \mathtt{>=}, \mathtt{||},
        \mathtt{\&\&}\}}
      {(l, (\mbox{\lstinline't1 op t2'}):int) \rulearrow
        (I_1 \concat I_2 \concat (l,
        \mbox{\lstinline'int var_n ='}~
        \underline{\mbox{\lstinline'e1'}\Zclear \mbox{\lstinline'op e2'}\Zclear}
        \semicolon
        ), \mbox{\lstinline'var_n'})}
    }

    {\myinference[$\tau$-unop$_2$]
      {(l, \mbox{\lstinline't'}) \rulearrow (I, \mbox{\lstinline'e'})}
      {(l, (\mbox{\lstinline'\! t'})) \rulearrow
        (I \concat (l, \mbox{\lstinline'int var_n = \! e;'}),
        \mbox{\lstinline'var_n'})}
    }

    {\myinference[$\tau$-binop$_3$]
      {(l, \mbox{\lstinline't1'}:\mathbb{Z}) \rulearrow
        (I_1, \mbox{\lstinline'e1'}) \quad
        (l, \mbox{\lstinline't2'}:\mathbb{Z})
        \rulearrow (I_2, \mbox{\lstinline'e2'}) \quad
        op \in \{\mathtt{+}, \mathtt{-}, \mathtt{/}, \mathtt{\%},
        \mathtt{<<}, \mathtt{>>}, \mathtt{|}, \mathtt{\&},
        \mathbin{\char`\^}\}}
      {(l, (\mbox{\lstinline't1 op t2'}):\mathbb{Z}) \rulearrow
        (I_1 \concat I_2 \concat (l,
        \underline{\Zinit \mbox{\lstinline'var_n = e1'} \Zclear
          \mbox{\lstinline'op e2'} \Zclear}
        \semicolon
        ), \mbox{\lstinline'var_n'})}
    }

    {\myinference[$\tau$-unop$_3$]
      {(l, \mbox{\lstinline't'}:\mathbb{Z}) \rulearrow (I, \mbox{\lstinline'e'})
        \quad
        op \in \{ -, \sim\}}
      {(l, (\mbox{\lstinline'op t'}):\mathbb{Z}) \rulearrow
        (I
        \concat (l, \underline{\Zinit \mbox{\lstinline'var_n = op e'} \Zclear}),
        \mbox{\lstinline'var_n'})}
    }

    {\myinference[$\tau$-if]
      {(l, \mbox{\lstinline't1'}:\mathbb{Z}) \rulearrow
        (I_1, \mbox{\lstinline'e1'}) \\
        (l, \mbox{\lstinline't2'}:\mathbb{Z}) \rulearrow
        (I_2, \mbox{\lstinline'e2'}) \\
        (l, \mbox{\lstinline't3'}:\mathbb{Z}) \rulearrow
        (I_3, \mbox{\lstinline'e3'})}
      {
        (l, (\mbox{\lstinline't1 ? t2 : t3'}):\mathbb{Z})
        \rulearrow
        (I_1
        \concat (l,
        \mbox{\lstinline'if('}
        \underline{\mbox{\lstinline'e1'}\Zclear \mbox{\lstinline' \!= 0'}}
        \mbox{\lstinline')'} \bopen
        I_2
        \concat
        (l, \underline{\Zinit \mbox{\lstinline'var_n = e2'} \Zclear}
        \semicolon )
        \bclose
        \mbox{\lstinline'else'} \bopen
        I_3
        \concat
        (l, \underline{\Zinit \mbox{\lstinline'var_n = e3'} \Zclear}
        \semicolon )
        \bclose ),
        \mbox{\lstinline'var_n'})
      }
    }
  }
  \caption{Règles de traduction pour les opérations unaires et binaires}
  \label{fig:op}
\end{figure*}

\begin{figure*}[bt]
  \scriptsize{
    {\myinference[$\tau$-sum]
      {(l, \mbox{\lstinline't1'}:\mathbb{Z}) \rulearrow
        (I_1, \mbox{\lstinline'e1'}) \\
        (l, \mbox{\lstinline't2'}:\mathbb{Z}) \rulearrow
        (I_2, \mbox{\lstinline'e2'}) \\
        (l, \mbox{\lstinline't3'}:\mathbb{Z}) \rulearrow
        (I_3, \mbox{\lstinline'e3'})}
      {
        \splitfrac
            {(l,
              (\mbox{\lstinline'\\sum(t1, t2, \\lambda integer i; t3)'}):
              \mathbb{Z})
              \rulearrow}
            {
              (I_1 \concat I_2
              \concat
              (l, \underline{\Zinit \mbox{\lstinline'var_n = 0'}} \semicolon )
              \concat
              (l, \mbox{\lstinline' for('}
              \underline{\Zinit \mbox{\lstinline'i_n = e1'} \Zclear}\semicolon
              \underline{\mbox{\lstinline'i_n <= e2'} \Zclear}\semicolon
              \underline{\mbox{\lstinline'i_n++'} \Zclear}
              \mbox{\lstinline')'} \bopen
              I_3
              \concat
              (l,
              \underline{\mbox{\lstinline'var_n += e3'} \Zclear}\semicolon )
              \bclose
              ),
              \mbox{\lstinline'var_n'})
            }
      }
    }

    {\myinference[$\tau$-numof]
      {(l, \mbox{\lstinline't1'}:\mathbb{Z}) \rulearrow
        (I_1, \mbox{\lstinline'e1'}) \\
        (l, \mbox{\lstinline't2'}:\mathbb{Z}) \rulearrow
        (I_2, \mbox{\lstinline'e2'}) \\
        (l, \mbox{\lstinline't3'}:int) \rulearrow (I_3, \mbox{\lstinline'e3'})}
      {
        \splitfrac
            {(l,
              (\mbox{\lstinline'\\numof(t1, t2, \\lambda integer i; t3)'}):
              \mathbb{Z})
              \rulearrow}
            {
              (I_1 \concat I_2
              \concat
              (l,
              \underline{\Zinit \mbox{\lstinline'var_n = 0'}}
              \semicolon )
              \concat
              (l, \mbox{\lstinline' for('}
              \underline{\Zinit \mbox{\lstinline'i_n = e1'} \Zclear}
              \semicolon
              \underline{\mbox{\lstinline'i_n <= e2'} \Zclear}
              \semicolon
              \underline{\mbox{\lstinline'i_n++'} \Zclear}
              \mbox{\lstinline')'} \bopen
              I_3
              \concat (l,
              \mbox{\lstinline'if(e3)'}
              \bopen
              (l, \underline{\mbox{\lstinline'var_n++'}} \semicolon)
              \bclose )
              \bclose
              ),
              \mbox{\lstinline'var_n'})
            }
      }
    }
  }
  \caption{Règles de traduction pour les fonctions logiques \lstinline'sum' et
    \lstinline'numof'}
  \label{fig:builtin}
\end{figure*}

\begin{figure*}[bt]
  \scriptsize{
    {\myinference[$\pi$-equiv]
      {(l, \mbox{\lstinline'p1'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
        (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'})}
      {(l, \mbox{\lstinline'p1 <==> p2'})
        \rulearrow
        (I_1 \concat I_2 \concat
        (l, \mbox{\lstinline'int var_n = ((!e1 || e2) && (!e2 || e1));'}),
        \mbox{\lstinline'var_n'})}
    }

    {\myinference[$\pi$-and]
      { (l, \mbox{\lstinline'p1'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
        (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'}) }
      { (l, \mbox{\lstinline'p1 && p2'}) \rulearrow
        (I_1 \cdot (l, \mbox{\lstinline'int var_n = e1;'}) \cdot
        (l, \mbox{\lstinline'if(var_n)'} \bopen I_2 \cdot
        (l, \mbox{\lstinline'var_n = e2;'}) \bclose ),
        \mbox{\lstinline'var_n'})
      }
    }

    {\myinference[$\pi$-true]
      {}
      {(l, \mbox{\lstinline'\\true'}) \rulearrow
        ((l, \mbox{\lstinline'int var_n = 1;'}), \mbox{\lstinline'var_n'})}
    }

    {\myinference[$\pi$-false]
      {}
      {(l, \mbox{\lstinline'\\false'}) \rulearrow
       ((l, \mbox{\lstinline'int var_n = 0;'}), \mbox{\lstinline'var_n'})}
    }

    {\myinference[$\pi$-not]
      {(l, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
      {(l, \mbox{\lstinline'\!p'}) \rulearrow
        (I \concat (l, \mbox{\lstinline'int var_n = \!e;'}),
        \mbox{\lstinline'var_n'})}
    }

    {\myinference[$\pi$-or]
      {(l, \mbox{\lstinline'p1'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
        (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'})}
      {(l, \mbox{\lstinline'p1 || p2'})
        \rulearrow
        (I_1 \concat (l, \mbox{\lstinline'int var_n = e1;'})
        \concat (l, \mbox{\lstinline'if(!var_n)'} \bopen
        I_2
        \concat (l, \mbox{\lstinline'var_n = e2;'}) \bclose),
        \mbox{\lstinline'var_n'})
      }
    }

    {\myinference[$\pi$-impl]
      {(l, \mbox{\lstinline'p1'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
        (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'})}
      {(l, \mbox{\lstinline'p1 ==> p2'})
        \rulearrow
        (I_1 \concat (l, \mbox{\lstinline'int var_n = 1;'})
        \concat (l, \mbox{\lstinline'if(e1)'} \bopen
        I_2
        \concat (l, \mbox{\lstinline'var_n = e2;'}) \bclose),
        \mbox{\lstinline'var_n'})
      }
    }

    {\myinference[$\pi$-if]
      {(l, \mbox{\lstinline't'}:\mathbb{Z}) \rulearrow
        (I_1, \mbox{\lstinline'e1'}) \\
        (l, \mbox{\lstinline'p2'}) \rulearrow (I_2, \mbox{\lstinline'e2'}) \\
        (l, \mbox{\lstinline'p3'}) \rulearrow (I_3, \mbox{\lstinline'e3'})}
      {
        (l, \mbox{\lstinline't ? p2 : p3'}) \rulearrow
        (I_1 \concat (l, \mbox{\lstinline'int var_n;'})
        \concat (l,  \mbox{\lstinline'if('}
        \underline{\mbox{\lstinline'e1'}\Zclear \mbox{\lstinline' \!= 0'}}
        \mbox{\lstinline')'} \bopen
        I_2 \concat (l, \mbox{\lstinline'var_n=e2;'}) \bclose
        \mbox{\lstinline'else'} \bopen
        I_3 \concat (l, \mbox{\lstinline'var_n=e3;'}) \bclose),
        \mbox{\lstinline'var_n'})
      }
    }

    {\myinference[$\pi$-rel]
      {(l, \mbox{\lstinline't1'}:\mathbb{Z}) \rulearrow
        (I_1, \mbox{\lstinline'e1'}) \quad
        (l, \mbox{\lstinline't2'}:\mathbb{Z}) \rulearrow
        (I_2, \mbox{\lstinline'e2'}) \quad
        op \in \{\mathtt{<}, \mathtt{<=}, \mathtt{>}, \mathtt{>=},
        \mathtt{==}, \mathtt{!=}\}}
      {(l, \mbox{\lstinline't1 op t2'}) \rulearrow
        (I_1 \concat I_2 \concat (l,
        \mbox{\lstinline'int var_n ='}~
        \underline{\mbox{\lstinline' e1'} \Zclear \mbox{\lstinline' op e2'}
          \Zclear}
        \semicolon
        ), \mbox{\lstinline'var_n'})}
    }
  }
  \caption{Règles de traduction pour les prédicats simples}
  \label{fig:pred-logic}
\end{figure*}

\begin{figure*}[bt]
  \scriptsize{
    {\myinference[$\pi$-valid]
      {(l, \mbox{\lstinline't'}:ptr) \rulearrow (I, \mbox{\lstinline'e'}) }
      {(l, \mbox{\lstinline'\\valid(t)'}) \rulearrow
        (I \concat (l, \mbox{\lstinline'int var_n = fvalid(e);'}),
        \mbox{\lstinline'var_n'})
      }
    }

    {\myinference[$\pi$-valid-range]
      {(l, \mbox{\lstinline't1'}:ptr) \rulearrow (I_1, \mbox{\lstinline'e1'})
        \\
        (l, \mbox{\lstinline't2'}:int) \rulearrow (I_2, \mbox{\lstinline'e2'})
        \\
        (l, \mbox{\lstinline't3'}:int) \rulearrow (I_3, \mbox{\lstinline'e3'})
      } {
        (l, \mbox{\lstinline'\\valid(t1+(t2..t3))'}) \rulearrow
        (I_1 \concat I_2 \concat I_3
        \concat (l, \mbox{\lstinline'int var_n = fvalidr(e1,e2,e3);'}),
        \mbox{\lstinline'var_n'})
      }
    }
  }
  \caption{Règles de traduction pour les prédicats de validité mémoire}
  \label{fig:valid}
\end{figure*}

\begin{figure*}[bt]
  \scriptsize{
    {\myinference[$\pi$-forall]
      {
        (l, \mbox{\lstinline't1'} : \mathbb{Z}) \rulearrow
        (I_1, \mbox{\lstinline'e1'}) \\
        (l, \mbox{\lstinline't2'} : \mathbb{Z}) \rulearrow
        (I_2, \mbox{\lstinline'e2'}) \\
        (l, \mbox{\lstinline'p'}) \rulearrow (I_3, \mbox{\lstinline'e3'})
      }
      {
        \splitfrac {
          (l, \mbox{\lstinline'\\forall integer k; t1 <= k <= t2 ==> p'})
          \rulearrow
        } {
          \splitfrac {
            (I_1 \cdot I_2
            \cdot (l, \mbox{\lstinline'int var_n = 1;'})
            \cdot
            (l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} )
          } {
            \cdot
            (l, \mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e2'}}~ \mbox{\lstinline'&& var_n)'}
            \bopen
            I_3
            \cdot (l, \mbox{\lstinline'var_n = e3;'})
            \cdot (l, \underline{\mbox{\lstinline'k++'}} \semicolon)
            \bclose )
            \cdot
            (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon )
            \cdot
            (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon )
            \cdot
            (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon ),
            \mbox{\lstinline'var_n'})
          }
        }
      }
    }

    {\myinference[$\pi$-exists]
      {
        (l, \mbox{\lstinline't1'} : \mathbb{Z}) \rulearrow
        (I_1, \mbox{\lstinline'e1'}) \\
        (l, \mbox{\lstinline't2'} : \mathbb{Z}) \rulearrow
        (I_2, \mbox{\lstinline'e2'}) \\
        (l, \mbox{\lstinline'p'}) \rulearrow (I_3, \mbox{\lstinline'e3'})
      }
      {
        \splitfrac {
          (l, \mbox{\lstinline'\\exists integer k; t1 <= k <= t2 && p'})
          \rulearrow
        } {
          \splitfrac {
            (I_1 \cdot I_2
            \cdot (l, \mbox{\lstinline'int var_n = 0;'})
            \cdot (l, \Zinit \underline{\mbox{\lstinline'k = e1;'}} )
          } {
            \cdot
            (l, \mbox{\lstinline'while('}
            \underline{\mbox{\lstinline'k <= e2'}}~\mbox{\lstinline'&& !var_n)'}
            \bopen
            I_3
            \cdot (l, \mbox{\lstinline'var_n = e3;'})
            \cdot (l, \underline{\mbox{\lstinline'k++'}} \semicolon)
            \bclose )
            \cdot
            (l, \underline{\mbox{\lstinline'k'}} \Zclear \semicolon )
            \cdot
            (l, \underline{\mbox{\lstinline'e1'}} \Zclear \semicolon )
            \cdot
            (l, \underline{\mbox{\lstinline'e2'}} \Zclear \semicolon ),
            \mbox{\lstinline'var_n'})
          }
        }
      }
    }
  }
  \caption{Règles de traduction pour les prédicats quantifiés}
  \label{fig:quantif}
\end{figure*}
