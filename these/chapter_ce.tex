
\chapter{Génération de contre-exemples pour la preuve}
\label{sec:ce}

\chapterintro

Dans ce chapitre, nous identifions différentes sortes d'échecs de preuve et de
contre-exemples.
Nous présentons les transformations de programme permettant de produire les
contre-exemples par génération de tests, ainsi qu'une méthode de diagnostic des
échecs de preuve basée sur ces transformations.

\commentGP{TODO: plan}


\section{Exemple Illustratif}
\label{sec:ce-example}


Nous illustrons les problèmes qui se posent en vérification déductive de
programmes et les solutions que nous proposons sur le programme de la
figure~\ref{fig:rgf1}.
Ce programme est issu d'un travail de spécification formelle et de vérification
déductive~\cite{Genestier/TAP15}.
Il implémente un algorithme proposé par \cite[page 235]{Arndt/10}.
L'exemple de la figure~\ref{fig:rgf1} traite la génération de
{\em Restricted Growth Functions} (RGF), définies par la propriété exprimée par
le prédicat \eacsl \lstinline{is_rgf} aux lignes 1--3 de la
figure~\ref{fig:rgf1}, où la RGF $a$ est représentée par les valeurs du tableau
C correspondant.
Pour des raisons de lisibilité, certaines notations \eacsl sont remplacées par
des symboles mathématiques (par exemple, les mots-clés 
\lstinline[style=c]{\exists}, \lstinline[style=c]{\forall} and
\lstinline[style=c]{integer} sont respectivement notés $\exists$, $\forall$ et
$\mathbb{Z}$).


\begin{figure}[tb]
  \centering
  \lstinputlisting[multicols=2]{listings/rgf_0.c}
  \caption{Fonction de successeur pour les fonctions RGF\label{fig:rgf1}}
\end{figure}


La figure~\ref{fig:rgf1} montre une fonction sous vérification \lstinline{f} 
et une fonction auxiliaire \lstinline{g}.
La précondition de \lstinline{f} indique que \lstinline{a} est un tableau valide
de taille \lstinline{n>0} (lignes 24--25) et doit être une RGF (ligne 26).
La postcondition énonce que la fonction n'est autorisée à modifier que les
valeurs du tableau \lstinline{a} à l'exception de la première valeur
\lstinline{a[0]} (ligne 27), et que le tableau \lstinline{a} généré est toujours
une RGF (ligne 28).
De plus, si la fonction retourne 1 alors la RGF \lstinline{a} générée doit
respecter une propriété supplémentaire (lignes 29--33).
\lstinline{\at(a[j],Pre)} dénote la valeur de \lstinline{a[j]} dans l'état
\lstinline{Pre}, c'est-à-dire avant l'exécution de la fonction.


We focus now on the body of the function \lstinline{f} in
Fig.~\ref{fig:rgf1}. 
The loop on lines 39--40 goes through the array from right
to left to find the rightmost non-increasing element, that is,
the maximal  array index \lstinline{i} such that \lstinline{a[i] <= a[i-1]}.
If such an index \lstinline{i} is found,
the function increments \lstinline{a[i]} (line 43) and fills out the rest
of the array with \lstinline{0}'s (call to \lstinline{g}, line 44).
The loop contract (lines 36--38) specifies the interval of values of the loop variable,
the variable that the loop can modify as well as a loop variant 
that can be used to ensure the termination of the loop.
The loop variant expression must be non-negative whenever an iteration starts,
and strictly decrease after it.

The function \lstinline{g} is used to fill the array with zeros to the right of index \lstinline{i}.
In addition to size and validity constraints (lines 9--10),
its precondition requires that the elements of \lstinline{a} up to index  \lstinline{i}
form an RGF (lines 11--12). 
The function is allowed to modify the elements of \lstinline{a} starting from the index \lstinline{i+1} (line 13)
and generates an RGF (line 14).
The loop invariants 
indicate the value interval of the loop variable \lstinline{k} (line 17), 
and state that the property \lstinline{is_rgf} is satisfied
up to \lstinline{k} (line 18).
This invariant allows a deductive verification tool to deduce the postcondition.
The annotation \lstinline{loop assigns} (line 19) says that the only values the loop can
change are \lstinline{k} and the elements of \lstinline{a} starting from the index \lstinline{i+1}.
The term \lstinline{n-k} is a variant of the loop (line 20).

The \acsl lemma \lstinline'max_rgf' on lines 5--7
states
that if an array is an RGF, then each of its elements is at most equal to its
index.
This lemma is not proved as such by \Wp but can be used to ensure the absence of
overflow at line 43.


\section{Kinds of Proof Failures and Counter-Examples}
\label{sec:ce-definitions}


An annotation
cannot be proved for all inputs if there are inputs
for which the property does not hold.
The notion of \emph{counter-example} depends on the way annotations are evaluated.
The diagnosis of proof failures 
based on the prover's counter-examples can be imprecise
since from the prover's point of view,
the code of callees and loops in $f$ is replaced by the corresponding
subcontracts.
To make this diagnosis more precisely, we propose to 
take into account their code as well as their contracts, and to treat both by testing.
In this section, we define three kinds of 
proof failure reasons, two kinds of counter-examples
and associated detection techniques.

Let $P$ be a C program annotated in \eacsl, 
and $f$ the function under verification in $P$.
$f$ is assumed to be recursion-free.
This function may call other functions, let $g$ denote any of them.
A \emph{test datum} $V$ for $f$ is a vector of values for all input variables of $f$.
We use the general term of a \emph{contract} 
to designate the set of \eacsl annotations describing a loop or a function.
A function contract is composed of pre- and postconditions including \eacsl clauses
\lstinline{requires}, \lstinline{assigns} and
\lstinline{ensures}  (cf. lines 24--33 in Fig.~\ref{fig:rgf1}).
A loop contract is composed of \lstinline{loop invariant},
\lstinline{loop variant} and \lstinline{loop assigns} clauses
(cf. lines 17--20 in Fig.~\ref{fig:rgf1}).
A \emph{non-imbricated} loop (resp. function, assertion) in $f$ is a loop
 (resp. function called, assertion) in $f$ outside any loop in
$f$. A \emph{subcontract for $f$} is the contract of some non-imbricated loop or function
 in $f$. A \emph{non-imbricated annotation} in $f$ is either a
non-imbricated assertion or an annotation in a subcontract for $f$.
For instance, the function $f$ of Fig.~\ref{fig:rgf1} has two subcontracts:
the contract of the called function $g$ and the contract of the loop on lines 36--40.
The contract of the loop in $g$ on lines 17--21 is not a subcontract for $f$, but is a subcontract for $g$.

We assume it has been proved that the subcontracts for $f$ are respected:
the called functions in $f$ respect their contracts, and the loops in $f$  preserve their loop invariants
and respect all imbricated annotations.
Let $c_f$ denote the contract of $f$,
$\C$ the set of non-imbricated subcontracts for $f$,
and $\A$ the set of all non-imbricated annotations in $f$, that is, 
the annotations included in the contracts $\C\cup\{c_f\}$ as well as non-imbricated  assertions in $f$.


\begin{figure}[tb]
\begin{minipage}{0.4\columnwidth}
\begin{lstlisting}[mathescape]
/*@ requires P1;
    ensures P2; */
$Type_g$ g(...) {
  code1;
}
/*@ requires P5;
    ensures P6; */
$Type_f$ f(...) {
  code2;
  //@ loop invariant P3;
  while(b) {
    code3;
  }
  code4;
  //@ assert P4;
  code5;
}
\end{lstlisting}
\end{minipage}
\hspace{-6mm}
\begin{minipage}{0.07\columnwidth}$\to$\end{minipage}
\begin{minipage}{0.6\columnwidth}
\begin{lstlisting}[mathescape]
$Type_g$ g(...) {
  int pre_g; $Spec2Code$(P1, pre_g);
  fassert(pre_g);
  code1; 
  int post_g; $Spec2Code$(P2, post_g);
  fassert(post_g);
}
$Type_f$ f(...) {
  int pre_f; $Spec2Code$(P5, pre_f);
  fassume(pre_f);
  code2;
  int inv1; $Spec2Code$(P3, inv1);
  fassert(inv1);
  while(b) {
    code3;
    int inv2; $Spec2Code$(P3, inv2);
    fassert(inv2);
  }
  code4;
  int asrt; $Spec2Code$(P4, asrt);
  fassert(asrt);
  code5;
  int post_f; $Spec2Code$(P6, post_f);
  fassert(post_f);
}
\end{lstlisting}
\end{minipage}
\caption{(a) An annotated code, vs.  (b) its translation for \NCD}
\label{fig:NC-transf}
\end{figure}


\textbf{Non-compliance.}
A previous work~\cite{Petiot/SCAM14} formally described 
how to transform a C program $P$ annotated in \eacsl
into an instrumented program, denoted  $P^\NC$ in this paper,
on which we can apply test generation to produce test data %$V$
violating some annotations at runtime.
Fig.~\ref{fig:NC-transf} illustrates the translation of an annotated program $P$
into another C program, $P^{\NC}$, that is used to generate counter-examples 
during non-compliance detection (\NCD).
$P^\NC$ checks all annotations in $\A$ in the corresponding program locations
and reports any failure.
For instance, the postcondition $\textit{Post}_f$ of $f$
is evaluated by the following code inserted at the end of the function $f$ in $P^\NC$:
\begin{equation}\tag{$\dagger$}
\mbox{\lstinline[mathescape]'int post_f;  $\ Spec2Code$($\textit{Post}_f$, post_f); fassert(post_f);'}
\end{equation}
For an \eacsl predicate \lstinline[mathescape]'$\textit{P}$',
we denote by \lstinline[mathescape]'$Spec2Code$($\textit{P}$, b)'
the generated C code  evaluating the predicate
\lstinline[mathescape]'$\textit{P}$'
and assigning its validity status to the Boolean 
variable \lstinline[mathescape]'b' (see~\cite{Petiot/SCAM14} for details).
The function call \lstinline[mathescape]'fassert(b)'
is expanded into a conditional
statement \lstinline[mathescape]'if(b)' that reports the failure and exits 
whenever \lstinline[mathescape]'b' is false.
Similarly, preconditions and postconditions of a callee $g$
are evaluated respectively before and after executing the function $g$.
A loop invariant is checked before the loop (for being initially true) 
and after each loop iteration (for being preserved by the previous
loop iteration). 
An assertion is checked at its location.
To generate only test data  that respect
the precondition $\textit{Pre}_f$ of $f$,
it is checked  in the beginning of $f$ 
similarly to ($\dagger$)
except that \fassert
is replaced by \fassume
to assume the given condition.

\begin{definition}[Non-compliance] 
\label{def:NC}
We say that there is a \emph{non-compliance} between code and specification in $P$
if there exists  a test datum $V$ for $f$ respecting its precondition,
such that $P^{\NC}$ reports an annotation failure on $V$.
In this case, we say that $V$ is a \emph{non-compliance counter-example} (\NCCE).
\end{definition}

Test generation on the translated program $P^{\NC}$ 
can be used to generate \NCCE{}s (cf.~\cite{Petiot/SCAM14}).
We call this technique \emph{Non-Compliance Detection} (\NCD).
In this work we use the \pathcrawler test generator that
will try to cover all program paths.
Since the translation step has added a branch for the false
value of each annotation, \pathcrawler will try to cover at
least one path where the annotation does not hold.
(An optimization in \pathcrawler avoids covering the 
same \fassert failure several times.)
The \NCD step may have three outcomes. 
It returns (\nc,$V$) if an \NCCE $V$ has been found and
indicates the failing annotation.
Second, if it has managed to perform a complete exploration 
of all program paths without finding an \NCCE (cf. Sec. \ref{sec:framac}), it returns \no.
Otherwise, if only a partial exploration of program paths
has been performed (due to a timeout,
partial coverage criterion or any other limitation), it returns 
\textsf{?} (unknown).


\begin{figure}[tb]
\begin{minipage}{0.4\columnwidth}
\begin{lstlisting}[mathescape]
//@ assigns k1,...,kN;
//@ ensures P;
$Type_g$ g(...){ code1; }




$Type_f$ f(...){ code2;
  g($Args_g$);
  code3; }
\end{lstlisting}
\end{minipage}
\hspace{-6mm}
\begin{minipage}{0.07\columnwidth}$\to$\end{minipage}
\begin{minipage}{0.6\columnwidth}
\begin{lstlisting}[mathescape]
$Type_g$ g_swd(...){
  k1=Nondet(); ... kN=Nondet();
  $Type_g$ ret = Nondet();
  int post; $Spec2Code$(P, post);
  fassume(post); return ret;
} //respects contract of g
$Type_g$ g(...){ code1; }
$Type_f$ f(...){ code2;
  g_swd($Args_g$);
  code3; }
\end{lstlisting}
\end{minipage}
\caption{(a) A contract $c\in\C$ of callee $g$ in $f$, vs. (b) its translation
for \CWD}
\label{fig:CW-transf-functions}
\end{figure}



\begin{figure}[tb]
\begin{minipage}{0.4\columnwidth}
\begin{lstlisting}[mathescape]
$Type_f$ f(...){ code1;
  //@ loop assigns x1,...,xN;
  //@ loop invariant I; 
  while(b){ code2; }
  code3; }
\end{lstlisting}
\end{minipage}
\hspace{-6mm}
\begin{minipage}{0.07\columnwidth}$\to$\end{minipage}
\begin{minipage}{0.6\columnwidth}
\begin{lstlisting}[mathescape]
$Type_f$ f(...){ code1;
  x1=Nondet(); ... xN=Nondet();
  int inv1; $Spec2Code$(I, inv1);
  fassume(inv1 &$ $& !b); //respects l$ $oop contract
  code3; }
\end{lstlisting}
\end{minipage}
\caption{(a) A contract $c\in\C$ of a loop in $f$, vs. 
(b) its translation
for \CWD}
\label{fig:CW-transf-loops}
\end{figure}

\textbf{Subcontract weakness.}
To treat the contracts of called functions and loops in $\C$
instead of their code,
we use another program transformation of $P$ producing a new program $P_\all^{\CW}$.
It requires a (loop) assigns clause in any subcontract
(that is anyway necessary for the proof of any really interesting code).
For all non-imbricated function calls and loops in $f$,
their code is replaced by a new one as follows.

For the contract $c\in\C$ of a called function $g$ in $f$, 
the program transformation  (illustrated by Fig.~\ref{fig:CW-transf-functions})
generates a new function \lstinline{g_swd} with the same signature 
whose code simulates any possible behavior respecting the postcondition in $c$, 
and replaces all calls to $g$ by  a call to \lstinline{g_swd}.
First, \lstinline{g_swd} allows any of the variables 
(or, more generally, left-values) present in
the \lstinline{assigns} clause of $c$ to change its value 
(line 2 in Fig.\ref{fig:CW-transf-functions}(b)).
It can be realized by assigning a non-deterministic 
value of the appropriate type
using a dedicated function, denoted here by \lstinline{Nondet()}
(or simply by adding an array of fresh input variables and reading
a different value for each use and each function invocation).
If the return type of $g$ is not \lstinline{void},
another non-deterministic value is read for the returned value
\lstinline{ret} (line 3 in Fig.\ref{fig:CW-transf-functions}(b)).
Finally, the validity of the postcondition is evaluated (taking into
account these new non-deterministic values) 
and assumed
in order to consider only executions that respect 
the postcondition, and
the function returns (lines 4--5 in Fig.\ref{fig:CW-transf-functions}(b)).

Similarly, for the contract $c\in\C$ of a loop in $f$, 
the program transformation  
replaces the code of the loop by 
another code that simulates any possible behavior respecting $c$, that is, 
ensuring the ``loop postcondition'' $I\wedge \neg b$ after the loop as shown in Fig.~\ref{fig:CW-transf-loops}.
In addition, the transformation treats in the same way as in $P^{\NC}$
all other annotations in $\A$:
preconditions of called functions, initial loop invariant verifications 
and the  pre- and postcondition of $f$
(they are not shown 
in Fig. \ref{fig:CW-transf-functions}(b) and \ref{fig:CW-transf-loops}(b)).

\begin{definition}[Global subcontract weakness] 
\label{def:CW}
We say that $P$ has a \emph{global subcontract weakness} for $f$ 
if there exists a test datum $V$ for $f$ respecting its precondition,
such that $P^{NC}$ does not report any annotation failure on $V$,
while $P_{all}^{\CW}$ reports an annotation failure on $V$.
In this case, we say that $V$ is a 
\emph{global subcontract weakness counter-example} (\CWCE)
for the set  of subcontracts $\C$.
\end{definition}

Notice that we do not consider the same counter-example as an \NCCE  and 
a \CWCE. Indeed, even if some counter-examples may illustrate both a
subcontract weakness and a non-compliance, we consider that
non-compliances usually come
from a direct conflict of the code and the specification
and should be addressed first, while 
contract weaknesses are often more subtle and will be
easier to address when non-compliances are eliminated.

Again, test generation can be applied on  $P_{\all}^{\CW}$ to generate
global \CWCE candidates. When it finds a test datum $V$ such that 
$P_{\all}^{\CW}$ fails on $V$, we use runtime assertion checking:
if $P^{\NC}$ fails on $V$, then
$V$ is classified as an \NCCE, otherwise  $V$ is a global \CWCE.
We call this technique \emph{Global Contract Weakness Detection} for the set of 
all subcontracts, denoted $\CWD_{\all}$. 
The $\CWD_{\all}$ step may have four outcomes. 
It returns (\nc,$V$) if an \NCCE $V$ has been found,
and  (\cw,$V$) if $V$ has been finally classified as a \CWCE.
If it has managed to perform a complete exploration 
of all program paths without finding an \CWCE, it returns \no.
Otherwise, if only a partial exploration of program paths
has been performed it returns \textsf{?} (unknown).


\begin{figure}[tb]
  \begin{minipage}{0.5\columnwidth}
    \lstinputlisting{listings/ex1.c}
    \caption{Absence of \CWCE{}s for any single subcontract does not imply absence of global \CWCE{}s}
    \label{fig:contracts-ex1}
  \end{minipage}
  \hspace{4mm}
  \begin{minipage}{0.5\columnwidth}
    \lstinputlisting{listings/ex2.c}
    \caption{Global \CWCE{}s do not help to find precisely a too weak subcontract}
    \label{fig:contracts-ex2}
  \end{minipage}
  \caption{Two examples with several subcontracts}
  \label{fig:many-contracts}
\end{figure}


A global \CWCE indicates a global subcontract weakness but
does not explicitly identify which single subcontract $c\in\C$ is too 
weak.
To do that, we propose another program transformation of $P$ into
an instrumented program  $P_c^{\CW}$.
It is realized by replacing only one non-imbricated function call or loop 
by the code respecting the postcondition of corresponding subcontract $c$ 
(as indicated in Fig. \ref{fig:CW-transf-functions} and \ref{fig:CW-transf-loops})
and transforming other annotations in $\A$ as in $P^{\NC}$.

\begin{definition}[Single subcontract weakness] 
\label{def:CW}
Let $c$ be a subcontract for $f$.
We say that $c$ is a \emph{too weak subcontract}
(or has a \emph{single subcontract weakness}) for $f$ 
if there exists a test datum $V$ for $f$ respecting its precondition,
such that $P^{\NC}$ does not report any annotation failure on $V$,
while $P_c^{\CW}$ reports an annotation failure on $V$.
In this case, we say that $V$ is a \emph{single subcontract weakness counter-example} (\CWCE)
for the subcontract  $c$ in $f$.
\end{definition}

For any subcontract $c\in\C$, test generation can be separately applied on  $P_{c}^{\CW}$ to generate
single \CWCE candidates and, if one is generated, check it on $P_{\all}^{\CW}$ to 
classify it as an \NCCE or a \CWCE.
We call this technique \emph{Single Contract Weakness Detection}
for individual subcontracts one after another, denoted $\CWD_{\each}$. 
The $\CWD_{\each}$ step may have three outcomes. 
It returns (\nc,$V$) if an \NCCE $V$ has been found,
and (\cw,$V$) if $V$ has been finally classified as a single \CWCE for some subcontract $c$.
Otherwise, it returns \textsf{?} (unknown), since even after an exhaustive path testing
the absence of single \CWCE for any individual subcontract $c$ does not imply
the absence of a global \CWCE.

Sometimes $\CWD_\each$ cannot exhibit a subcontract weakness for a single subcontract
while there is a global subcontract weakness for all of them at once.
For example in Fig.~\ref{fig:contracts-ex1},
if we apply $\CWD_\each$ to any of the subcontracts, we always have
\lstinline'x >=  \old(x)+5' at the end of $f$
(we add $1$ to $x$ by executing the translated subcontract,
and add $2$ twice by executing the other two functions' code),
so the postcondition of \lstinline'f' holds and no weakness is detected.
If we run  $\CWD_\all$  to consider all subcontracts at once, we only get
\lstinline'x>= \old(x)+3' after executing the three subcontracts, and can exhibit a counter-example.

On the other hand, running  $\CWD_\all$
produces a global \CWCE that does not indicate which one of the subcontracts is too weak,
while $\CWD_\all$ can sometimes be more precise.
For Fig.~\ref{fig:contracts-ex2},
since the three callees are replaced by their subcontracts for  $\CWD_\all$,  it is impossible
to find out which one is too weak.
On this example we can be more precise with $\CWD_\each$,
since only the replacement of the  subcontract of  \lstinline'g3' also leads to a \CWCE:
we can have \lstinline'x >= \old(x)+3' by executing
\lstinline'g1',  \lstinline'g2' and the subcontract of \lstinline'g3',
exhibiting the contract weakness of \lstinline'g3'.

We define a combined subcontract weakness detection technique, denoted \CWD, applying
first $\CWD_{\each}$ followed by  $\CWD_{\all}$ until the first \CWCE is found. 
$\CWD$ may have the same four outcomes as  $\CWD_{\all}$.
It allows us
to be both precise (and indicate when possible a single subcontract being too weak),
and complete (capable to find global \CWCE{}s even when there are no single subcontract weaknesses).

\textbf{Prover incapacity.}
When neither a non-compliance nor a global subcontract weakness
exist, we cannot demonstrate that it is impossible to prove the property.

\begin{definition}[Prover incapacity] 
\label{def:prov-incap}
We say that a proof failure in $P$ is due to a \emph{prover incapacity} 
if for any test datum $V$ for $f$ respecting its precondition,
neither $P^{NC}$ nor $P_{\all}^{\CW}$ report any annotation failure on $V$.
In other words, there is no \NCCE and no global \CWCE for $P$.
\end{definition}


\section{Diagnosis of Proof Failures using Structural Testing}
\label{sec:global-method}


\begin{figure}[tb]
  \begin{tabular}{c|c|l|c|c|c|l}
    & \multicolumn{2}{c|}{Impacted lines} & \multicolumn{3}{c|}{Verdicts}
    & \\ \hline
    \# & Line & Changes & Proof & \NCD & \CWD & Counter-example \\ \hline
    % example/rgf_0.c
    0 & -- & -- & \ok & -- & -- & -- \\ \hline
    % example/rgf_1.c
    1 & 26 & (deleted) & \ko & \nc & -- & \ce{$n=1; a[0]=-214739$} \\ \hline
    % example/rgf_2.c
    2 & 37 & \lstinline[style=c]'loop assigns i,a[1..n-1];'
    & \multirow{2}{*}{\ko} & \multirow{2}{*}{?} & \multirow{2}{*}{\cw}
    & {\scriptsize{$\langle$}}$n=2; nondet(a[1])=97157;$ \\
    &&&&&& $nondet(i)=0${\scriptsize{$\rangle$}} \\ \hline
    % example/rgf_3.c
    3 & 5--7 & (deleted) & \multirow{2}{*}{\ko} & \multirow{2}{*}{\no}
    & \multirow{2}{*}{\no} & \multirow{2}{*}{--} \\
    & 24 & \lstinline[style=c]'requires n>0 && n<21;' &&&& \\ \hline
    % example/rgf_4.c
    4 & 5--7 & (deleted) & \ko & ? & ? & -- \\
  \end{tabular}
  \caption{Method results for different versions of the illustrating example.}
  \label{tab:versions-rgf}
\end{figure}


\tikzstyle{bef}=[align=left,font=\ttfamily,node distance=3mm,text width=\textwidth*.4]
\tikzstyle{aft}=[align=left,font=\ttfamily,node distance=3mm,text width=\textwidth*.5]
\tikzstyle{acsl}=[inner sep=0mm,fill=blue!15]
\tikzstyle{genc}=[inner sep=0mm,fill=blue!15]

\tikzstyle{common}=[node distance=15mm,align=center]
\tikzstyle{test}=[draw,trapezium,trapezium left angle=70,
  trapezium right angle=-70,common]
\tikzstyle{op}=[draw,common]
\tikzstyle{data}=[draw,common,ellipse,node distance=35mm]
\tikzstyle{ce}=[data]
\tikzstyle{arrow}=[draw,->]
\tikzstyle{darrow}=[draw,o->]

\begin{figure}[b]
\begin{tikzpicture}
  \node(p) [data] {$P$};
  \node(ncd) [right of=p,test,node distance=1.7cm] {$\NCD(P)$};
  \node(ncce1) [below of=ncd,node distance=1.2cm] {\insertball{1} $V$ is \NCCE};
  \path[darrow] (ncd) -- node[left] {(\nc, $V$)} (ncce1);
  \path[arrow] (p) -- (ncd);
  \node(cwd) [right of=ncd,test,node distance=3.5cm] {$\CWD(P)$};
  \path[darrow] (ncd.east)+(0,.2) -- node[above] {\no} (cwd);
  \path[darrow] (ncd.east)+(-.1,-.2) -- node[below] {?} (cwd);

  % CWD did not found any CE
  \node(cov-2) [right of=cwd,test,node distance=3.5cm]
    {$\NCD(P)$=\no$\land$\\ $\CWD(P)$=\no};
  \path[darrow] (cwd.east)+(0,.2) -- node[above] {\no} (cov-2);
  \path[darrow] (cwd.east)+(-.1,-.2) -- node[below] {?} (cov-2);
  \node(qm) [right of=cov-2,node distance=2.4cm] {\insertball{4} \textsf{?}};
  \path[darrow] (cov-2) -- node[below] {false} (qm);
  \node(pw) [below of=cov-2,node distance=1.2cm]
    {\insertball{3} Prover incapacity};
  \path[darrow] (cov-2) -- node[right] {true} (pw);

  % CWD found a CE
  \node(cwce-ncce) [below of=cwd,node distance=1.2cm]
    {\insertball{2} $V$ is \CWCE};
  \path[darrow] (cwd) -- node[right] {(\cw, $V$)} (cwce-ncce);
  \path[darrow] (cwd) -- node[right] {~~~(\nc, $V$)} (ncce1);
\end{tikzpicture}
\caption{Combined verification methodology in case of a proof failure on $P$}
\label{fig:method-short}
\end{figure}


In this section, we present an overview of our method for 
diagnosis of proof failures, 
and illustrate it on several examples derived from the illustrative example
of Fig.~\ref{fig:rgf1}.


The proposed method is illustrated by Fig.~\ref{fig:method-short}.
Suppose that the proof of the annotated program $P$ fails for some non-imbricated annotation $a\in\A$.
The first step tries to find a non-compliance using \NCD. 
If found, it generates an \NCCE (marked by \insertball{1} in Fig.~\ref{fig:method-short})
and classifies the proof failure as a non-compliance.
If the first step cannot generate a counter-example,
the \CWD step combines $\CWD_\each$ and $\CWD_\all$ 
and tries to generate single \CWCE{}s, then global \CWCE{}s, 
until the first counter-example is generated and classified 
(either as an \NCCE \insertball{1} or a \CWCE \insertball{2}).
If no counter-example has been found, the last step checks the outcomes.
If both \NCD and \CWD have returned \textsf{no}, that is, 
both  $\NCD$  and $\CWD_\all$ have performed a complete path exploration 
without finding a counter-example,
the proof failure is classified as a prover incapacity \insertball{3} (cf. Def. \ref{def:prov-incap}).
Otherwise, it  remains unclassified \insertball{4}.
Fig.~\ref{tab:versions-rgf} summarizes the different cases.

The proof failure reason and the counter-examples, along with 
reported failing annotations or too weak subcontracts 
(not shown in the outcomes in Fig.~\ref{fig:method-short}) 
can be extremely helpful for the verification engineer. 
Suppose we prove in \Wp a modified version of the function $f$ of Fig.~\ref{fig:rgf1}
where the precondition at line 26 is missing.
The proof of the precondition of $g$ on line 12 for the call on line 44
fails without indicating a precise reason.
The \NCD step of \stady  generates an \NCCE (case \insertball{1},
\#1 in Fig.~\ref{tab:versions-rgf}) where \lstinline'is_rgf(a,n)'
is clearly false, and indicates the failing annotation (coming from line 12).  
That helps the verification engineer to easily undertand and fix the issue. 
Indeed, if an \NCCE is generated, there is no need to
try automatic proof or look for a too weak subcontract --- it will not help.
The reason of the proof failure is necessarily related 
to a non-compliance between 
non-imbricated code and annotations.

Let us suppose now that the clause on line 37 has been erroneously
written as follows: \lstinline'loop assigns i, a[1..n-1];'.
The loop on lines 39--40 still preserves its invariant. 
The code still respects the specification, and the \NCD step does not find any \NCCE.
Thanks to the replacement shown in Fig.~\ref{fig:CW-transf-loops},
$\CWD_\each$ for the subcontract of this loop will detect a single
subcontract weakness for the loop subcontract (case \insertball{2},
\#2 in Fig.~\ref{tab:versions-rgf}),
and fail to establish the 
precondition of $g$ (coming from line 12) for the call on line 44.
With the indication of the single \CWCE for the loop, 
the verification engineer will try to strengthen the indicated subcontract
and find the issue. Again, trying interactive proof or additional assertions or lemmas 
will be useless here since the property can obviously not be proved 
because of the counter-example.



Suppose now we want to prove the absence of overflow at line 43
of Fig.~\ref{fig:CW-transf-loops}, but the lemma on lines 5--7 
(that allows the prover to deduce this property) is missing.
The proof fails  without giving a precise reason since
the prover does not manage to deduce the right bounds on \lstinline{t[i]} by induction.
Neither \NCD nor \CWD can produce a counter-example, and
as the initial program has too many paths, their outcomes are \textsf{?}
(unknown) (case \insertball{4}, \#4 in Fig.~\ref{tab:versions-rgf}).
For such situations, \stady offers the possibility to reduce the input domain.
The verification engineer can add the \acsl clause 
\lstinline'typically n<5;' to reduce the array size 
for testing, that is ignored by the proof. 
Running \stady now allows the tool to finish the complete exploration of all
program paths (for \lstinline'n<5') both for \NCD and \CWD without finding a counter-example.
\stady classifies the proof failure for the program with 
the reduced domain as a prover incapacity (case \insertball{3},
\#3 in Fig.~\ref{tab:versions-rgf}).
That gives the verification engineer more confidence that the proof failure
has the same reason on the initial program for bigger sizes \lstinline{n}.
Indeed, when there is a counter-example for a very big datastructure size, 
in many case,  even if it cannot be guaranteed, 
there also exists another counter-example for smaller datastructures. 
The verification engineer prefers to  try interactive proof or adding an additional lemmas or assertions,
and does not waste time for looking for a bug or a too week subcontract.



%%%%%%%%%%%%%%%%% TODO

\begin{figure}[bt]
  \scriptsize{
    {\myinference[$\alpha$-assume-assigns]
      {}
      {(End_f, \mbox{\lstinline'assigns x;'})
        \rulearrow
        I \concat (End_f, \mbox{\lstinline'x = nondet();'})}
    }

    {\myinference[$\alpha$-assume-post]
      {(End_f, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
      {(End_f, \mbox{\lstinline'ensures p;'})
        \rulearrow
        I \concat (End_f, \mbox{\lstinline'fassume(e);'})}
    }
  }
  \caption{Règles de traduction pour les faiblesses de contrats :
    postconditions et assigns}
  \label{fig:assume-annot}
\end{figure}

La règle \textsc{$\alpha$-assume-assigns} suppose que toutes les l-values
présentes dans la clause \lstinline'assigns' ont changé de valeur : elle affecte
une nouvelle valeur non déterministe à chacune d'elle à la fin de la fonction.
La règle \textsc{$\alpha$-assume-post} suppose sa validité à la fin de la
fonction instrumentée.

\begin{figure}[bt]
  \scriptsize{
    {\myinference[$\alpha$-assume-loop-assigns]
      {}
      {(l, \mbox{\lstinline'loop assigns x;'})
        \rulearrow
        I \concat (l, \mbox{\lstinline'x = nondet();'})}
    }

    {\myinference[$\alpha$-assume-invariant-1]
      {(l, \mbox{\lstinline'p'}) \rulearrow (I, \mbox{\lstinline'e'})}
      {
        (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
        I \concat (l, \mbox{\lstinline'fassume(e && !loopcond);'})
      }
    }

    {\myinference[$\alpha$-assume-invariant-2]
      {(l, \mbox{\lstinline'p'}) \rulearrow (I_1, \mbox{\lstinline'e1'}) \\
        (EndIter_l, \mbox{\lstinline'p'}) \rulearrow
        (I_2, \mbox{\lstinline'e2'})}
      {
        (l, \mbox{\lstinline'loop invariant p;'}) \rulearrow
        I_1 \concat (l, \mbox{\lstinline'fassume(e1);'})
        \concat I_2 \concat (EndIter_l, \mbox{\lstinline'fassert(e2);'})
      }
    }
  }
  \caption{Règles de traduction pour les faiblesses de contrats :
    invariants et assigns de boucle}
  \label{fig:assume-loop-annot}
\end{figure}

La règle \textsc{$\alpha$-assume-loop-assigns} suppose que toutes les l-values
présentes dans la clause \lstinline'loop assigns' ont changé de valeur : une
nouvelle valeur non déterministe est affectée à chacune d'elle.
La règle \textsc{$\alpha$-assume-invariant-1} a vocation à remplacer toute la
boucle, elle suppose que le prédicat de l'invariant est vrai, ainsi que la
négation de la condition de boucle (appelée ici \lstinline'loopcond').
La règle \textsc{$\alpha$-assume-invariant-2} permet de supposer que la boucle
a déjà itéré un certain nombre de fois, elle suppose que l'invariant est vrai
avant la boucle, et vérifie l'invariant à la fin de chaque itération.


\section*{Conclusion du chapitre}

\commentGP{TODO}
